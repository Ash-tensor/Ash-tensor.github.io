<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.3.2">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2024-01-11T09:19:05+09:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">Tensor Studio</title><subtitle>텐서 스튜디오</subtitle><author><name>ash tensor</name></author><entry><title type="html">[HTML/JAVASCRIPT] 아주 간단한 버켓리스트 페이지 제작</title><link href="http://localhost:4000/web/2024/01/10/bucketlist.html" rel="alternate" type="text/html" title="[HTML/JAVASCRIPT] 아주 간단한 버켓리스트 페이지 제작" /><published>2024-01-10T00:00:00+09:00</published><updated>2024-01-10T00:00:00+09:00</updated><id>http://localhost:4000/web/2024/01/10/bucketlist</id><content type="html" xml:base="http://localhost:4000/web/2024/01/10/bucketlist.html"><![CDATA[<p>2024년이 시작한지도 벌써 10일이 지나긴 했지만, 새해를 맞아 새해의 목표를 세우는 것은 필요한 것 같다. 막연하게 생각했었던 새해 목표도 구체적으로 정리하고, 일일 목표를 세우기 위해서라도.</p>

<p>그래서 간단한 2024년 버켓리스트 페이지를 제작했다! 제작하면서 기초적인 HTML 태그, javascript, css 지식을 정리할 수 있는 좋은 기회였다.</p>

<h1 id="완성된-버켓리스트">완성된 버켓리스트</h1>

<iframe src="https://ash-tensor.github.io/bucketlist/" width="100%" height="800"></iframe>

<p>기능이라고 할 것도 없이 간단한데, 클릭을 하면 완료 도장이 찍히는 것이다.</p>

<h2 id="코드">코드</h2>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&lt;!DOCTYPE html&gt;
&lt;html&gt;

&lt;head&gt;
&lt;meta charset="utf-8"&gt;
&lt;meta name="viewport" content="width=device-width"&gt;
&lt;title&gt;2024 버킷리스트&lt;/title&gt;
&lt;link href="style.css" rel="stylesheet" type="text/css"&gt;
&lt;style&gt;
    @import url("https://fonts.googleapis.com/css2?family=Hahmlet:wght@300&amp;display=swap");
    * {
    font-family: "Hahmlet", serif;";
    }
    .bg {
    background-image: url('https://s3.ap-northeast-2.amazonaws.com/materials.spartacodingclub.kr/bucketList/bg-grid.png');
    background-position: center;
    background-size: cover;
    margin: auto;
    width: 360px;
    }
    .title {
    background-color: tomato;
    border-radius: 10px;
    color: white;
    text-align: center;
    padding: 4px 14px;
    }

    .msg {
    margin: -5px 0 15px;
    }

    .bucket {
    width : 160px;
    height: 160px;
    background-position: center;
    background-size: cover;
    }

    .img1 {
    background-image: url('https://s3.ap-northeast-2.amazonaws.com/materials.spartacodingclub.kr/bucketList/bucket-red.png');
    }
    .img2 {
    background-image: url('https://s3.ap-northeast-2.amazonaws.com/materials.spartacodingclub.kr/bucketList/bucket-lightred.png');
    }

    .class = 'msg center' {
    color: black !important;
    }

&lt;/style&gt;
&lt;link rel="stylesheet" type="text/css" href="https://s3.ap-northeast-2.amazonaws.com/materials.spartacodingclub.kr/bucketList/sparta-bucket2.css" /&gt;

&lt;/head&gt;

&lt;body class="bg center"&gt;
&lt;h1 class="title"&gt;2024년 신년계획&lt;/h1&gt;
&lt;p class="msg center"&gt;올해 안에 모두 달성하는게&lt;/p&gt;
&lt;p class="msg center"&gt;목표!&lt;/p&gt;
&lt;div class="flex-row wrap"&gt;
    &lt;div class='bucket img1 center'&gt;자바 마스터하기&lt;/div&gt;
    &lt;div class='bucket img2 center'&gt;빅데이터 분석기사 합격하기&lt;/div&gt;
    &lt;div class='bucket img2 center'&gt;취업 뽀개기&lt;/div&gt;
    &lt;div class='bucket img1 center'&gt;운동하기!&lt;/div&gt;
    &lt;div class='bucket img1 center'&gt;알고리즘 통달하기&lt;/div&gt;
    &lt;div class='bucket img2 center'&gt;여유를 가지고 여행하기!&lt;/div&gt;
&lt;/div&gt;

&lt;script&gt;
    // 페이지 로드 시 이전 상태 복원
    document.addEventListener("DOMContentLoaded", (event) =&gt; {
    const buckets = document.querySelectorAll(".bucket");
    buckets.forEach((bucket, index) =&gt; {
        // 로컬 스토리지에서 상태 읽기
        const isDone = localStorage.getItem("bucket" + index) === "done";
        if (isDone) {
        bucket.classList.add("done");
        }
    });
    });

    // 버킷 리스트 클릭 이벤트
    const buckets = document.querySelectorAll(".bucket");
    buckets.forEach((bucket, index) =&gt; {
    bucket.addEventListener("click", function () {
        // 클래스 토글
        bucket.classList.toggle("done");

        // 로컬 스토리지에 상태 저장
        if (bucket.classList.contains("done")) {
        localStorage.setItem("bucket" + index, "done");
        } else {
        localStorage.setItem("bucket" + index, "");
        }
    });
    });
&lt;/script&gt;
&lt;/body&gt;

&lt;/html&gt;
</code></pre></div></div>

<h2 id="코드-설명">코드 설명</h2>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&lt;meta name="viewport" content="width=device-width"&gt;
    // 뷰포트(viewport)의 너비를 기기의 너비로 설정하여 
    모바일 화면에 최적화된 보기 경험을 제공한다. 
    반응형 웹 디자인을 위해 필요하다.
</code></pre></div></div>

<p>뷰포트(viewport) : 사용자가 웹사이트나 애플리케이션을 통해 볼 수 있는 영역을 의미한다. 쉽게 말해, 사용자의 화면에 실제로 보이는 부분. 예를 들어, 스마트폰이나 태블릿, 랩탑 등 다양한 기기에서 웹사이트를 방문했을 때, 그 기기의 화면 크기에 맞게 보이는 웹페이지의 영역이 뷰포트에 해당한다.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>@import url("https://fonts.googleapis.com/css2?family=Hahmlet:wght@300&amp;display=swap");
* {
font-family: "Hahmlet", serif;";
}
//구글 폰트를 적용하고 * 즉 모든 요소에 대해서 "Hahmlet" 폰트를 적용함

.bg {
    /* 배경 이미지 및 스타일 설정 */
}
.title {
    /* 타이틀 영역의 배경색, 글자색, 텍스트 정렬 등의 스타일을 정의 */
}
.msg {
    /* 메시지 영역의 스타일을 정의 */
}
.bucket {
    /* 버킷리스트 아이템의 크기 및 배경 이미지 관련 스타일을 정의 */
}
.img1, .img2 {
    /* 특정 버킷리스트 항목에 대한 배경 이미지를 정의 */
}

&lt;body class="bg center"&gt;
    .bg에서 정의한 CSS 스타일과 center 스타일 속성을 사용함. 
    // center 속성은 외부 css 파일에 정의되어 있음

    /* 외부 CSS 시트에 적용된 .center 클래스
    
    .center {
        display: flex; &lt;&lt; 플랙스박스 레이아웃을 적용함
        flex-direction: column; &lt;&lt; 주 축을 column으로 설정
        align-items: center; &lt;&lt; 교차 축에서 중앙 정렬
        justify-content: center; &lt;&lt; 주 축에서 중앙 정렬
    } */
</code></pre></div></div>

<ul>
  <li>플렉스박스(Flexbox) 레이아웃은 CSS3에서 도입된 강력한 레이아웃 도구로, 복잡한 레이아웃을 쉽게 만들 수 있게 해주는 방식. 주로 1차원 레이아웃을 위해 사용되며, 즉, 한 번에 한 축(가로 또는 세로)을 따라 요소를 배치하는 데 최적화되어 있음</li>
</ul>

<p>플렉스박스를 사용하면 요소들 간의 간격과 정렬을 유연하게 조정할 수 있어서, 다양한 화면 크기와 해상도에 대응하는 반응형 웹 디자인을 구현하기 쉽다. 플렉스박스는 특히 요소의 크기가 불명확하거나 동적일 때 유용하며, 복잡한 정렬이나 분배를 단순한 코드로 해결할 수 있게 해 준다.</p>

<p>플렉스박스의 주요 특징:</p>

<ol>
  <li>
    <p><strong>컨테이너와 아이템</strong>: 플렉스 컨테이너(Flex Container) 내부에 플렉스 아이템(Flex Items)들이 배치됨. 컨테이너에 <code class="language-plaintext highlighter-rouge">display: flex;</code> 또는 <code class="language-plaintext highlighter-rouge">display: inline-flex;</code> 속성을 적용함으로써 플렉스박스 레이아웃이 활성화된다.</p>
  </li>
  <li>
    <p><strong>주 축과 교차 축</strong>: 플렉스박스 레이아웃에서는 주 축(Main Axis)과 교차 축(Cross Axis)이라는 두 개의 축이 있다. <code class="language-plaintext highlighter-rouge">flex-direction</code> 속성을 통해 주 축을 설정할 수 있으며, 아이템들은 이 주 축을 따라 배치됨.</p>
  </li>
  <li>
    <p><strong>정렬</strong>: <code class="language-plaintext highlighter-rouge">justify-content</code>, <code class="language-plaintext highlighter-rouge">align-items</code>, <code class="language-plaintext highlighter-rouge">align-self</code> 등의 속성을 통해 아이템들의 수평, 수직 정렬을 쉽게 조절할 수 있음.</p>
  </li>
  <li>
    <p><strong>유연성</strong>: <code class="language-plaintext highlighter-rouge">flex-grow</code>, <code class="language-plaintext highlighter-rouge">flex-shrink</code>, <code class="language-plaintext highlighter-rouge">flex-basis</code> 속성을 사용해 아이템들이 차지하는 공간의 비율을 조절할 수 있으며, 컨테이너의 남은 공간을 아이템들이 어떻게 분배할지 결정할 수 있다.</p>
  </li>
</ol>

<p>플렉스박스 레이아웃은 웹 페이지의 다양한 구성 요소에 유용하게 적용될 수 있으며, 특히 <strong>메뉴, 카드 레이아웃, 그리드 시스템</strong> 등을 만들 때 자주 사용된다.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&lt;h1 class="title"&gt;2024년 신년계획&lt;/h1&gt;
</code></pre></div></div>

<p>h1 태그 : 가장 중요한 제목을 나타냄</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&lt;p class="msg center"&gt;올해 안에 모두 달성하는게&lt;/p&gt;
&lt;p class="msg center"&gt;목표!&lt;/p&gt;
</code></pre></div></div>

<p>p 태그 : 문단을 나타냄, msg, center 클래스가 적용되어 있음.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&lt;div class="flex-row wrap"&gt;
flex-row, wrap 클래스를 적용한다. flex-row와 wrap은 외부 css 시트에 적용되어 있음

*/ 외부 css 시트에 적용된 .flex-row와 .wrap 클래스

.flex-row {
    display: flex;
    flex-direction: row;
    align-items: center;
    justify-content: center;
}

.wrap {
    flex-wrap: wrap;
} */
</code></pre></div></div>

<p>div 태그 : &lt;div&gt; 태그는 블록 레벨 컨테이너로, 여기서는 여러 버킷리스트 항목들을 감싸고 있음. class=”flex-row wrap” 속성은 CSS 플렉스박스(flexbox) 레이아웃을 적용하여 항목들을 행(row)으로 정렬하고, 필요한 경우 여러 줄로 감싸(wrap)서 표시한다.</p>

<p>.flex-row</p>

<ol>
  <li>display: flex;: 이 속성은 해당 요소를 플렉스 컨테이너로 만듭니다. 플렉스 아이템들이 플렉스박스 레이아웃을 사용하여 배치됩니다.</li>
  <li>flex-direction: row;: 플렉스 아이템들이 수평 방향(가로)으로 나열되도록 설정합니다.
align-items: center;: 플렉스 아이템들이 교차 축(이 경우에는 세로 축)에서 중앙에 위치하도록 설정합니다.</li>
  <li>justify-content: center;: 플렉스 아이템들이 주 축(이 경우에는 가로 축)에서 중앙에 위치하도록 설정합니다.</li>
</ol>

<p>.wrap</p>

<p>.wrap 클래스는 플렉스 아이템들이 플렉스 컨테이너 내에서 여유 공간이 부족할 때, 다음 줄로 넘어가도록 설정합니다:</p>

<p>flex-wrap: wrap; 이 속성은 플렉스 아이템이 한 줄에 모두 표시될 수 없을 때, 다음 줄로 감싸지도록(줄바꿈) 설정</p>

<p>이 두 클래스가 적용되어 버킷리스트가 한줄에 두 개씩 표시되고, 플렉스 아이템이 한 줄에 표시될 수 없으므로 다음 줄로 감싸지도록(줄바꿈)이 됨</p>

<p>자바스크립트 코드는 다음 포스트에 자세히 정리하겠다.</p>]]></content><author><name>ash tensor</name></author><category term="WEB" /><summary type="html"><![CDATA[2024년이 시작한지도 벌써 10일이 지나긴 했지만, 새해를 맞아 새해의 목표를 세우는 것은 필요한 것 같다. 막연하게 생각했었던 새해 목표도 구체적으로 정리하고, 일일 목표를 세우기 위해서라도.]]></summary></entry><entry><title type="html">[JAVA] 예외처리 - throw, throws, throwable</title><link href="http://localhost:4000/java/2024/01/08/exception.html" rel="alternate" type="text/html" title="[JAVA] 예외처리 - throw, throws, throwable" /><published>2024-01-08T00:00:00+09:00</published><updated>2024-01-08T00:00:00+09:00</updated><id>http://localhost:4000/java/2024/01/08/exception</id><content type="html" xml:base="http://localhost:4000/java/2024/01/08/exception.html"><![CDATA[<h1 id="예외처리">예외처리</h1>

<p>자바는 솔직히 예외처리를 아주 빡빡하게 처리하는 언어다. 다른 언어들이 특정 예외가 일어났을 때를 열거해서 (divideByZero error, Stack overflow error 등) 제외하는 것에 비해서 조금은 특이하다.</p>

<p>물론 C 처럼 예외 처리를 아예 강제하지 않는 언어와 비교하려는 것은 아니다. Python이나 C++, C# 모두 try - catch - finally와 같은 예외 처리를 지원하고, 자바와 사용되는 예약어만 다들 뿐 그 궤는 비슷하다.</p>

<p>하지만 널리 사용되는 언어인 Javascript와 Python에 비교해 봐도, 자바처럼 Checked 에러와 Unchecked 에러를 나눠서 구현을 강제해서 구분하는 언어는 충분히 드물다고 할 수 있다.</p>

<h2 id="checked-error---unchecked-error">Checked Error - Unchecked Error</h2>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>class ExceptionExample {
    // 예외를 던질 수 있는 메서드
    public void methodWithThrows() throws CustomException { &lt;&lt; 에러 열거
        System.out.println("메서드에서 예외를 던집니다.");
        throw new CustomException("Custom 예외 발생");
    }

    // 호출하는 코드
    public static void main(String[] args) {
        ExceptionExample example = new ExceptionExample();

        try {
            example.methodWithThrows();
        } catch (CustomException e) {   &lt;&lt; 열거한 에러 처리
            System.out.println("예외를 처리합니다: " + e.getMessage());
        }
    }
}

// CustomException 정의
class CustomException extends Exception {
    public CustomException(String message) {
        super(message);
    }
}
</code></pre></div></div>

<p>여기서 세번째 라인의 throws가 바로 Checked Error를 열거하는 예약어다. 보통 throws 키워드를 설명할 때</p>

<blockquote>
  <blockquote>
    <p>[Throws 키워드는 메소드 선언부 끝에 작성되어 메소드에서 처리하지 않은 예외를 호출한 곳으로 떠넘기는 역할을 합니다.]</p>
  </blockquote>
</blockquote>

<p>라고 설명하는데, 이 말을 처음 들을 때 이해가 쉽지는 않다(고 생각한다).</p>

<p>throws 키워드는 Checked Error를 열거하는 예약어로, 만약 이 메소드를 호출하는 메소드가 있다면 무조건 예외처리를 해야 컴파일이 가능하다는 뜻이다.</p>

<p>즉 위 예시 코드로 설명해 보자면, 예외를 던질 수 있는 메서드에서 customException을 throws 예약어로 열거했으므로 //호출하는 코드 부분에서 무조건적으로</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>catch(CustomException e)
</code></pre></div></div>

<p>부분이 없으면 실행을 아예 거부해버린다.</p>

<p><img src="/img/posts/JAVA/throws.PNG" style="width: 80%" /></p>

<p>이런식으로.</p>

<h2 id="throws가-없는-프로그램">throws가 없는 프로그램</h2>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>class ExceptionExample {
    public void methodWithoutThrows() {
        System.out.println("예외 테스트");
        ExceptionExample example = new ExceptionExample();
        example.methodWithoutThrows();
    }

    // 호출하는 코드
    public static void main(String[] args) {
        ExceptionExample example = new ExceptionExample();
        example.methodWithoutThrows();
        }
    }
</code></pre></div></div>

<p>throws를 제거한 코드다. try - catch 문이 없어도 문제 없이 컴파일 가능한 모습을 볼 수 있다. methodWithoutThrows는 예외를 던지지 않으므로 호출하는 코드에서는 예외 처리를 할 필요가 없다.</p>

<p>이렇게 throws를 사용하면 메서드를 사용하는 측에게 어떤 예외가 발생할 수 있는지 명시함으로써 명확한 예외 처리를 유도할 수 있다… 곤 하지만, 솔직히 아무리 문법적으로 강제해도 제대로 하지 않을 사람은 안 한다. 아예 JVM으로 에러를 던져버리는 것이다.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// main 메소드 throws

public class Example {
    public static void main(String[] args) throws Exception {
        // 예외가 발생할 수 있는 코드
    }
}
</code></pre></div></div>

<p>이런 식으로, main 메소드에서 throws를 사용하는 것은 에러를 JVM에게 전가한다는 뜻이다. Main 메소드보다 더 상위의 메소드는 JVM밖에는 없기에, 에러를 던져도 JVM은 에러 메시지만 출력하고 프로그램을 종료한다.</p>

<p>main 메서드에서 throws를 사용할 때는 주로 런타임 예외인 RuntimeException 또는 Exception과 같은 일반적인 예외를 사용하며, 이를 통해 예외 처리를 뒷단으로 미루는 경우가 있다.</p>

<blockquote>
  <blockquote>
    <p>[throws &lt;unchecked exception(runtime exception)&gt; 키워드가 붙어있는 메서드는 꼭 try 블록 내부에서 호출되지 않더라도 컴파일이 됩니다. 하지만 매우 문제가 있는 코드입니다.]</p>
  </blockquote>
</blockquote>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// RuntimeException throws

public class Example {
    // 예외를 던질 수 있는 메서드
    public static void methodWithThrows() throws RuntimeException {
        System.out.println("메서드에서 예외를 던집니다.");
        throw new RuntimeException("런타임 예외 발생");
    }

    // 호출하는 코드
    public static void main(String[] args) {
        // 메서드 호출 시 try-catch 블록 없음
        methodWithThrows();
        
        // 아래 코드는 실행되지 않음 (Unreachable code 에러 발생)
        System.out.println("메서드 호출 후의 코드");
    }
}
</code></pre></div></div>

<p>위의 코드에서 methodWithThrows는 RuntimeException을 던질 수 있는데, 호출하는 main 메서드에서는 해당 예외를 처리하는 try-catch 블록이 없다. 그러나 컴파일은 문제없이 진행된다.</p>

<p>하지만 실행 시에는 methodWithThrows에서 발생한 예외가 main 메서드로 전파되어, “Unreachable code” 에러가 발생하면서 프로그램이 비정상적으로 종료된다.</p>]]></content><author><name>ash tensor</name></author><category term="JAVA" /><summary type="html"><![CDATA[예외처리]]></summary></entry><entry><title type="html">[JAVA] 인터페이스와 추상클래스의 차이</title><link href="http://localhost:4000/java/2024/01/07/interface.html" rel="alternate" type="text/html" title="[JAVA] 인터페이스와 추상클래스의 차이" /><published>2024-01-07T00:00:00+09:00</published><updated>2024-01-07T00:00:00+09:00</updated><id>http://localhost:4000/java/2024/01/07/interface</id><content type="html" xml:base="http://localhost:4000/java/2024/01/07/interface.html"><![CDATA[<p>추상 클래스와 인터페이스는 모두 자바에서 객체지향의 원칙 중 추상화를 구현하기 위해 사용되는 개념이지만 몇가지 중요한 차이가 존재한다. 솔직히 내 생각에는, 자바라는 언어가 어쩌면 극단적으로 객체지향을 중시한다는 것을 보여주는 예시라고 생각한다. 파이썬에서는 굳이 인터페이스를 사용하지 않는 경우가 많은 것 같다. “<strong>call</strong>” 처럼 간단한 인터페이스라면 객체를 그냥 파이썬 함수처럼 호출해서 사용하는 경우도 있고.</p>

<p>인터페이스를 배울 때 (적어도 나는) 추상 클래스와는 다르게 다중 상속이 가능하다는 것이 기억나는데 이는 객체지향에 익숙하지 않으면 추상 클래스와 인터페이스가 어떤 일을 하는지 정확히 이해하기 힘들기 때문이라고 생각한다.</p>

<h1 id="인터페이스">인터페이스</h1>

<p>인터페이스는 추상 클래스와는 별도로 <strong>구현 객체가 같은 동작을 한다는 것을 보장하기 위해 초점을 두는 것이 추상 클래스와는 다르다.</strong> 예를 들어서, 리모컨이라는 추상 클래스가 존재한다고 할 때, TV리모컨과 에어컨 리모컨은 하는 역할이 다를 것이다.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>abstract class RemoteControl {
    abstract void turnOn();
    abstract void turnOff();
    abstract void volumeUp(); &lt;&lt; 에어컨 리모컨에서는 구현할 수 없다.
}

class TVRemote extends RemoteControl {
    void turnOn();
    void turnOff();
    void volumeUp();
}

class AirconditionerRemote extends RemoteControl {
    void turnOn();
    void turnOff();
    void volumeUp(); &lt;&lt; 구현할 수 없음
}
</code></pre></div></div>

<p>이런 경우에 인터페이스를 사용하는 것이다. 공통적인 기능의 보장! TurnOn과 TurnOff는 공통적인 기능이므로, 이런 식으로 구현이 될 수 있겠다.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Interface Volume {
    void volumeUp();
    void volumeDown();
}

class TVRemote extends RemoteControl implements Volume {
    void turnOn();
    void turnOff();
    void volumeUp();
}
</code></pre></div></div>

<p>이렇게 동작의 메서드를 각각 인터페이스마다 분리하여 설계함으로서 조금 더 구조적이고 더욱 추상적인 객체를 설계할 수 있다.</p>

<h2 id="구현-예제">구현 예제</h2>

<h3 id="iremotecontrolable-인터페이스">IRemoteControlable 인터페이스</h3>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>public interface IRemoteControlable {
void turnOn();
void turnOff();
void channelUp();
void channelDown();
void volumnUp();
void volumnDown();
void putChannel(int value);
}
</code></pre></div></div>

<h3 id="controller-클래스">Controller 클래스</h3>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>package jan5th;
import java.util.Scanner;

public class Controller implements IRemoteControlable {
    Television model;

    public Controller(Television model){
        this.model = model;
    }

    public boolean analyzer(int value, Scanner hand){

//"1. TV 켜기, 2. TV 끄기, 3. 채널 올리기, 4. 채널 내리기, " +
//"5. 볼륨 올리기, 6. 볼륨 내리기, 7. 특정 채널로 이동, 0. 종료";
        
        switch (value){

            case 1:{
                this.turnOn();
                break;
            }
            case 2: {
                this.turnOff();
                break;
            }
            case 3 : {
                this.channelUp();
                break;
            }
            case 4 : {
                this.channelDown();
                break;
            }
            case 5 : {
                this.volumnUp();
                break;
            }
            case 6 : {
                this.volumnDown();
                break;
            }
            case 7 : {
                System.out.println("입력할 채널을 선택해주세요");
                int inputedChannel = hand.nextInt();
                this.putChannel(inputedChannel);
                break;
            }
            case 0 : {
                System.out.println("TV를 그만 봅니다.");
                return false;
            }
        }
        return true;
    }

    public void turnOn() {
        model.on = true;
        System.out.println("TV 전원 : ON");
    }

    @Override
    public void turnOff() {
        model.on = false;
        System.out.println("TV 전원 : OFF");
    }

    @Override
    public void channelUp() {
        if(model.on == false) {
            System.out.println("TV STATE : OFF");
        }
        else {
            model.channel += 1;
            System.out.printf("현재 채널 : %d\n", model.channel);
        }
    }

    @Override
    public void channelDown() {
        if(model.on == false) {
            System.out.println("TV STATE : OFF");
        }
        else {
            if (model.channel == 1) {
                System.out.println("0번 채널은 없습니다.");
            } else {
                model.channel -= 1;
                System.out.printf("현재 채널 : %d\n", model.channel);
            }
        }
    }
    @Override
    public void volumnUp() {
        if(model.on == false) {
            System.out.println("TV STATE : OFF");
        }
        else {
            model.volume += 1;
            System.out.printf("현재 볼륨 : %d\n", model.volume);
        }
    }

    @Override
    public void volumnDown() {
        if(model.on == false) {
            System.out.println("TV STATE : OFF");
        }
        else {
            if (model.volume == 0) {
                System.out.println("볼륨을 0 아래로 내릴 수 없습니다.");
            } else {
                model.volume -= 1;
                System.out.printf("현재 볼륨 : %d\n", model.volume);
            }
        }
    }
    @Override
    public void putChannel(int value) {
        if(model.on == false) {
            System.out.println("TV STATE : OFF");
        }
        else {
            if (value &lt;= 0) {
                System.out.println("그런 채널은 없습니다.");
            } else {
                model.channel = value;
                System.out.printf("현재 채널 : %d\n", model.channel);
            }
        }
    }
}
</code></pre></div></div>

<h3 id="human-클래스">Human 클래스</h3>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>package jan5th;

import java.util.Scanner;

public class Human {
    Controller model;

    public Human(Controller controller){
        this.model = controller;
    }
    void input(Scanner Hand){
        boolean condition = true;
        while(condition){
            System.out.println("1. TV 켜기, 2. TV 끄기, 3. 채널 올리기, 4. 채널 내리기, " +
                    "5. 볼륨 올리기, 6. 볼륨 내리기, 7. 특정 채널로 이동, 0. 종료");
            int value = Hand.nextInt();
            condition = this.model.analyzer(value, Hand);
        }
    }
}
</code></pre></div></div>

<h3 id="메인-클래스">메인 클래스</h3>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>package jan5th;

import java.util.Scanner;

public class Main {
    public static void main(String[] args) {
        Television appleTV = new Television();
        Controller appleTVController = new Controller(appleTV);
        Human me = new Human(appleTVController);
        me.input(Hand);
    }
}
</code></pre></div></div>]]></content><author><name>ash tensor</name></author><category term="JAVA" /><summary type="html"><![CDATA[추상 클래스와 인터페이스는 모두 자바에서 객체지향의 원칙 중 추상화를 구현하기 위해 사용되는 개념이지만 몇가지 중요한 차이가 존재한다. 솔직히 내 생각에는, 자바라는 언어가 어쩌면 극단적으로 객체지향을 중시한다는 것을 보여주는 예시라고 생각한다. 파이썬에서는 굳이 인터페이스를 사용하지 않는 경우가 많은 것 같다. “call” 처럼 간단한 인터페이스라면 객체를 그냥 파이썬 함수처럼 호출해서 사용하는 경우도 있고.]]></summary></entry><entry><title type="html">[JAVA] PSVM - public static void main(string[] args)</title><link href="http://localhost:4000/java/2024/01/04/psvm.html" rel="alternate" type="text/html" title="[JAVA] PSVM - public static void main(string[] args)" /><published>2024-01-04T00:00:00+09:00</published><updated>2024-01-04T00:00:00+09:00</updated><id>http://localhost:4000/java/2024/01/04/psvm</id><content type="html" xml:base="http://localhost:4000/java/2024/01/04/psvm.html"><![CDATA[<h1 id="psvm">PSVM</h1>

<p>자바를 즐겨 사용하는 사람도 자바의 코드가 간결함과는 거리가 멀다는 데는 동의할 것이다. 당장 파이썬에서 하는 것처럼 print(“hello world”)를 실행하려고 해도, 아니면 자바를 이어받은 코틀린에서조차</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>fun main() {
println("Hello")
}
</code></pre></div></div>

<p>이렇게 간결한데 자바에서는</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>class Main {
public static void main(String args[]) {
    System.out.println("Hello");
    }
}
</code></pre></div></div>

<p>이런 식으로 작성해야 될 정도고, 저 부분을 수정하면</p>

<p><img src="/img/posts/PSVM.PNG" style="width: 80%" /></p>

<p>이렇게 아예 IDE에서부터 프로그램을 실행할 수 없다고 말해버린다. 이렇듯 자바는 public static final 처럼 문법적으로 꼭 필요한 서식과 문법적 구조가 너무 늘어진다. 그렇다보니 PS에서는 자바를 그다지 사용하지 않는 것 같다. 당연히 느려서 그런 것도 있겠지만, 똑같이 엄청 느린 파이썬을 많이 사용하는 걸 보면 꼭 그런것 만은 아닌 것 같다.</p>

<p>그런데 왜 자바에서는 PSVM string args를 써야하는 걸까?</p>

<h2 id="public">public</h2>

<p>public은 접근 제어자이다. 자바는 프로그램의 시작을 Main 메소드에서 시작한다. 그러므로 어디에서든 접근해야 하기 때문에 public으로 선언하는 것은 당연하다.</p>

<h2 id="static">static</h2>

<p>자바에서 static 키워드는 많은 용도로 사용되는데, 정적 변수(Static Variable)과 정적 메서드(Static Method)가 대표적이다. 그리고 PSVM을 무조건 사용해야 되는 이유도 바로 여기에 있다. 
정적 변수는 클래스가 메모리에 로드 될 때 생성되며 <strong>정적 영역</strong>에 적재된다. 정적 변수는 클래스 이름을 통해 접근할 수 있으며 (ex: Integer.MAX_VALUE) 객체를 생성하지 않아도 된다. 정적 메서드도 똑같은데, 정적 메서드 역시 클래스 이름을 통해 직접 호출할 수 있고, <strong>인스턴스의 변수나 인스턴스의 메서드를 직접 사용하거나 호출할 수 없다.</strong>
오로지 정적 변수나 정적 메서드만 호출할 수 있다. 이 정적 메서드의 가장 대표적인 메서드가 바로 메인 메서드다.</p>

<p>이 때문에 자바의 메인 메서드에는 public static void main(string[] args) 를 적어야 하는데, 자바의 메인 메서드는 객체를 생성하지 않고 실행되어야 하기 때문에 static, 즉 정적 메서드여야 하는 것이다.</p>

<p>우리가 자바를 사용할 때, Main 클래스를 인스턴스해서, 예를 들어서</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Main classMain = new Main(args[]);
classMain.main();
</code></pre></div></div>

<p>이런 식으로 터미널에 작성해서 실행하지는 않으니까.</p>

<p>그리고 인스턴스의 변수나 인스턴스의 메서드를 직접 사용하거나 호출할 수 없는데 내 기억에 가장 깊게 남아있는 예시가 있다. 23년 정보처리기사 3회 자바 문제인데</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// 에러가 나는 라인을 고르시오
class Person(
    private String name;
    public Person(String val) {
        name = val;
    }
    public static String get() {
        return name;
    }
    public void print() {
        System.out.println(name);
    }
)

public class Engineer {
    public static void main(string[] args) {
        Person obj = new Person("Kim");
        obj.print();
    }
}
</code></pre></div></div>

<p>이런 문제였다. 여기서는 7번 라인, <strong>return name</strong> 부분에서 에러가 나는데, 이는 get()이라는 메서드가 static 메서드이기 때문에, 2번 라인에서 선언된 private String name 이라는 인스턴스 변수를 참조할 수 없기 때문에 에러가 나는 것이다.</p>

<p>어디서 에러가 날 지 찾으라는 문제가 나올 거라고는 생각을 하지 못해서 시험장에서 꽤 당황했었던 기억이 난다.</p>]]></content><author><name>ash tensor</name></author><category term="JAVA" /><summary type="html"><![CDATA[PSVM]]></summary></entry><entry><title type="html">[CS] 2의 보수</title><link href="http://localhost:4000/cs/2024/01/02/binary.html" rel="alternate" type="text/html" title="[CS] 2의 보수" /><published>2024-01-02T00:00:00+09:00</published><updated>2024-01-02T00:00:00+09:00</updated><id>http://localhost:4000/cs/2024/01/02/binary</id><content type="html" xml:base="http://localhost:4000/cs/2024/01/02/binary.html"><![CDATA[<h1 id="2의-보수">2의 보수</h1>

<p>논리회로나 컴퓨터 구조 과목에서 2의 보수를 다루지 않고 넘어가는 건 있을 수 없다. 보통 이진수의 음수를 다루는 데 있어서 언급이 되곤 하는데, 비트를 NOT 연산한 후에 + 1 을 하면 얻을 수 있다고 배운다. 2의 보수는 부호가 붙은 정수를 표현하는데 있어서 가장 널리 쓰이는 방법이다.</p>

<h2 id="구하는-법">구하는 법</h2>

<p>앞서 설명한 대로 비트를 NOT 연산한 후에 + 1 을 하면 2의 보수가 된다. 즉</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code> 1111(2) 의 보수는
 0001(2) 가 된다.
</code></pre></div></div>

<h2 id="보수">보수</h2>

<p>1의 보수와 2의 보수가 대표적으로, 더해서 각 목표가 되는 수를 말하는데, 논리회로에서 음수를 표현하는 방법으로는 부호 절대값과 1의 보수, 2의 보수, 3가지 정도로 나뉜다. 하지만 선술했듯 부호가 붙은 정수를 표현하는데 가장 널리 쓰이는 방법이 바로 2의 보수인데</p>

<ol>
  <li>이는 2의 보수가 1의 보수보다 하나의 수를 더 표시할 수 있고</li>
  <li>회로가 가장 간편해지기 때문이다.</li>
</ol>

<p>2의 보수가 1의 보수보다 하나의 수를 더 표시할 수 있는 이유는 같은 비트를 사용한다고 할 때, 0을 표시하는 방법이 1의 보수는 두 가지 경우이기 때문이다. 예를 들어 보겠다.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>num0 =  0000 0000(2) ## 바이트 0
num1 =  1111 1111(2) ## num0의 1의 보수
num2 = 10000 0000(2) ## num1의 2의 보수
</code></pre></div></div>

<p>1의 보수에는 0을 두가지로 표현하게 된다. 그렇기 때문에 1바이트당 1의 보수인 경우에는 -127 ~ +127 까지 표현할 수 있지만, 2의 보수인 경우 -128 ~ 127까지 계산할 수 있다. 1111 1111, 즉 -128이 포함되는 것이다.</p>

<p>하지만 처음 들었을때 고작 한가지 숫자를 더 표현하겠다고(물론 과거의 컴퓨터는 그 하나의 숫자를 더 표현하는 것이 엄청 중요할 정도로 성능이 빡빡했지만) 2의 보수를 사용한다기 보다는 추가적인 이유가 더 중요하다는 생각이 들었다.</p>

<h2 id="회로의-작성-용이성">회로의 작성 용이성</h2>

<p>부호 절댓값 방법은 절댓값이 작은 수에서 큰 수를 뺄 경우에는 순서를 바꿔서 빼야된다는 추가적인 방법이 필요할 뿐만 아니라, 가산기로는 연산할 수 없기 때문에 <strong>뺄셈기</strong>가 추가되어야 한다. 그리고 비트의 낭비가 너무 심하다. 그래서 논리 연산(&gt;, &lt;…)을 할 때 모순이 생기곤 한다.</p>

<p>1의 보수는 그러한 연산을 매우 간편하게 만들어 주는데, 부호와 절댓값을 따로 계산할 필요도 없고 뺄셈기를 사용할 필요 없이 가산기 그대로 사용할 수 있다.</p>

<p>하지만 0000과 1111을 둘 다 0으로 처리해야 하는 회로와, 계산 과정에서 캐리, 즉 올림이 발생했는지를 확인하고 만약 발생했다면 마지막 비트에 1을 추가하는 회로를 구성해야 한다.</p>

<p>예를 들어서</p>

<p>7 - 3 을 하는 간단한 계산을 할 때.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>7(0111)과 -3(1100)의 덧셈에서는 1011이 나오게 되고, 
이는 보수를 취하게 되면 4이므로 맞다. 
이는 캐리가 이루어지지 않았기 때문이다.
하지만 7(0111)과 -1(1110)의 덧셈을 수행하면 
결과값은 **10101(21)이고 
오버플로우가 발생했으므로 1을 더해주는 연산을 해주면 0110(6)이다.
</code></pre></div></div>

<p>하지만 2의 보수에서는 이러한 귀찮은 방법이 필요 없다.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>7(0111)과 -3(1101)의 덧셈에서는 10100이 나오게 되고, 
2의 보수에서는 오버플로우가 발생한 부분을 버림으로 4가 되서 정답이다. 
또한 7(0111)과 -1(1111)의 덧셈을 수행하면 
결과값은 10110이고 
최상위 비트 1을 버리면 0110(6)으로 정답이다.
</code></pre></div></div>

<p>이런 간결성 덕분에 2의 보수는 대부분의 컴퓨터 구조에서 음수를 표현하는 방법으로 표현된다.</p>]]></content><author><name>ash tensor</name></author><category term="CS" /><summary type="html"><![CDATA[2의 보수]]></summary></entry><entry><title type="html">[Android Studio]Bottom Navigation Bar 구현 - OnItemSelectedListener 이용</title><link href="http://localhost:4000/%EC%95%88%EB%93%9C%EB%A1%9C%EC%9D%B4%EB%93%9C/2023/12/29/bottomNavigationView.html" rel="alternate" type="text/html" title="[Android Studio]Bottom Navigation Bar 구현 - OnItemSelectedListener 이용" /><published>2023-12-29T00:00:00+09:00</published><updated>2023-12-29T00:00:00+09:00</updated><id>http://localhost:4000/%EC%95%88%EB%93%9C%EB%A1%9C%EC%9D%B4%EB%93%9C/2023/12/29/bottomNavigationView</id><content type="html" xml:base="http://localhost:4000/%EC%95%88%EB%93%9C%EB%A1%9C%EC%9D%B4%EB%93%9C/2023/12/29/bottomNavigationView.html"><![CDATA[<h1 id="bottom-navigation-bar">Bottom Navigation Bar</h1>

<p>어떤 앱이든 Bottom Naviagation Bar가 없는 앱은 상상하기 힘들다. 토스, 에브리타임, 카카오톡은 아닌가? 아무튼, 과장 좀 보태서 거의 모든 앱의 하단 부분에는 이 Bottom Navigation Bar가 존재한다.</p>

<p><img src="/img/posts/android_studio/3.jpeg" style="width: 80%" /></p>

<p>이런거 말이다.</p>

<p>그런데 흔히 온라인에서 돌아다니는 BottomNavigationBar 구현방법 대부분은 사용중지가 될 예정인 setOnNavigationItemSelectedListener와 onNavigationItemSelectedListener를 사용하고 있어서, 사용이 비권장된다. 안드로이드 호환성 때문에 나중에 사용하다가 에러가 뜰 가능성도 높고, Deprecate될 기능을 사용하는 건 당연히 좋지 못하다. 사용중지가 될 기능을 유지보수하고 있는건 웃기기도 하고.</p>

<p>그래서 android 팀이 권장하는 OnItemSelectedListener를 이용해서 BottomNavigationBar룰 구현해보았다.</p>

<h2 id="menuxml">menu.xml</h2>

<p>일단 먼저 menu.xml을 추가해 주어야 한다. 그러기 위해서는 res 디렉토리에 menu라는 android resources directory를 추가해야 하는데</p>

<p><img src="/img/posts/android_studio/menu1.png" style="width: 80%" /></p>

<p>이렇게 추가한 뒤에, 똑같게 File &gt; New &gt; Menu Resources File을 추가하면 된다. 그 뒤에 item을 추가해 준다. item은 BottomNavigationBar의 각 메뉴로 구현된다.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    &lt;item
        android:id="@+id/menu_1"
        android:title="MENU1"
            ##android:title은 화면에 표시될 이름이다
            ##나중에 bottomNavigationView와 연결할 때 android:id를 이용해서 연결한다.
        #android:icon="" 에서 icon에 아이콘 파일을 연결해 주면 아이콘이 나오는데 에셋을 만드는 중이라 현재는 추가하지 않았다
        /&gt;
     &lt;item
        android:id="@+id/menu_2"
        android:title="MENU2"
        /&gt;
     &lt;item
        android:id="@+id/menu_3"
        android:title="MENU3"
        /&gt;
    
    
    &gt;
</code></pre></div></div>

<h2 id="activity_mainxml">activity_main.xml</h2>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;androidx.constraintlayout.widget.ConstraintLayout xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto"
    xmlns:tools="http://schemas.android.com/tools"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    tools:context=".MainActivity"&gt;

    &lt;LinearLayout
        android:layout_width="match_parent"
        android:layout_height="match_parent"
        android:orientation="vertical"&gt;

        &lt;FrameLayout
            android:layout_width="match_parent"
            android:layout_height="0dp"  ## 레이아웃의 높이를 가중치를 이용하여 조정
            android:layout_weight="1"    ## 부모 레이아웃의 남은 공간을 모두 차지
            android:id="@+id/FragmentContainer" &gt;
            &lt;TextView
                android:id="@+id/testTextView"   ## 프래그먼트가 바뀌었는지 확인용
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:text="firstView"
                android:gravity="center"
            /&gt;
        &lt;/FrameLayout&gt;

        &lt;com.google.android.material.bottomnavigation.BottomNavigationView
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:layout_gravity="bottom"
            android:id="@+id/bottomNavigationView"
            app:menu="@menu/menu" /&gt;    ## 아까 만든 메뉴를 적으면 됨
    &lt;/LinearLayout&gt;

&lt;/androidx.constraintlayout.widget.ConstraintLayout&gt;
</code></pre></div></div>

<p>기본적으로 리니어 레이아웃과 프레임 레이아웃을 사용해서 레이아웃을 설정했다. android:layout_height=”0dp”, android:layout_weight=”1”을 이용해서 바텀 네비게이션 뷰를 차지한 공간 이외의 공간을 모두 LinearLayout이 차지하기로 하고, 이 리니어 레이아웃에 이후에 바텀 네비게이션 뷰의 메뉴를 누른 경우에 Fragment가 표시될 예정이다. android:id=”@+id/FragmentContaner id를 이용해서 연결한다!</p>

<h2 id="fragment1-추가">fragment1 추가</h2>

<p><img src="/img/posts/android_studio/fragment2.png" style="width: 80%" /></p>

<p>File &gt; New &gt; New Fragment를 추가해주고, Fragment를 작성한다. 이번에는 일단 BottomNavigationView를 작성하는게 목표기 때문에 따로 수정은 하지 않았다.</p>

<h2 id="mainactivityjava">MainActivity.java</h2>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>public class MainActivity extends AppCompatActivity  {

    public FragmentManager fragmentManager = getSupportFragmentManager();
    BottomNavigationView bottomNavigationView;

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);

        BottomNavigationView bottomNavigationView = findViewById(R.id.bottomNavigationView);
        bottomNavigationView.setOnItemSelectedListener(navListener);

    }

    private NavigationBarView.OnItemSelectedListener navListener = new NavigationBarView.OnItemSelectedListener() {
        @Override
        public boolean onNavigationItemSelected(@NonNull MenuItem item) {
            Fragment selectedFragment = null;

            switch (item.getItemId()) {    ## 누른 해당 메뉴의 id가 menu_1인 경우에
                case R.id.menu_1:
                    selectedFragment = new fragment1();     ## fragment를 할당
                    break;
            }
            TextView testTextView = findViewById(R.id.testTextView);
            ##테스트용 TextView를 숨김
            testTextView.setVisibility(View.GONE);
            getSupportFragmentManager().beginTransaction().replace(R.id.FragmentContainer, selectedFragment).commit();

            return true;
        }
    } ;
}
</code></pre></div></div>

<p>FrameLayout은 레이아웃을 겹쳐서 보여주기 때문에 testTextView와 Fragment1의 TextView가 겹쳐서 보여지게 된다. 그렇기 때문에 항상 Visibility를 바꿔줘야 한다.</p>

<h2 id="실행">실행</h2>

<p><img src="/img/posts/android_studio/2.PNG" style="width: 50%" /></p>

<ul>
  <li>처음 실행 화면</li>
</ul>

<p><img src="/img/posts/android_studio/1.PNG" style="width: 50%" /></p>

<ul>
  <li>menu1을 선택한 화면</li>
</ul>

<p>예상한대로 BottomNavigationView가 제대로 작동하는 모습을 볼 수 있다!</p>]]></content><author><name>ash tensor</name></author><category term="안드로이드" /><summary type="html"><![CDATA[android studio]]></summary></entry><entry><title type="html">[AI 그림]프롬프트의 한계점 - 올바른 프롬프트 작성하기</title><link href="http://localhost:4000/ml/ai%EA%B7%B8%EB%A6%BC/2023/12/28/stable-diffusion.html" rel="alternate" type="text/html" title="[AI 그림]프롬프트의 한계점 - 올바른 프롬프트 작성하기" /><published>2023-12-28T00:00:00+09:00</published><updated>2023-12-28T00:00:00+09:00</updated><id>http://localhost:4000/ml/ai%EA%B7%B8%EB%A6%BC/2023/12/28/stable-diffusion</id><content type="html" xml:base="http://localhost:4000/ml/ai%EA%B7%B8%EB%A6%BC/2023/12/28/stable-diffusion.html"><![CDATA[<h1 id="ai-그림">AI 그림</h1>

<p>솔직히 말해서, 이제 인공지능 그림은 놀라움을 넘어서서 조금은 지루한 소재인 것 같다. 인공지능이 사람의 그림을 뛰어넘는 그림을 그려 내는 것을 이제는 모두가 당연하게 느낀다.</p>

<p>이제는 GPT도 인공지능 그림을 그려주고(gpt 4를 구독했을때), BING도 그림을 그려준다. 뤼튼도 마찬가지다. 이제 인공지능과 그림은 분리할 수 없는 소재가 되어 버렸다.</p>

<p>인공지능 그림을 크게 나누자면 GPT와 bing, NAI 와 같이 SaaS형 AI와 스테이블 디퓨전과 같이 사용자의 PC에서 로컬 PC의 자원을 사용해서 그림을 그려내는 신경망이 존재한다.</p>

<p>개인적으로 모두 사용해 본 결과, 가장 쉽게 그림을 그려낼 수 있는 건 SaaS형 서비스들이다. 예를 들어서 GPT와 같은 경우에 그림이 마음에 안 드는 경우에 그 그림에 덧붙여 추가적으로 그림을 수정해 달라고 요청하기도 쉽고, 채팅으로 요청만 하면 되기 때문에 전문적인 지식이 없는 사람에게는 꽤나 높은 수준의 에셋을 얻을 수 있기 때문이다.</p>

<h2 id="프롬프트">프롬프트</h2>

<ol>
  <li><img src="/img/posts/ai_image/adventure2.PNG" style="width: 80%" /></li>
</ol>

<p>프롬프트 : 모험가 길드의 내부</p>

<ol>
  <li><img src="/img/posts/ai_image/adventurer1.PNG" style="width: 80%" /></li>
</ol>

<p>프롬프트 : 모험가 길드의 내부, 압도적인 현실감, 뛰어난 디테일, 높은 퀄리티</p>

<ol>
  <li><img src="/img/posts/ai_image/adventurer3.PNG" style="width: 80%" /></li>
</ol>

<p>프롬프트 : 모험가 길드의 내부, 압도적인 현실감, 뛰어난 디테일, 높은 퀄리티, masterpiece, best quality</p>

<p>이런 식이다. 1번에서 2번을 넘어갈 때 가장 큰 퀄리티의 차이가 보이고, 2번에서 3번을 넘어갈 때는 그렇게 큰 성능 향상이 일어나지는 않아 보인다. 이런 SaaS형 서비스들에서도 그림을 그릴 때, 퀄리티 프롬프트(추가한 best quality, masterpiece, 뛰어난 디테일과 같은 지시)가 적용되는 것을 확인할 수 있는데, 이는 스테이블 디퓨전과 비슷한 모습이다. 당연하겠지만.</p>

<ol>
  <li><img src="/img/posts/ai_image/3.jpeg" style="width: 80%" /></li>
</ol>

<p>프롬프트 : 모험가 길드의 내부, 압도적인 현실감, 뛰어난 디테일, 높은 퀄리티, masterpiece, best quality, fantasy world</p>

<ol>
  <li><img src="/img/posts/ai_image/4.jpeg" style="width: 80%" /></li>
</ol>

<p>4번 그림은 모험가 길드를 넘어서서 거대한 왕성을 그려냈고, 5번 그림은 원래 주제인 모험가 길드는 오른쪽 구석에 조그마하게 쳐박혀 있는 모습을 볼 수 있다. 둘 다 모두 기존 프롬프트에 fantasy world라는 프롬프트를 추가한 내용이다.</p>

<p>이렇듯 bing Ai에서도 똑같은 주제를 요청한다고 하더라도 다음과 같이 프롬프트에 따라서 영향이 미치는 모습을 확인할 수 있는데, 점점 가면 갈수록 그림이 급격하게 변화하는 것을 확인할 수 있다. 모험가 길드의 내부라는 주제와는 다른 방향으로 이동하고 있는데, 이는 프롬프트의 한계성에서 기인한다.</p>

<h3 id="프롬프트의-한계성">프롬프트의 한계성</h3>

<p>bing ai는 DALLE 3를 사용하고, DALLE-3는 프롬프트를 해석할 때 GPT-3를 이용해서 이미지를 재구성한다. GPT를 이용해 본 사람들은 GPT가 가끔 오타를 내거나 내 지시에 오타가 있더라도 그것과는 상관없이 잘 무시하고 대답하는 걸 볼 수 있었을 텐데, 이는 언어모델이라는 GPT의 한계 때문이다.</p>

<p>따라서 DALL-E 는 culture라는 단어에서, Sculpture라는 단어를 연상하고야 만다…</p>

<ol>
  <li><img src="/img/posts/ai_image/2.jpeg" style="width: 80%" /></li>
</ol>

<p>이런식으로. 위 그림의 프롬프트에는 지금까지의 프롬프트에 더해서 fantasy culture를 추가한 모습이다. masterpiece와 culture가 서로 영향을 끼쳐 멋진 스태츄를 그려준 모습이다.</p>

<p>또한 DALL-E와 Stable diffusion이 완벽히 같다고 할 수는 없지만 open ai가 발표한 여러 논문을 참고해 보면 (https://cdn.openai.com/papers/dall-e-3.pdf) DALLE-3 역시 그림 - 태그 쌍을 통해 프롬프트를 해석한다고 밝혔는데 아마도 이는 Stable diffusion이 Devian art, danbooru와 같은 그림 - 태그 학습이 이뤄진 이미지 사이트들을 바탕으로 학습한 것과 비슷할 것으로 보인다.</p>

<p>따라서 어떤 특정한 단어가 danbooru와 같은 사이트에서 다른 뜻으로 학습이 되어 있거나 한 경우에는 올바르지 않은 결과를 출력하고야 만다. 
예를 들어서, legend 라는 단어는 흔히 쓰이는 보통명사지만 league of legend라는 고유명사의 일부이다. 이런 경우에, GPT와 같은 트랜스포머 신경망은 내가 리그 오브 레전드의 그림을 그려주기를 바라지 않더라도, 리그 오브 레전드의 요소를 섞어서 그려내고야 마는 것이다.</p>

<ol>
  <li><img src="/img/posts/ai_image/4.jpeg" style="width: 80%" /></li>
</ol>

<p>여기에는 5번 그림을 다시 가져왔는데, 보면 확인할 수 있지만 화면 둘레에 마치 액자와 같은 모습을 확인할 수 있을 것이다. 이는 masterpiece라는 프롬프트 때문이다. 명작을 보여달라고 했기 때문에 DALL-E 3는 박물관에 있을 법한 명작을 출력해 준 것이다.</p>

<p>나는 퀄리티 프롬프트라고 생각했던 프롬프트가 어디선가 이런 작용을 하고 있을 수 있다는 것을 항상 염두에 두어야 한다.</p>

<h3 id="환각">환각</h3>

<p><img src="/img/posts/ai_image/elephant.PNG" style="width: 80%" /></p>

<p>위 그림은 신경망에게 차 키를 들고 있지 않은 소년이라고 요청한 내용이다. 하지만 코끼리 효과가 일어난 모양인지 여지없이 차 키를 들고 있다.</p>

<p>이 둘은 GPT가 환각을 보는 원리와도 비슷하다. 뉴스에서 빔샤벨을 든 세종대왕의 멕북 에어 사태를 설명해 줘, 라고 요청했을 때 GPT가 신나서 설명해 주던 것 말이다. 이는 언어 모델의 한계 때문이지만 개인적으로는 꽤나 멋지다고 생각한다.</p>

<p>누가 빔샤벨을 든 세종대왕의 맥북 에어 사태를 그림으로 그릴 수 있겠는가? 안드로이드는 전기 양의 꿈을 꾸는가? 적어도 GPT는 그 꿈을 그릴 수 있는 것 같다.</p>

<p>사실 이 모든 과정이 어쩌면 창의성의 근본일지도 모른다. 고흐도 별이 빛나는 밤에를 그릴 때, 사실은 환각을 보고 있었다고 하니까.</p>]]></content><author><name>ash tensor</name></author><category term="ML" /><category term="AI그림" /><summary type="html"><![CDATA[ml, ai]]></summary></entry><entry><title type="html">[데이터 분석]조합에 따른 승률은 얼마나 차이가 날까?</title><link href="http://localhost:4000/ml/2023/12/19/esports-ml-1.html" rel="alternate" type="text/html" title="[데이터 분석]조합에 따른 승률은 얼마나 차이가 날까?" /><published>2023-12-19T00:00:00+09:00</published><updated>2023-12-19T00:00:00+09:00</updated><id>http://localhost:4000/ml/2023/12/19/esports-ml-1</id><content type="html" xml:base="http://localhost:4000/ml/2023/12/19/esports-ml-1.html"><![CDATA[<h1 id="조합에-따른-승률은-얼마나-차이가-날까">조합에 따른 승률은 얼마나 차이가 날까?</h1>

<p>나는 개인적으로 세이버 메트릭스를 매우 좋아한다.</p>

<p>규격화된 스텟과 지표. 물론 그것들이 게임의 모든 것을 설명할 수 있는 것은 아니다. 하지만 피터 드러커가 말한</p>

<ul>
  <li>측정되는 것이 관리되는 것(What gets measured get managed)이다.</li>
</ul>

<p>라는 어구처럼, 측정되는 것이야말로 사람의 손으로 관리되는 것이고, 이는 측정할 수 있어야만 비로소 관리하고 경영할 수 있다는 말이다.</p>

<p>하지만 이스포츠에서는 이러한 어구가 제대로 적용되지 않는다고 느낀다. 그래서 해설자들이 해설을 할 때도 자신의 경험에 비추어서 해설하고 과거의 바둑처럼 기세와 형세와 같은 추상적인 어구로 설명과 해설을 하고자 한다.</p>

<p>이는 어쩔 수 없다고는 생각한다. 하지만 알파고가 등장하면서 바둑도 현재 승률과 AI가 계산한 올바른 수, 그리고 메인라인(main line)등을 통하여 게임의 흐름과 형세를 구체적으로 지금 얼마나 불리한지, 얼마나 유리한지를 설명할 수 있게 되었다.</p>

<p>그럼 이스포츠에서도 그럴 수 있지 않을까?</p>

<h2 id="데이터-준비">데이터 준비</h2>

<p>일단 이를 위해서 RIOT API를 이용했다. RIOT API를 통해 약 3만 건의 챌린저 및 그랜드마스터의 매치를 수집했다. 과정은 다음과 같다.</p>

<p><img src="/img/posts/riot-api.png" style="width: 80%" /></p>

<p>이 둘은 상위 0.001% 게이머들로 활성 게이머 약 300만에 달하는 리그오브레전드 게이머 중 1천위 안에 드는 강자들로, 그 누구보다도 게임을 잘 이해하는 사람들이다.</p>

<p>일단 challengerleagues/by-queue/RANKED_SOLO_5x5 api를 및 grandmasterleaues/by-queue/RANKED_SOLO_5x5 api를 통해 현재 존재하는 챌린저와 그랜드마스터의 명단을 가져온다.</p>

<p>하지만 이는 summoner_id로 되어 있어서, 이를 통해 match data를 가져오려면 puuid를 이용해야 한다. 따라서 summoner/v4/summoners api를 사용해서 puuid를 가져온 다음, match/v5/matches/by-puuid api를 이용해서 각 puuid별 최근 매치 리스트의 인덱스를 가져오고, 최종적으로 매치 인덱스를 통해 매치 내용을 가져오는 식으로 매치 정보를 받아왔다.</p>

<p>순서대로 정리하면 다음과 같다.</p>

<ol>
  <li>challengerleagues/by-queue/RANKED_SOLO_5x5 api를 및 grandmasterleaues/by-queue/RANKED_SOLO_5x5 api를 통해 현재 존재하는 챌린저와 그랜드마스터의 명단을 가져오기</li>
  <li>summoner/v4/summoners api를 사용해서 summoner_id별로 puuid 가져오기</li>
  <li>match/v5/matches/by-puuid api를 이용해서 각 puuid별 최근 매치 리스트의 인덱스 가져오기</li>
  <li>매치 인덱스를 통해 매치 내용을 가져오는 식으로 매치 정보를 받아오기.</li>
</ol>

<p>이를 통해 수집한 데이터는 약 2만 1천건에 달한다. 이는 신경망을 훈련시키기에는 충분한 수치다.</p>

<h2 id="신경망-구성">신경망 구성</h2>

<p>케라스를 이용해서 신경망을 구성했다. 최종적으로 구성한 신경망은 다음과 같은데</p>

<p><img src="/img/posts/automodel.png" style="width: 40%" /></p>

<p>각 팀별 5명이고, 팀 1, 팀 2로 구성된 (2, 5)의 챔피언 배열이 들어가기 때문에 (2, 5)의 inputLayer가 구성되었다. 간단하게 시도해 볼 학습이라 autokeras를 이용해 간단하게 신경망을 구성했다.</p>

<p>이를 통해 max_trial = 20, epochs = 15로 학습시켜봤는데, 결과는 다음과 같이 나왔다.</p>

<p><img src="/img/posts/m2.png" style="width: 80%" /></p>

<p><img src="/img/posts/m3.png" style="width: 80%" /></p>

<p>정확도는 약 60%로 높아지고 있긴 했지만, 여기서 더 에포크를 늘린다고 하더라도 검증 정확도나 val loss는 줄어들지 않는 모습을 보였기 때문에, 여기서 학습을 마쳤다.</p>

<p>평가해 봤을때 val accuracy는 약 0.53으로 눈 감고 찍는 것보다 약 3% 승률이 높다고 할 수 있었다.</p>

<h2 id="높다면-높은-수치인가">높다면 높은 수치인가?</h2>

<p>이는 해석하기 나름이겠지만 과감하게 해석해 보자면, 조합이 숭률에 약 3% 정도 영향을 미친다고 할 수 있겠다. 물론 포스팅을 마친 이후에 데이터를 더 확인해 볼 예정이지만 이는 매우 과감한 추측인데 그 이유로는 신경망이 특정 조건(특정 조합과 특정 챔피언)만 찾아낼 수 있었을 수도 있기 때문에 SHAP 등의 도구를 이용해서 어떤 경우에 맞췄는지 확인해 봐야 할 것이다.</p>

<p>아무튼 이를 제쳐놓고라도, 53%라는 것은 아주 높은 수치라고 할 수 있다고 생각한다.</p>

<p>진행된 내 다른 연구에 의하면(나중에 정리해서 올리긴 할 거지만), 팀별로 처치한 용이 1마리 차이나면 승률이 약 2.2% 차이가 난다. 3%라면 즉 약 용 1.5개 만큼 차이난다는 의미인데…</p>

<p><img src="/img/posts/m4.png" style="width: 80%" /></p>

<p>엄청 크지 않나?</p>

<p>단순히 게임을 진행하기도 전에 진행된 게임의 조합 만으로도 용 1.5개 분만큼 승률이 차이난다는 의미인데 조합이 게임에 엄청나게 큰 영향을 미친다고 보는게 맞는 것 같다.</p>

<p>다음에는 챌린저 경기가 아닌 흔히 말하는 심해 경기, 골드, 플래티넘 구간의 경기를 검토해 봐야겠다.</p>

<p>의문점 및 조언이 있다면 언제나 환영한다!</p>]]></content><author><name>ash tensor</name></author><category term="ML" /><summary type="html"><![CDATA[ml, ai]]></summary></entry><entry><title type="html">[깃허브 블로그]지킬 블로그 카테고리 / NAVBAR 기능 추가(clean blog theme) - 1</title><link href="http://localhost:4000/%EA%B9%83%ED%97%88%EB%B8%8C/2023/12/15/jekyll-blog-theme-4.html" rel="alternate" type="text/html" title="[깃허브 블로그]지킬 블로그 카테고리 / NAVBAR 기능 추가(clean blog theme) - 1" /><published>2023-12-15T00:00:00+09:00</published><updated>2023-12-15T00:00:00+09:00</updated><id>http://localhost:4000/%EA%B9%83%ED%97%88%EB%B8%8C/2023/12/15/jekyll-blog-theme-4</id><content type="html" xml:base="http://localhost:4000/%EA%B9%83%ED%97%88%EB%B8%8C/2023/12/15/jekyll-blog-theme-4.html"><![CDATA[<h1 id="깃허브-블로그-카테고리-기능-추가clean-blog-theme">깃허브 블로그 카테고리 기능 추가(clean blog theme)</h1>

<p>네이버 블로그나 티스토리 블로그를 확인해 보면 당연히 카테고리 섹션이 있다. 이것도 역시, 댓글창처럼 당연하다면 당연하다고 생각한다. 그럴게, 블로그나 인터넷에서 글을 볼 때, 검색해서 들어가게 되면 그 주제의 글을 계속 봐야 할 때가 생긴다. 웹툰도, 만화도 1화만 보고 그 다음 화를 보지 못하면 답답하잖아?</p>

<p><img src="/img/posts/category/01.png" style="width: 75%" /></p>

<p>위에 볼 수 있는 것처럼 Clean blog theme에는 전체 post를 볼 수 있는 기능은 있지만 카테고리 기능이 없어서 불편하다고 생각했다.</p>

<p>필요하다면 만든다. 만드는데 조금 시간이 걸렸다.</p>

<h2 id="카테고리-레이아웃">카테고리 레이아웃</h2>

<p><img src="/img/posts/category/02.png" style="width: 75%" /></p>

<p>일단 내가 구현한 방법으로는, 위 사진처럼 전체 카테고리를 나열하는 전체 카테고리와</p>

<p><img src="/img/posts/category/03.png" style="width: 75%" /></p>

<p>그리고 그 세부 카테고리의 모든 글을 표시해주는 페이지를 만드는 방법으로 구현한 뒤에, 이 페이지에 존재하는 것처럼 navigation bar에 카테고리를 추가하는 것이다.</p>

<p>첫번째로 카테고리 레이아웃을 생성해야 한다. _layouts 디렉토리에 category.markdown 파일을 생성한다. 그리고</p>

<p><img src="/img/posts/category/04.png" style="width: 75%" /></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>---
layout: page
---
&lt;ul class="posts-list"&gt;

{% assign category = page.category | default: page.title %}
{% for post in site.categories[category] %}
    &lt;li&gt;
    &lt;h3&gt;
        &lt;a href="{{ site.baseurl }}{{ post.url }}"&gt;
        {{ post.title }}   
        &lt;/a&gt;
        &lt;small&gt;{{ post.date | date_to_string }}&lt;/small&gt;
    &lt;/h3&gt;
    &lt;/li&gt;
{% endfor %}

&lt;/ul&gt;
</code></pre></div></div>

<p>위 코드를 복사, 붙여넣기 한다.</p>

<p>위 코드는 이미 존재하는 페이지 레이아웃을 사용하면서, 모든 페이지를 순회하며 YAML 프론트매터의 categories 부분을 이용하여 카테고리 링크를 생성하는 코드다.</p>

<p>그리고 _layouts 디렉토리의 post.markdown을 수정한다.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&lt;!-- 카테고리를 추가하는 코드 --&gt;

        &lt;div&gt;
            {% for category in page.categories %}
            &lt;a href="{{ site.url }}/category/{{ category }}.html" style="color: white;"&gt;카테고리📁: {{ category }}&lt;/a&gt;
            {% endfor %}
        &lt;/div&gt;

&lt;!-- 카테고리를 추가하는 코드 --&gt;
</code></pre></div></div>

<p>위 코드를 붙여 넣으면 되는데, 이는 YAML 프론트매터를 이용해서 현재 페이지의 category를 이용해서 해당하는 링크를 만들어주는 코드다.</p>

<p><img src="/img/posts/category/05.png" style="width: 75%" /></p>

<p>나는 위 사진처럼 제목 부분 헤더 컨테이너 안에 하나, 그리고 본문 제목 위에 하나, 이렇게 삽입하고 싶기 때문에 두 번 삽입했다. 자신이 삽입하기 윈하는 위치에 삽입하면 된다.</p>

<p>만약 위 사진처럼 삽입하고 싶다면</p>

<p><img src="/img/posts/category/06.png" style="width: 75%" /></p>

<p>여기에 한 번</p>

<p><img src="/img/posts/category/07.png" style="width: 75%" /></p>

<p>여기에 한 번 복사해 넣으면 된다.</p>

<h2 id="카테고리-페이지-추가">카테고리 페이지 추가</h2>

<p>이게 끝이 아니다. 지킬 페이지는 개별 카테고리의 페이지를 직접 생성해 줘야 한다.</p>

<p><img src="/img/posts/category/03.png" style="width: 75%" /></p>

<p>바로 이 페이지를 만드는 과정이다. 만약 웹 페이지의 카테고리를 추가하기 위해서는 앞으로도 이 과정을 계속 수행해 줘야 한다! 그렇지 않으면 당연히 오류가 난다. 예를 들어서 당신이 지금은 C 카테고리만 있지만, java 카테고리를 만들고 싶으면 java 페이지를 추가해야 하는 것이다.</p>

<p>귀찮다. 하지만 어쩔 수 없다.</p>

<p>일단 루트 디렉토리에 category라는 디렉토리를 생성해야 한다. 어떤 방법으로 생성해도 상관없다.</p>

<p>그리고 난 뒤, 자신의 원하는 카테고리 이름으로 markdown 파일을 생성한다. 예를 들어서 이 페이지의 카테고리인 깃허브 카테고리를 만드려면</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>깃허브.markdown 
이런 식으로 이름을 생성하면 된다.
</code></pre></div></div>

<p>그리고 난 뒤 그 파일에 코드를 작성해 줄 텐데</p>

<p><img src="/img/posts/category/08.png" style="width: 75%" /></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>---
layout: category
title: 자격증
description: 자격증 📁카테고리의 모든 글.
background: '/img/bg-category.jpg'
---
</code></pre></div></div>

<p>이런 식으로 코드를 작성해 주면 된다. layout은 category를 사용하지만(방금 전 작성한) category layout은 page 레이아웃을 상속받아 사용하기 때문에 descripion 및 background 프론트매터를 사용 가능하다!</p>

<p>descripion은 카테고리 페이지의 설명에 사용되니 자기가 원하는대로 사용하면 된다.</p>

<p>이러면 카테고리 페이지는 완성했다!</p>

<p>사실 한번에 쓰고자 했었는데, 쓰다 보니까 내용이 너무 길어져서 전체 카테고리 포스트 생성과 navigation bar를 생성하는 법은 다음 포스트에 작성하도록 하겠다.</p>]]></content><author><name>ash tensor</name></author><category term="깃허브" /><summary type="html"><![CDATA[troubleshooting]]></summary></entry><entry><title type="html">[깃허브 블로그]지킬 블로그 코멘트 기능 추가(clean blog theme)</title><link href="http://localhost:4000/%EA%B9%83%ED%97%88%EB%B8%8C/2023/12/14/jekyll-blog-theme-3.html" rel="alternate" type="text/html" title="[깃허브 블로그]지킬 블로그 코멘트 기능 추가(clean blog theme)" /><published>2023-12-14T00:00:00+09:00</published><updated>2023-12-14T00:00:00+09:00</updated><id>http://localhost:4000/%EA%B9%83%ED%97%88%EB%B8%8C/2023/12/14/jekyll-blog-theme-3</id><content type="html" xml:base="http://localhost:4000/%EA%B9%83%ED%97%88%EB%B8%8C/2023/12/14/jekyll-blog-theme-3.html"><![CDATA[<h1 id="깃허브-블로그-코멘트-기능-추가clean-blog-theme">깃허브 블로그 코멘트 기능 추가(clean blog theme)</h1>

<p>블로그에는 기본적으로 댓글 란은 무조건 있어야 한다고 생각한다. 추가하는게 어렵지 않다. 터미널을 두드릴 필요도 없다. 오히려 카테고리 란을 추가하는게 조금 더 어려운 것 같다. 그러면 한번 추가해 보자고!</p>

<h2 id="disqus">DISQUS</h2>

<p>깃허브 페이지를 사용하는 데 있어서 가장 많이 사용하는 덧글/코멘트 기능이라고 하면 DISQUS다. STACK OVERFLOW나 다른 곳에서도 가장 먼저 추천하는 기능이다. 게다가 무료다! 사용하지 않을 이유가 없다.</p>

<p><img src="/img/posts/clean-blog-setup/09.png" style="width: 75%" /></p>

<p>지금 이 포스트 아래에도 붙어있는 댓글란인데, 많은 깃허브 페이지들을 보다 보면 대부분의 댓글이 이렇게 생긴 것을 확인할 수 있을 것이다.</p>

<p><a href="https://disqus.com/profile/signup/intent/">일단 여기</a>서 회원가입을 해 주면 된다.</p>

<p><img src="/img/posts/clean-blog-setup/10.png" style="width: 75%" /></p>

<p>회원가입을 하고 나면 이런 창이 보일 텐데, I want to install Disqus on my site를 눌러 주면 된다. 그리고 사이트 이름을 정해주고 난 뒤, 요금이 들지 않는 BASIC 요금제를 선택해 주고 select platform에서 jekyll을 선택해 주면 된다.</p>

<p><img src="/img/posts/clean-blog-setup/12.png" style="width: 75%" /></p>

<p>그리고 나면</p>

<p><img src="/img/posts/clean-blog-setup/13.png" style="width: 75%" /></p>

<p>위 사진에서도 나와있듯이 Universial Embed code 링크를 클릭해서 들어간 뒤</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&lt;div id="disqus_thread"&gt;&lt;/div&gt;
&lt;script&gt;
    /**
    *  RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM
    *  ...
    *  ...
    *  생략함
</code></pre></div></div>

<p>위 꼴의 universial embed code를 복사한다. 그리고 난 뒤 자신의 지킬 블로그가 설치되어 있는 로컬 폴더로 들어간다.</p>

<p>그리고 난 뒤, _layout 디렉토리의 post.markdown 파일로 들어간 뒤</p>

<p><img src="/img/posts/clean-blog-setup/15.png" style="width: 75%" /></p>

<p>이 부분에 아까 복사한 자신의 코드를 붙여넣기 하면 된다! 이제 다 끝났다!</p>

<h2 id="yaml-프론트매터">YAML 프론트매터</h2>

<p>위 코드는 자신의 disqus 댓글창을 생성하는 코드로, 당연하겠지만 항상 코멘트 섹션을 생성한다. 만약 그게 싫고, 포스트별로 댓글 창을 설정하고 싶은 경우에는 추가적으로 코드를 적어 넣어야 한다.</p>

<p><img src="/img/posts/clean-blog-setup/14.png" style="width: 75%" /></p>

<p>이 포스트의 프론트매터인데, 댓글을 달고싶은 포스트의 프론트매터에 위 사진처럼</p>

<p>속성을 넣어주면 된다. 그러면 지킬이 페이지를 구성할 때, disquss를 참조해서 포스트를 구성하게 된다. 그리고 난 뒤, 아까 수정했던 post.markdown에 들어가서 아까 작성했던 코드 스니펫의 앞 뒤에 if page.comments 와 endif 블록을 작성해 넣으면 된다.</p>

<p><img src="/img/posts/clean-blog-setup/16.png" style="width: 75%" />
<img src="/img/posts/clean-blog-setup/17.png" style="width: 75%" /></p>

<p>이런식으로!</p>

<p>충분히 이해 가능하겠지만, 이는 페이지의 yaml 프론트메터의 comments 부분이 참이면 아래의 코드 스니펫을 실행하라는 의미이다.</p>]]></content><author><name>ash tensor</name></author><category term="깃허브" /><summary type="html"><![CDATA[troubleshooting]]></summary></entry></feed>