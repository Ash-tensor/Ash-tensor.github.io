<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.3.2">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2024-03-06T15:17:15+09:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">Tensor Studio</title><subtitle>텐서 스튜디오</subtitle><author><name>ash tensor</name></author><entry><title type="html">[후기] 알리익스프레스 SD카드 배송 후기 / 용량 뻥튀기 확인하는법</title><link href="http://localhost:4000/%EB%A6%AC%EB%B7%B0/2024/03/06/sd-card.html" rel="alternate" type="text/html" title="[후기] 알리익스프레스 SD카드 배송 후기 / 용량 뻥튀기 확인하는법" /><published>2024-03-06T00:00:00+09:00</published><updated>2024-03-06T00:00:00+09:00</updated><id>http://localhost:4000/%EB%A6%AC%EB%B7%B0/2024/03/06/sd-card</id><content type="html" xml:base="http://localhost:4000/%EB%A6%AC%EB%B7%B0/2024/03/06/sd-card.html"><![CDATA[<h2 id="후기-알리익스프레스-sd카드-배송-리뷰">[후기] 알리익스프레스 SD카드 배송 리뷰</h2>

<p>최근 알리익스프레스에서 SD카드를 주문했다. 왜냐하면, 라즈베리파이를 웹 데이터베이스로 사용하고 싶었는데, 그러기 위해서는 SD카드가 필요했기 때문이다.
기본적으로 라즈베리파이나 오렌지파이 같은 원보드 컴퓨터들은 저장공간으로 SD카드를 사용하고, 부트로더도 SD카드를 사용하기 때문에, 한번 키기 위해서라도 SD카드가 필수적이다.</p>

<p>아무래도 웹 데이터베이스로 사용할 것이기 때문에 큰 용량이 필요했고, 256GB SD카드를 주문했다.</p>

<p><img src="/img/posts/sdcard/1.png" width="80%" /></p>

<p>이게 모든 문제의 시작이었다.</p>

<h3 id="문제-설명">문제 설명</h3>

<p>알리익스프레스에서 저장장치를 사지 말라고 하는건 굉장히 널리 퍼진 조언이지만, 예전에 SSD를 저렴하게 구매한 적이 있는데, 그 SSD는 아무런 문제 없이 작동했고,
꽤나 성능도 괜찮았기 때문에 “설마 SSD도 제대로 오는데 SD카드가 제대로 오지 않겠어?” 라고 생각했기 때문이다…</p>

<p>그때 500GB SSD를 2만원 안 되게 산 것 같은데, 이번 SD카드도 1만원 좀 안 되길래 용량 뻥튀기나 사기가 아니지 않을까? 라는 헛된 생각이 있었고,
그리고 AliExpress Choice 라는 딱지가 붙어 있었기 때문에, 뭔가 나에게 약간의 신뢰감을 줬다. 그래서 구매했지만…</p>

<h3 id="와-실제-사용할-수-있는-용량은-500메가도-안-돼">와 실제 사용할 수 있는 용량은 500메가도 안 돼?</h3>

<p>SD카드를 받고, 라즈베리파이 운영체제 이미지를 굽기 위해서 balenaEtcher를 이용해서 깔기 시작했는데 초기 500메가 정도만 인스톨되고 그 이후에는 초당 0.3메가 정도로 떨어지더니 
전부 인스톨되는데 예상시간이 하염없이 길어지기 시작했다. 여기서 눈치챘다. 아, 내가 당했구나 라고…</p>

<p>이런 경우에 사용할 수 있는 프로그램으로 <strong>H2testw</strong> 라는 프로그램이 있다. 이 프로그램은 SD카드의 실제 용량을 확인할 수 있는 프로그램이다. 더미 파일을 만들고, 그 파일을 validate하는 방식으로 용량을 확인한다.
그래서 확인해 본 결과…</p>

<p><img src="/img/posts/sdcard/2.png" width="80%" /></p>

<p>실제 사용할 수 있는 용량은 500메가 정도 밖에는 안 되고, 나머지는 전부 오류가 나는 모습을 확인할 수 있다. 
게다가 악질인 건, SD 카드의 모습이 마치 SanDisk 제품인 것처럼 래핑을 해 놓은 모습인데(실제로는 SanDian 으로 적혀있다..) 이런 가짜 SSD 카드가 알리 익스프레스에
널려 있다는 것이다.</p>

<ol>
  <li>이렇게 SanDian과 같이 이미 존재하는 브랜드를 흉내내는 경우</li>
  <li>그리고 레노버 SD카드라고 판매하는 제품이 있는데 « 레노버는 SD카드를 판매하지 않는다고 하니까 의심해 볼만 하다.</li>
  <li>용량에 비해 가격이 너무 저렴한 경우</li>
</ol>

<p>에는 의심을 해야 할 것 같다.</p>

<p>환불 받고 싶지만 환불하기까지의 과정이 너무 복잡하고, 고객센터 및 판매자와의 소통이 너무 어려워서 그냥 포기하고, 다시 SD카드를 구매하기로 했다.
쿠팡에서 삼성 SD 카드로..</p>]]></content><author><name>ash tensor</name></author><category term="리뷰" /><summary type="html"><![CDATA[[후기] 알리익스프레스 SD카드 배송 리뷰]]></summary></entry><entry><title type="html">[DB] 구체화된 뷰는 테이블과 어떻게 다를까?</title><link href="http://localhost:4000/db/2024/02/29/materialized-view.html" rel="alternate" type="text/html" title="[DB] 구체화된 뷰는 테이블과 어떻게 다를까?" /><published>2024-02-29T00:00:00+09:00</published><updated>2024-02-29T00:00:00+09:00</updated><id>http://localhost:4000/db/2024/02/29/materialized-view</id><content type="html" xml:base="http://localhost:4000/db/2024/02/29/materialized-view.html"><![CDATA[<h2 id="db-물리-뷰는-테이블과-어떻게-다를까">[DB] 물리 뷰는 테이블과 어떻게 다를까?</h2>

<h3 id="문제-설명">문제 설명</h3>

<p>테이블은 데이터베이스의 기본적인 저장 단위로, 행과 열로 구성되어 있고, 실제로 데이터를 저장한다. 그리고 뷰는 실제 데이터를 저장하지 않는다.
뷰는 하나 이상의 테이블을 가상의 테이블처럼 보이게 하는 것이다. 
뷰는 쿼리를 이용해서 생성되며, 실제 데이터를 저장하지는 않고, 데이터에 대한 참조만을 저장한다.</p>

<p>이는 일반적인 논리적 뷰의 설명이다. 그렇다면 물리적 뷰는 테이블과 어떻게 다를까?</p>

<h3 id="물리적-뷰--구체화된-뷰">물리적 뷰 / 구체화된 뷰</h3>

<p>“물리적 뷰는 테이블과 어떻게 다르지?” 라는 질문을 받았는데, 대답을 하지 못해서 당황했었다. 왜냐하면, 물리 뷰라는 이름에서 다가오는 늬앙스가 
뷰라는 실체가 없고 가상의 테이블이라는 늬앙스와는 다르게 느껴졌기 때문이다.</p>

<p>뷰는 실제 데이터를 저장하지 않는데, 물리 뷰라고? 그렇다면 Physical view라는 말인가? 그럼 피지컬한 실체가 있는 건가? 이런 식으로 생각이 흘러갔기 때문이다.
하지만 물리적 뷰, 즉 materialized view는 이런 개념과는 거리가 있다.</p>

<p>물리적 뷰는 뷰와는 다르게 실제 데이터를 저장한다. 뷰는 쿼리를 이용하여 생성되며, 실제 데이터를 저장하지 않는다. 하지만 물리적 뷰는 쿼리를 이용하여 생성되며, 실제 데이터를 저장한다.
일반적인 뷰와는 다르게, 물리적 뷰는 DB상에 그 실체가 있다.</p>

<p>그렇다면 정말로, 테이블이라고 할 수 있을 것이다. 그렇다면 물리적 뷰는 테이블과 어떻게 다를까?</p>

<h3 id="물리적-뷰는-새로운-데이터를-저장하는-것이-아니라-기존의-데이터를-저장한다">물리적 뷰는 새로운 데이터를 저장하는 것이 아니라, 기존의 데이터를 저장한다.</h3>

<p>그러니까 즉, 물리적 뷰는 이미 존재하는 데이터를 이용해서, 일정부분 가공하고, 필터링된 데이터를 저장한다고 볼 수 있다. 새로운 데이터를 저장하는 테이블과는 거리가 있다. 정규화가 잘 된 테이블이 존재한다고 해 보자. 그런 경우에는 
사업 또는 비즈니스 사이클에 필요한 데이터를 얻는다고 할 때, 정규화된 여러 테이블을 조인해야만 필요한 데이터를 얻어야 하는 경우가 많다.</p>

<p>하지만 이런 경우에는 데이터를 조회할 때마다 계속 조인이 발생하고, 매번 쿼리할 때마다 계산이 필요해진다. 이런 경우에는 정규화가 잘 된 테이블이지만 오히려 서비스의 성능을 낮출 수 있다.</p>

<h3 id="반정규화">반정규화?</h3>

<p>아마 DB이론을 공부한 사람이라면 이 경우에 바로 반정규화를 떠올릴 것이다. 중복 테이블을 생성하거나, 중복 컬럼 생성, 테이블 병합 등, 여러 방법이 존재하지만 이 경우에 DB의 무결성이 깨지게 되고, 이는 
시스템의 안정성을 해칠 수 있다. 반정규화에 대한 대안으로 물리적 뷰를 사용할 수 있다.</p>

<p>물리적 뷰, 구체화된 뷰는 특정 쿼리의 결과를 데이터베이스에 물리적 실체로 저장하고, 뷰에 엑세스 할 때마다 
복잡한 쿼리(JOIN, GROUP BY, ORDER BY 등)를 실행하지 않고, 저장된 결과를 단순히 조회함으로써 성능을 향상시킬 수 있다.</p>

<h3 id="예제">예제</h3>

<p>아래 쿼리는 sales 테이블에서 sale_date를 기준으로 월별 매출 합계를 계산하여 
monthly_sales_summary 매터리얼라이즈드 뷰를 생성한다. 
이제 이 매터리얼라이즈드 뷰를 사용하여 월별 매출에 대한 정보를 조회 한 번으로 얻을 수 있다.</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="c1">-- 매터리얼라이즈드 뷰 생성 쿼리</span>
<span class="k">CREATE</span> <span class="n">MATERIALIZED</span> <span class="k">VIEW</span> <span class="n">monthly_sales_summary</span> <span class="k">AS</span>
<span class="k">SELECT</span>
    <span class="k">EXTRACT</span><span class="p">(</span><span class="nb">YEAR</span> <span class="k">FROM</span> <span class="n">sale_date</span><span class="p">)</span> <span class="k">AS</span> <span class="n">sale_year</span><span class="p">,</span>
    <span class="k">EXTRACT</span><span class="p">(</span><span class="k">MONTH</span> <span class="k">FROM</span> <span class="n">sale_date</span><span class="p">)</span> <span class="k">AS</span> <span class="n">sale_month</span><span class="p">,</span>
    <span class="k">SUM</span><span class="p">(</span><span class="n">amount</span><span class="p">)</span> <span class="k">AS</span> <span class="n">total_sales</span>
<span class="k">FROM</span>
    <span class="n">sales</span>
<span class="k">GROUP</span> <span class="k">BY</span>
    <span class="k">EXTRACT</span><span class="p">(</span><span class="nb">YEAR</span> <span class="k">FROM</span> <span class="n">sale_date</span><span class="p">),</span>
    <span class="k">EXTRACT</span><span class="p">(</span><span class="k">MONTH</span> <span class="k">FROM</span> <span class="n">sale_date</span><span class="p">);</span>

</code></pre></div></div>

<p>다음은 매터리얼라이즈드 뷰 새로고침 명령이다. 이 명령은 매터리얼라이즈드 뷰의 데이터를 새로 고쳐서 최신 데이터로 업데이트한다.</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="n">REFRESH</span> <span class="n">MATERIALIZED</span> <span class="k">VIEW</span> <span class="n">monthly_sales_summary</span><span class="p">;</span>

</code></pre></div></div>

<h3 id="dbms-별-구체화된-뷰-지원">DBMS 별 구체화된 뷰 지원</h3>

<p>구체화된 뷰는 DBMS에 따라 지원 여부가 다르다. MYSQL은 지원하지 않는다. 오라클은 지원한다. 오라클은 보통 자동으로 새로 고치지만,
수동으로 새로고침을 할 수도 있다. SQL Server는 Indexed View라는 이름으로 지원한다.</p>]]></content><author><name>ash tensor</name></author><category term="DB" /><summary type="html"><![CDATA[[DB] 물리 뷰는 테이블과 어떻게 다를까?]]></summary></entry><entry><title type="html">[JAVA] 배열에서는 왜 contains() 메소드가 제대로 작동하지 않을까?</title><link href="http://localhost:4000/java/2024/02/28/java-contain.html" rel="alternate" type="text/html" title="[JAVA] 배열에서는 왜 contains() 메소드가 제대로 작동하지 않을까?" /><published>2024-02-28T00:00:00+09:00</published><updated>2024-02-28T00:00:00+09:00</updated><id>http://localhost:4000/java/2024/02/28/java-contain</id><content type="html" xml:base="http://localhost:4000/java/2024/02/28/java-contain.html"><![CDATA[<h2 id="java-배열에서는-왜-contains-메소드가-제대로-작동하지-않을까">[JAVA] 배열에서는 왜 contains() 메소드가 제대로 작동하지 않을까?</h2>

<h3 id="문제-설명">문제 설명</h3>

<p>자바의 contain() 메소드는 배열에서 제대로 작동하지 않는다. 다시 말하면, 예를 들어서 ArrayList에 int[] 타입의 배열을 넣고, contains() 메소드를 사용하여 같은 값을 가진 배열을 찾아내는 것이 불가능하다.
하지만 ArrayList에 Integer 타입의 배열을 넣고, contains() 메소드를 사용하여 같은 값을 가진 배열을 찾아내는 것은 가능하다.
분명 contains() 메소드도 eqauls() 메소드를 사용하여 값을 비교하도록 되어있는데, ArrayList<Integer>의 경우에는 가능하고, int[]의 경우에는 불가능하다.</Integer></p>

<p>왜 가능할까?</p>

<h4 id="배열의-경우">배열의 경우</h4>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="kn">package</span> <span class="nn">boj</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">java.util.ArrayList</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.Arrays</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.List</span><span class="o">;</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">equal_test</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
    
    <span class="c1">// 테스트용 ArrayList 생성</span>
        <span class="nc">ArrayList</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">[]&gt;</span> <span class="n">testArrayList</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;();</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">targetIntArray</span> <span class="o">=</span> <span class="o">{</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">};</span>

        <span class="n">testArrayList</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">targetIntArray</span><span class="o">);</span>
        <span class="kt">boolean</span> <span class="n">question1</span> <span class="o">=</span> <span class="n">testArrayList</span><span class="o">.</span><span class="na">contains</span><span class="o">(</span><span class="n">targetIntArray</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">question1</span><span class="o">);</span>
        <span class="c1">// true 출력</span>

        <span class="c1">// 같은 값을 가진 배열을 생성하여 contains() 메소드를 사용</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">sameValueArray</span> <span class="o">=</span> <span class="o">{</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">};</span>
        <span class="kt">boolean</span> <span class="n">question2</span> <span class="o">=</span> <span class="n">testArrayList</span><span class="o">.</span><span class="na">contains</span><span class="o">(</span><span class="n">sameValueArray</span><span class="o">);</span>
        
        <span class="c1">// false 출력</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">question2</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>

</code></pre></div></div>

<p><img src="/img/posts/JAVA/equals/2.png" style="display: block; margin-left: auto; margin-right: auto; width: 100%" /></p>

<p>아마 감이 좋다면 String에서 == 연산자와 equals() 메소드의 차이점을 떠올리며 감을 잡을 수 있을 것이다. String의 경우에는 == 연산자를 사용하여 두 String의 주소를 비교하고, equals() 메소드를 사용하여 두 String의 값을 비교했었다.
contain() 역시 equal() 메소드를 사용한다. 그렇다면 왜 같은 값을 가진 배열을 찾아내지 못할까?</p>

<p>위 코드의 예시를 통해 확인할 수 있듯, 배열의 경우 contains() 메소드를 사용하여 같은 값을 가진 배열을 찾아내는 것이 불가능하다. 디버거를 이용해서 주소를 확인해 보면 다음과 같은데
배열 변수의 주소가 다른 것을 확인할 수 있다. 하지만 배열 변수의 주소가 다르기 때문에 false를 반환하는 것이 아니다. ArrayList의 equals() 메소드는 단순히 배열 변수의 주소만을 비교하지는 않는다. 이는 다음 코드를 확인하면 더욱 명확해진다.</p>

<h4 id="arraylist-의-경우">ArrayList<Integer> 의 경우</Integer></h4>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="kn">package</span> <span class="nn">boj</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">java.util.ArrayList</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.Arrays</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.List</span><span class="o">;</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">equal_test</span> <span class="o">{</span>
<span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
    
    <span class="c1">// 테스트용 ArrayList 생성</span>
        <span class="nc">ArrayList</span><span class="o">&lt;</span><span class="nc">ArrayList</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;&gt;</span> <span class="n">testArrayList</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;();</span>

    <span class="c1">// ArrayList에 Integer 타입의 ArrayList를 넣음</span>
        <span class="nc">ArrayList</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">targetIntArrayList</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;();</span>
        <span class="n">targetIntArrayList</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="mi">1</span><span class="o">);</span>
        <span class="n">targetIntArrayList</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="mi">2</span><span class="o">);</span>
        <span class="n">testArrayList</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">targetIntArrayList</span><span class="o">);</span>
        
        <span class="kt">boolean</span> <span class="n">question1</span> <span class="o">=</span> <span class="n">testArrayList</span><span class="o">.</span><span class="na">contains</span><span class="o">(</span><span class="n">targetIntArrayList</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">question1</span><span class="o">);</span>
    <span class="c1">// true 출력</span>

        <span class="nc">ArrayList</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">sameValueArray</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;();</span>
        
    <span class="c1">// 같은 값을 가진 ArrayList를 생성하여 contains() 메소드를 사용</span>
        <span class="n">sameValueArray</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="mi">1</span><span class="o">);</span>
        <span class="n">sameValueArray</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="mi">2</span><span class="o">);</span>
        <span class="kt">boolean</span> <span class="n">question2</span> <span class="o">=</span> <span class="n">testArrayList</span><span class="o">.</span><span class="na">contains</span><span class="o">(</span><span class="n">sameValueArray</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">question2</span><span class="o">);</span>
    <span class="c1">// true 출력</span>
    <span class="o">}</span>
<span class="o">}</span>

</code></pre></div></div>

<p>위 코드를 실행해 보면 알 수 있듯, 배열과는 달리, 같은 값을 가진 ArrayList<Integer> 의 경우에는 둘 다 true를 반환하는 것을 확인할 수 있다. 하지만 이를 디버거로 확인해 보면, 두 ArrayList<Integer>의 
주소는 다르다. 그런데도 불구하고, contains() 메소드는 두 ArrayList<Integer>의 값을 비교하여 같은 값을 가진 것으로 판단한다.</Integer></Integer></Integer></p>

<p><img src="/img/posts/JAVA/equals/4.png" style="display: block; margin-left: auto; margin-right: auto; width: 100%" /></p>

<p>이는 ArrayList<Integer>의 경우에, int 값이 아닌 Integer 객체를 비교하기 때문이다. 위 사진을 보면 코드상에서는 분명, 둘 다 각각 int(1, 2)를 집어넣었는데도 불구하고
Integer 객체의 경우에 두 ArrayList 모두 똑같은 객체의 Integer 객체를 가리키고 있는 것을 확인할 수 있다. 이 이전의 배열 사진을 확인해 보면 각각의 int는 다른 객체를 가리키고 있는 것을 확인할 수 있다.
자바에서 기본 자료형 (int, char 등)은 객체로 취급받지 않고 특정한 값으로 취급받는다. 하지만 Integer, Character 등은 객체로 취급받고, java의 Heap 영역에 적재되어 있다. 
따라서 아무리 많은 Integer, Character, String 등의 객체를 사용하더라도, 같은 값을 가지고 있으면 같은 주소를 가지는 동일한 객체를 가리키고 있는 것이다.</Integer></p>

<p>또한 ArrayList<Integer>의 경우에는 equals() 메소드를 사용하여 두 객체의 값을 비교한다. equals() 메소드는 객체의 값을 비교하기 위해 equals() 메소드를 오버라이딩하여 사용한다.</Integer></p>

<p>그래서 ArrayList<Integer>의 경우에는 contains() 메소드를 사용하여 같은 값을 가진 객체를 찾아낼 수 있다!!</Integer></p>]]></content><author><name>ash tensor</name></author><category term="JAVA" /><summary type="html"><![CDATA[[JAVA] 배열에서는 왜 contains() 메소드가 제대로 작동하지 않을까?]]></summary></entry><entry><title type="html">[백준] 백준 1743번 :: 음식물 피하기 :: 실버 1</title><link href="http://localhost:4000/%EB%B0%B1%EC%A4%80/ps/java/%ED%8C%8C%EC%9D%B4%EC%8D%AC/2024/02/27/boj1743.html" rel="alternate" type="text/html" title="[백준] 백준 1743번 :: 음식물 피하기 :: 실버 1" /><published>2024-02-27T00:00:00+09:00</published><updated>2024-02-27T00:00:00+09:00</updated><id>http://localhost:4000/%EB%B0%B1%EC%A4%80/ps/java/%ED%8C%8C%EC%9D%B4%EC%8D%AC/2024/02/27/boj1743</id><content type="html" xml:base="http://localhost:4000/%EB%B0%B1%EC%A4%80/ps/java/%ED%8C%8C%EC%9D%B4%EC%8D%AC/2024/02/27/boj1743.html"><![CDATA[<h2 id="백준-백준-1743번--음식물-피하기--실버-1">[백준] 백준 1743번 :: 음식물 피하기 :: 실버 1</h2>

<h3 id="문제-설명">문제 설명</h3>

<p>코레스코 콘도미니엄 8층은 학생들이 3끼의 식사를 해결하는 공간이다. 그러나 몇몇 비양심적인 학생들의 만행으로 음식물이 통로 중간 중간에 떨어져 있다. 이러한 음식물들은 근처에 있는 것끼리 뭉치게 돼서 큰 음식물 쓰레기가 된다.</p>

<p>이 문제를 출제한 선생님은 개인적으로 이러한 음식물을 실내화에 묻히는 것을 정말 진정으로 싫어한다. 참고로 우리가 구해야 할 답은 이 문제를 낸 조교를 맞추는 것이 아니다.</p>

<p>통로에 떨어진 음식물을 피해가기란 쉬운 일이 아니다. 따라서 선생님은 떨어진 음식물 중에 제일 큰 음식물만은 피해 가려고 한다.</p>

<p>선생님을 도와 제일 큰 음식물의 크기를 구해서 “10ra”를 외치지 않게 도와주자.</p>

<p><strong>입력</strong></p>

<p>첫째 줄에 통로의 세로 길이 N(1 ≤ N ≤ 100)과 가로 길이 M(1 ≤ M ≤ 100) 그리고 음식물 쓰레기의 개수 K(1 ≤ K ≤ N×M)이 주어진다.  그리고 다음 K개의 줄에 음식물이 떨어진 좌표 (r, c)가 주어진다.</p>

<p>좌표 (r, c)의 r은 위에서부터, c는 왼쪽에서부터가 기준이다. 입력으로 주어지는 좌표는 중복되지 않는다.</p>

<p><strong>출력</strong></p>

<p>첫째 줄에 음식물 중 가장 큰 음식물의 크기를 출력하라.</p>

<h3 id="제한시간">제한시간</h3>

<p>2 초	256 MB</p>

<h3 id="예제-입력">예제 입력</h3>

<p>3 4 5</p>

<p>3 2</p>

<p>2 2</p>

<p>3 1</p>

<p>2 3</p>

<p>1 1</p>

<h3 id="예제-출력">예제 출력</h3>

<p>4</p>

<h3 id="힌트">힌트</h3>

<p>O . . .</p>

<p>. O O .</p>

<p>O O . .</p>

<h4 id="접근방법">접근방법</h4>

<p>탐색 문제이고, 군집군 검사? 이런 문제를 어떻게 부르는지는 잘 모르겠지만, 가까이 있는 동일한 개체를 찾아내는 문제의 표본이라고 할 수 있는 문제이다.
단순한 BFS / DFS 탐색 문제하고는 다른데, 그 이유는 이 문제는 군집을 찾아내는 문제이기 때문이다. 왜냐하면 DFS/BFS로 탐색을 하더라도, 한번의 Depth에서 모든 연결되어 있는 노드를
검색할 수 없기 때문에, 중간에 탐색이 한 번 끊기게 되고 그 다음에 탐색을 시작하게 되면 사실 붙어있는 같은 군집인데 실제로는 다른 군집을 찾게 되기 때문이다.</p>

<p>위의 힌트를 가지고 예를 들어 보자.</p>

<p>(2, 2)의 점(이 문제에서는 첫번째 행과 첫번째 열이 1로 주어졌다)에서 DFS로 탐색을 시작한다고 해 보자.</p>

<p>그렇다면 실제로 연결되어 있는 노드는 (2, 3), (3, 2), (3, 1)이다. 하지만 첫번째 Depth에서는 (2, 3)과 (3, 2)를 탐색하고, 다음 Depth에서 (3, 1)을 탐색하게 되는데,
이 경우에 각각의 Depth에서의 탐색은 서로 다른 군집으로 인식할 수 있기 때문에, 이를 제대로 세 주어야 한다.</p>

<p>그리고 이 문제를 풀면서, 처음에는 각각의 노드의 순서쌍을 배열 int[] node = new int[2]로 선언해서 사용했는데, 이렇게 하면 HashSet에 넣을 때, 같은 순서쌍이라도 다른 객체로 인식되어서
HashSet에 중복된 노드가 들어가게 된다. 또한 중복 검사, 예를 들면 visitedNodes.contains()와 같은 메소드에서 항상 false만을 리턴하게 된다.
그래서 ArrayList<Integer>로 선언해서 사용했는데, 더 간단한 방법이 있을 것 같아서 조금 더 공부할 필요를 느꼈다.</Integer></p>

<h4 id="자바-코드">자바 코드</h4>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="kn">package</span> <span class="nn">boj</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">java.util.*</span><span class="o">;</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">newboj1743</span> <span class="o">{</span>

    <span class="kd">static</span> <span class="kt">int</span><span class="o">[]</span> <span class="no">MAX_AMOUNT</span><span class="o">;</span> <span class="c1">// 군집을 세기 위해서 선언한 배열</span>
    <span class="c1">// 각각 노드의 군집의 크기를 저장하기 위한 배열로 크기는 nodeList.size()와 같다.</span>
    <span class="kd">static</span> <span class="nc">HashSet</span><span class="o">&lt;</span><span class="nc">ArrayList</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;&gt;</span> <span class="n">visitedNodes</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HashSet</span><span class="o">&lt;&gt;();</span>
    <span class="c1">// 방문한 노드를 저장하기 위한 HashSet</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">Scanner</span> <span class="n">scanner</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Scanner</span><span class="o">(</span><span class="nc">System</span><span class="o">.</span><span class="na">in</span><span class="o">);</span>
        <span class="nc">ArrayList</span><span class="o">&lt;</span><span class="nc">ArrayList</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;&gt;</span> <span class="n">condition</span> <span class="o">=</span> <span class="n">setCondition</span><span class="o">(</span><span class="n">scanner</span><span class="o">);</span>
        <span class="nc">ArrayList</span><span class="o">&lt;</span><span class="nc">ArrayList</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;&gt;</span> <span class="n">nodeList</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;();</span>

        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">condition</span><span class="o">.</span><span class="na">size</span><span class="o">();</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="n">nodeList</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">condition</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">i</span><span class="o">));</span>
        <span class="o">}</span>

        <span class="no">MAX_AMOUNT</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">nodeList</span><span class="o">.</span><span class="na">size</span><span class="o">()];</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="no">MAX_AMOUNT</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="no">MAX_AMOUNT</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span>
            
            <span class="c1">//군집 배열의 값을 1로 초기화</span>
        <span class="o">}</span>

        <span class="k">for</span> <span class="o">(</span><span class="nc">ArrayList</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">node</span> <span class="o">:</span> <span class="n">nodeList</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">if</span> <span class="o">(!</span><span class="n">visitedNodes</span><span class="o">.</span><span class="na">contains</span><span class="o">(</span><span class="n">node</span><span class="o">))</span> <span class="o">{</span>
            <span class="c1">//nodeList에 있어서 각각의 node가 방문한 노드가 아니라면 dfs를 시작한다.</span>
                <span class="n">dfs</span><span class="o">(</span><span class="n">node</span><span class="o">,</span> <span class="n">nodeList</span><span class="o">,</span> <span class="n">condition</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="mi">0</span><span class="o">),</span> <span class="n">nodeList</span><span class="o">.</span><span class="na">indexOf</span><span class="o">(</span><span class="n">node</span><span class="o">));</span>
            <span class="o">}</span>
        <span class="o">}</span>

        <span class="nc">OptionalInt</span> <span class="n">max</span> <span class="o">=</span> <span class="nc">Arrays</span><span class="o">.</span><span class="na">stream</span><span class="o">(</span><span class="no">MAX_AMOUNT</span><span class="o">).</span><span class="na">max</span><span class="o">();</span>
        <span class="kt">int</span> <span class="n">answer</span> <span class="o">=</span> <span class="n">max</span><span class="o">.</span><span class="na">getAsInt</span><span class="o">();</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">answer</span><span class="o">);</span>


    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="nc">ArrayList</span><span class="o">&lt;</span><span class="nc">ArrayList</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;&gt;</span> <span class="nf">setCondition</span><span class="o">(</span><span class="nc">Scanner</span> <span class="n">scanner</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="n">scanner</span><span class="o">.</span><span class="na">nextInt</span><span class="o">();</span>
        <span class="kt">int</span> <span class="n">y</span> <span class="o">=</span> <span class="n">scanner</span><span class="o">.</span><span class="na">nextInt</span><span class="o">();</span>
        <span class="kt">int</span> <span class="n">repeat</span> <span class="o">=</span> <span class="n">scanner</span><span class="o">.</span><span class="na">nextInt</span><span class="o">();</span>
        <span class="n">scanner</span><span class="o">.</span><span class="na">nextLine</span><span class="o">();</span>

        <span class="nc">ArrayList</span><span class="o">&lt;</span><span class="nc">ArrayList</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;&gt;</span> <span class="n">answer</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;();</span>
        <span class="nc">ArrayList</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">condition</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;();</span>
        <span class="n">condition</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">x</span><span class="o">);</span>
        <span class="n">condition</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">y</span><span class="o">);</span>
        <span class="n">answer</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">condition</span><span class="o">);</span>

        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">repeat</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="kt">int</span> <span class="n">first</span> <span class="o">=</span> <span class="n">scanner</span><span class="o">.</span><span class="na">nextInt</span><span class="o">();</span>
            <span class="kt">int</span> <span class="n">second</span> <span class="o">=</span> <span class="n">scanner</span><span class="o">.</span><span class="na">nextInt</span><span class="o">();</span>
            <span class="nc">ArrayList</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">temp</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;();</span>
            <span class="n">temp</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">first</span><span class="o">);</span>
            <span class="n">temp</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">second</span><span class="o">);</span>

            <span class="n">answer</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">temp</span><span class="o">);</span>

        <span class="o">}</span>
        <span class="k">return</span> <span class="n">answer</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="nc">ArrayList</span><span class="o">&lt;</span><span class="nc">ArrayList</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;&gt;</span> <span class="nf">connectedNodeChecker</span>
            <span class="o">(</span><span class="nc">ArrayList</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">node</span><span class="o">,</span> <span class="nc">ArrayList</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">limit</span><span class="o">,</span> <span class="nc">ArrayList</span><span class="o">&lt;</span><span class="nc">ArrayList</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;&gt;</span> <span class="n">condition</span><span class="o">)</span> <span class="o">{</span>
            
        <span class="c1">// 방향 배열 선언</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">xDirections</span> <span class="o">=</span> <span class="o">{-</span><span class="mi">1</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">};</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">yDirections</span> <span class="o">=</span> <span class="o">{</span><span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="o">-</span><span class="mi">1</span><span class="o">,</span> <span class="mi">1</span><span class="o">};</span>

        <span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="mi">0</span><span class="o">);</span>
        <span class="kt">int</span> <span class="n">y</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="mi">1</span><span class="o">);</span>

        <span class="nc">ArrayList</span><span class="o">&lt;</span><span class="nc">ArrayList</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;&gt;</span> <span class="n">answer</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;();</span>

        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">4</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="kt">int</span> <span class="n">calculatedX</span> <span class="o">=</span> <span class="n">x</span> <span class="o">+</span> <span class="n">xDirections</span><span class="o">[</span><span class="n">i</span><span class="o">];</span>
            <span class="kt">int</span> <span class="n">calculatedY</span> <span class="o">=</span> <span class="n">y</span> <span class="o">+</span> <span class="n">yDirections</span><span class="o">[</span><span class="n">i</span><span class="o">];</span>

            <span class="k">if</span> <span class="o">(</span><span class="n">calculatedX</span> <span class="o">&lt;</span> <span class="mi">1</span> <span class="o">||</span> <span class="n">calculatedX</span> <span class="o">&gt;</span> <span class="n">limit</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="mi">0</span><span class="o">)</span> <span class="o">||</span>
            <span class="n">calculatedY</span> <span class="o">&lt;</span> <span class="mi">1</span> <span class="o">||</span> <span class="n">calculatedY</span> <span class="o">&gt;</span> <span class="n">limit</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="mi">1</span><span class="o">))</span> <span class="o">{</span>
            <span class="o">}</span>
            <span class="k">else</span> <span class="o">{</span>
                <span class="nc">ArrayList</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">temp</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;();</span>
                <span class="n">temp</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">calculatedX</span><span class="o">);</span>
                <span class="n">temp</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">calculatedY</span><span class="o">);</span>
                
                <span class="c1">// 각각 4방향의 연결된 노드 중에서, condition에 포함되어 있는 노드라면 answer에 추가한다.</span>

                <span class="k">if</span> <span class="o">(</span><span class="n">condition</span><span class="o">.</span><span class="na">contains</span><span class="o">(</span><span class="n">temp</span><span class="o">))</span> <span class="o">{</span>
                    <span class="n">answer</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">temp</span><span class="o">);</span>
                <span class="o">}</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">answer</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">dfs</span><span class="o">(</span><span class="nc">ArrayList</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">node</span><span class="o">,</span> <span class="nc">ArrayList</span><span class="o">&lt;</span><span class="nc">ArrayList</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;&gt;</span> <span class="n">nodeList</span><span class="o">,</span>
                           <span class="nc">ArrayList</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">limit</span><span class="o">,</span> <span class="kt">int</span> <span class="n">number</span><span class="o">)</span> <span class="o">{</span>
                           
        <span class="c1">// number는 군집 배열의 인덱스를 나타낸다.</span>
                           
        <span class="n">visitedNodes</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">node</span><span class="o">);</span>
        
        <span class="c1">// connectedNodeChecker를 통해서 연결된 노드를 찾아내고, 그 노드가 방문한 노드가 아니라면 dfs를 시작한다.</span>
        <span class="nc">ArrayList</span><span class="o">&lt;</span><span class="nc">ArrayList</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;&gt;</span> <span class="n">connectedNodes</span> <span class="o">=</span> <span class="n">connectedNodeChecker</span><span class="o">(</span><span class="n">node</span><span class="o">,</span> <span class="n">limit</span><span class="o">,</span> <span class="n">nodeList</span><span class="o">);</span>

        <span class="k">if</span> <span class="o">(</span><span class="n">connectedNodes</span><span class="o">.</span><span class="na">size</span><span class="o">()</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">return</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="k">else</span> <span class="o">{</span>
            <span class="k">for</span> <span class="o">(</span><span class="nc">ArrayList</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">connectedNode</span> <span class="o">:</span> <span class="n">connectedNodes</span><span class="o">)</span> <span class="o">{</span>
                <span class="k">if</span> <span class="o">(!</span><span class="n">visitedNodes</span><span class="o">.</span><span class="na">contains</span><span class="o">(</span><span class="n">connectedNode</span><span class="o">))</span> <span class="o">{</span>
                
                    <span class="no">MAX_AMOUNT</span><span class="o">[</span><span class="n">number</span><span class="o">]</span> <span class="o">+=</span> <span class="mi">1</span><span class="o">;</span>
                    <span class="n">dfs</span><span class="o">(</span><span class="n">connectedNode</span><span class="o">,</span> <span class="n">nodeList</span><span class="o">,</span> <span class="n">limit</span><span class="o">,</span> <span class="n">number</span><span class="o">);</span>
                <span class="o">}</span>
            <span class="o">}</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>

</code></pre></div></div>]]></content><author><name>ash tensor</name></author><category term="백준" /><category term="PS" /><category term="JAVA" /><category term="파이썬" /><summary type="html"><![CDATA[[백준] 백준 1743번 :: 음식물 피하기 :: 실버 1]]></summary></entry><entry><title type="html">[백준] 백준 1987번 :: 알파벳 :: 골드 4</title><link href="http://localhost:4000/%EB%B0%B1%EC%A4%80/ps/java/2024/02/21/boj1987.html" rel="alternate" type="text/html" title="[백준] 백준 1987번 :: 알파벳 :: 골드 4" /><published>2024-02-21T00:00:00+09:00</published><updated>2024-02-21T00:00:00+09:00</updated><id>http://localhost:4000/%EB%B0%B1%EC%A4%80/ps/java/2024/02/21/boj1987</id><content type="html" xml:base="http://localhost:4000/%EB%B0%B1%EC%A4%80/ps/java/2024/02/21/boj1987.html"><![CDATA[<h2 id="백준-백준-1987번--알파벳--골드-4">[백준] 백준 1987번 :: 알파벳 :: 골드 4</h2>

<h3 id="문제-설명">문제 설명</h3>

<p>세로
$R$칸, 가로
$C$칸으로 된 표 모양의 보드가 있다. 보드의 각 칸에는 대문자 알파벳이 하나씩 적혀 있고, 좌측 상단 칸 (
$1$행
$1$열) 에는 말이 놓여 있다.</p>

<p>말은 상하좌우로 인접한 네 칸 중의 한 칸으로 이동할 수 있는데, 새로 이동한 칸에 적혀 있는 알파벳은 지금까지 지나온 모든 칸에 적혀 있는 알파벳과는 달라야 한다. 즉, 같은 알파벳이 적힌 칸을 두 번 지날 수 없다.</p>

<p>좌측 상단에서 시작해서, 말이 최대한 몇 칸을 지날 수 있는지를 구하는 프로그램을 작성하시오. 말이 지나는 칸은 좌측 상단의 칸도 포함된다.</p>

<p><strong>입력</strong></p>

<p>첫째 줄에
$R$과
$C$가 빈칸을 사이에 두고 주어진다. (
$1 ≤ R,C ≤ 20$) 둘째 줄부터
$R$개의 줄에 걸쳐서 보드에 적혀 있는
$C$개의 대문자 알파벳들이 빈칸 없이 주어진다.</p>

<p><strong>출력</strong></p>

<p>첫째 줄에 말이 지날 수 있는 최대의 칸 수를 출력한다.</p>

<h3 id="제한시간">제한시간</h3>

<p>2 초	256 MB</p>

<h3 id="예제-입력">예제 입력</h3>

<p>2 4
CAAB
ADCB</p>

<h3 id="예제-출력">예제 출력</h3>

<p>3</p>

<h4 id="접근방법">접근방법</h4>

<p>처음에는 백트래킹을 위해 지금까지 지나온 경로를 모두 기억하는 무식한 방법으로 접근했다. 하지만 이 방법은 풀이는 성공했지만 메모리 조건을 초과해서 메모리 초과가 발생했다.
(그 와중에도 파이썬으로는 풀이가 성공했지만 자바로는 메모리 초과가 발생했다는 점이 재밌다. 아무래도 파이썬의 메모리 보정이 꽤 크기도 하고, 파이썬으로 문제풀이를 하던 습관 때문에 파이썬의 리스트에 대응되는
자바의 ArrayList를 남발하면서 메모리 초과가 발생했던 것 같다.)</p>

<p>그래서 백트래킹을 위해 지금까지 지나온 경로를 모두 기억하는 것이 아니라 알파벳의 원소별로 방문 여부를 체크하는 방법으로 접근했다. 이 방법은 메모리 초과가 발생하지 않았다.</p>

<p>사실 BFS 또는 DFS로 접근하는데 있어서, 개인적으로는 재귀로 구현하는 DFS는 메모리 초과가 발생할 가능성이 크기 때문에 되도록이면 피하는 방법이지만 이번에는 재귀로 구현한 DFS로 풀이했다.</p>

<p>또한 98%의 테스트케이스에서 멈췄는데, 역시나 이는 입력 : 1 1 / A 일때, 1이 출력되어야 하는데 0이 출력되었기 때문이다. 이는 최소한 한 번은 이동해야 answer에 값이 할당되는데, 그렇지 않아서 발생한 문제였다.
이런 실수를 하지 말아야 한다고 생각하는데, 안타깝다 ㅠㅠ</p>

<p>아, 그리고 어차피 알파벳은 26개이기 떼문에 26이 넘어가면 더 이상 탐색할 필요가 없다.</p>

<h4 id="자바-코드">자바 코드</h4>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="kn">package</span> <span class="nn">boj</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.io.BufferedReader</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.io.IOException</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.io.InputStreamReader</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.ArrayList</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.StringTokenizer</span><span class="o">;</span>


<span class="kd">public</span> <span class="kd">class</span> <span class="nc">newboj1987</span> <span class="o">{</span>
    <span class="c1">// 상하좌우 순서로 방향배열 선언</span>
    <span class="kd">static</span> <span class="kt">int</span> <span class="no">R</span><span class="o">,</span> <span class="no">C</span><span class="o">;</span>
    <span class="kd">static</span> <span class="kt">int</span><span class="o">[][]</span> <span class="n">theMap</span><span class="o">;</span>
    <span class="kd">static</span> <span class="kt">int</span><span class="o">[]</span> <span class="n">x_way</span> <span class="o">=</span> <span class="o">{-</span><span class="mi">1</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">};</span>
    <span class="kd">static</span> <span class="kt">int</span><span class="o">[]</span> <span class="n">y_way</span> <span class="o">=</span> <span class="o">{</span><span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="o">-</span><span class="mi">1</span><span class="o">,</span> <span class="mi">1</span><span class="o">};</span>
    <span class="kd">static</span> <span class="kt">int</span> <span class="n">answer</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
    <span class="kd">static</span> <span class="kt">boolean</span><span class="o">[]</span> <span class="n">visited</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">boolean</span><span class="o">[</span><span class="mi">26</span><span class="o">];</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">dfs</span><span class="o">(</span><span class="kt">int</span> <span class="n">x</span><span class="o">,</span> <span class="kt">int</span> <span class="n">y</span><span class="o">,</span> <span class="kt">int</span> <span class="n">count</span><span class="o">)</span> <span class="o">{</span>
    
    <span class="c1">//answer를 1로 초기화 하거나 문제공간이 1, 1인 경우에는 1로 리턴해도 된다.</span>
        <span class="k">if</span> <span class="o">(</span><span class="no">R</span> <span class="o">==</span> <span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="no">C</span> <span class="o">==</span> <span class="mi">1</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">answer</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span>
            <span class="k">return</span><span class="o">;</span>
        <span class="o">}</span>
        
        <span class="c1">// 26개 이상의 알파벳을 지나면 더 이상 탐색할 필요가 없다.</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">count</span> <span class="o">&gt;=</span> <span class="mi">26</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">answer</span> <span class="o">=</span> <span class="n">count</span><span class="o">;</span>
            <span class="k">return</span><span class="o">;</span>
        <span class="o">}</span>
        
        <span class="c1">// 이미 방문한 알파벳이라면 answer에 count를 할당하고 리턴한다.</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">visited</span><span class="o">[</span><span class="n">theMap</span><span class="o">[</span><span class="n">x</span><span class="o">][</span><span class="n">y</span><span class="o">]])</span> <span class="o">{</span>
            <span class="n">answer</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">answer</span><span class="o">,</span> <span class="n">count</span><span class="o">);</span>
            <span class="k">return</span><span class="o">;</span>
        <span class="o">}</span>
       
        <span class="k">else</span> <span class="o">{</span>
            <span class="n">visited</span><span class="o">[</span><span class="n">theMap</span><span class="o">[</span><span class="n">x</span><span class="o">][</span><span class="n">y</span><span class="o">]]</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
            <span class="nc">ArrayList</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">[]&gt;</span> <span class="n">moveList</span> <span class="o">=</span>  <span class="n">ableMove</span><span class="o">(</span><span class="n">x</span><span class="o">,</span><span class="n">y</span><span class="o">);</span>
            <span class="k">for</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">coordinates</span> <span class="o">:</span> <span class="n">moveList</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">dfs</span><span class="o">(</span><span class="n">coordinates</span><span class="o">[</span><span class="mi">0</span><span class="o">],</span> <span class="n">coordinates</span><span class="o">[</span><span class="mi">1</span><span class="o">],</span> <span class="n">count</span><span class="o">+</span><span class="mi">1</span><span class="o">);</span>
            <span class="o">}</span>
        <span class="o">}</span>

        <span class="n">visited</span><span class="o">[</span><span class="n">theMap</span><span class="o">[</span><span class="n">x</span><span class="o">][</span><span class="n">y</span><span class="o">]]</span> <span class="o">=</span> <span class="kc">false</span><span class="o">;</span>

    <span class="o">}</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">IOException</span> <span class="o">{</span>
        <span class="nc">BufferedReader</span> <span class="n">br</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">BufferedReader</span><span class="o">(</span><span class="k">new</span> <span class="nc">InputStreamReader</span><span class="o">(</span><span class="nc">System</span><span class="o">.</span><span class="na">in</span><span class="o">));</span>
        <span class="nc">StringTokenizer</span> <span class="n">st</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">StringTokenizer</span><span class="o">(</span><span class="n">br</span><span class="o">.</span><span class="na">readLine</span><span class="o">());</span>

        <span class="no">R</span> <span class="o">=</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="n">st</span><span class="o">.</span><span class="na">nextToken</span><span class="o">());</span>
        <span class="no">C</span> <span class="o">=</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="n">st</span><span class="o">.</span><span class="na">nextToken</span><span class="o">());</span>
        <span class="n">theMap</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="no">R</span><span class="o">][</span><span class="no">C</span><span class="o">];</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="no">R</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="nc">String</span> <span class="n">str</span> <span class="o">=</span> <span class="n">br</span><span class="o">.</span><span class="na">readLine</span><span class="o">();</span>
            <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="no">C</span><span class="o">;</span> <span class="n">j</span><span class="o">++)</span> <span class="o">{</span>
                <span class="n">theMap</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">]</span> <span class="o">=</span> <span class="n">str</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">j</span><span class="o">)</span> <span class="o">-</span> <span class="sc">'A'</span><span class="o">;</span>
            <span class="o">}</span>
        <span class="o">}</span>

        <span class="n">dfs</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">);</span>

        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">answer</span><span class="o">);</span>

    <span class="o">}</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="nc">ArrayList</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">[]&gt;</span> <span class="nf">ableMove</span><span class="o">(</span><span class="kt">int</span> <span class="n">x</span><span class="o">,</span> <span class="kt">int</span> <span class="n">y</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">ArrayList</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">[]&gt;</span> <span class="n">coordinates</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;();</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">4</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="kt">int</span> <span class="n">x_position</span> <span class="o">=</span> <span class="n">x</span> <span class="o">+</span> <span class="n">x_way</span><span class="o">[</span><span class="n">i</span><span class="o">];</span>
            <span class="kt">int</span> <span class="n">y_position</span> <span class="o">=</span> <span class="n">y</span> <span class="o">+</span> <span class="n">y_way</span><span class="o">[</span><span class="n">i</span><span class="o">];</span>
            
            <span class="c1">// 배열을 벗어나지 않는지 체크</span>

            <span class="k">if</span><span class="o">(</span><span class="n">x_position</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">x_position</span> <span class="o">&gt;</span> <span class="n">theMap</span><span class="o">.</span><span class="na">length</span><span class="o">-</span><span class="mi">1</span> <span class="o">||</span> <span class="n">y_position</span> <span class="o">&lt;</span> <span class="mi">0</span> 
                <span class="o">||</span> <span class="n">y_position</span> <span class="o">&gt;</span> <span class="n">theMap</span><span class="o">[</span><span class="mi">0</span><span class="o">].</span><span class="na">length</span><span class="o">-</span><span class="mi">1</span> <span class="o">){</span>
            <span class="o">}</span>
            <span class="k">else</span> <span class="o">{</span>
                <span class="kt">int</span><span class="o">[]</span> <span class="n">temp</span> <span class="o">=</span> <span class="o">{</span><span class="n">x_position</span><span class="o">,</span> <span class="n">y_position</span><span class="o">};</span>
                <span class="n">coordinates</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">temp</span><span class="o">);</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">coordinates</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>

</code></pre></div></div>]]></content><author><name>ash tensor</name></author><category term="백준" /><category term="PS" /><category term="JAVA" /><summary type="html"><![CDATA[[백준] 백준 1987번 :: 알파벳 :: 골드 4]]></summary></entry><entry><title type="html">[WEB]GCP(google cloud platform) 프리 티어 VM 생성 / MYSQL 서버 연결</title><link href="http://localhost:4000/web/2024/02/17/gcp-free-tier-settings.html" rel="alternate" type="text/html" title="[WEB]GCP(google cloud platform) 프리 티어 VM 생성 / MYSQL 서버 연결" /><published>2024-02-17T00:00:00+09:00</published><updated>2024-02-17T00:00:00+09:00</updated><id>http://localhost:4000/web/2024/02/17/gcp-free-tier-settings</id><content type="html" xml:base="http://localhost:4000/web/2024/02/17/gcp-free-tier-settings.html"><![CDATA[<h2 id="webgcpgoogle-cloud-platform-프리-티어-vm-생성">[WEB]GCP(google cloud platform) 프리 티어 VM 생성</h2>

<p>클라우드 서비스로 가장 우선적으로 선택하는 것 중에 하나가 바로 AWS일 것이다. 하지만 AWS 같은 경우에는 프리티어 VM의 사용 기한이 1년으로, 
1년이 지나면 자동으로 등록해 놓은 신용카드로 사용 요금이 빠져나간다. 그래서 나 같은 경우에는 프리티어로 사용하던 VM의 사용 기한이 끝나 매달 2만원 가량의 요금이
 지불되고 있는데… 솔직히 돈이 너무 아까웠다. 그래서 이에 대한 대책으로 다른 클라우드 서비스 프리 티어를 살펴보고 최종적으로 GCP에 MYSQL 서버를 설치하고 접속되게 변경했다.</p>

<h3 id="오라클은-가입이-안됨">오라클은 가입이 안됨…</h3>

<p>사실 이런 프리티어 클라우드 서비스 중에 가장 성능이 좋은 서비스는 오라클이다. 그런데 이 오라클 클라우드의 가장 큰 단점은 회원가입이 어럽다는 점이다…
농담이 아니라 실제 많은 사람들이 호소하는 불편함으로, 이 마지막 화면에서 “트랜잭션 오류가 발생하였습니다.” 라는 오류를 뱉으며 회원가입이 안 되는 오류가 있다.</p>

<p><img src="/img/posts/gcp/oraclefail.png" style="width: 80%" /></p>

<p>바로 이 화면이다. 해결 방법으로는 오라클 고객센터 라이브 챗으로 풀어달라고 하면 해결된다고는 하는데, 나 같은 경우에는 응답이 없어서, 그냥 GCP로 바꾸기로 했다.</p>

<h3 id="gcp">GCP</h3>

<p>GCP와 오라클이 프리티어에서 가장 큰 강점을 가지는 것은 바로 영구 무료 유지라는 점이다. AWS는 물론이고 MS 애저도 1년이 지나면 얄짤없이 유료화 시키는데 비해서
프리 티어 성능 안에서는 1년이 지나건 몇년이 지나건 무료로 서비스를 사용할 수 있다는 점이 큰 매력이다.</p>

<p><img src="/img/posts/gcp/gcp1.png" style="width: 80%" /></p>

<p>이 사진에서 알수있듯, 오리건, 아이오와, 사우스캐롤라이나의 VM이라면 30GB 용량까지 평생 무료로 사용할 수 있다. 하지만 스펙이 저열한데, 프리티어의 e2-micro
성능은 vcpu 1개와 0.5GB 메모리, 그리고 1GB 트래픽만 허용된다.</p>

<p>vcpu 1개의 경우에는 대략 0.2Ghz 정도의 성능을 가지는데, 아무리 무료라고는 하지만 좋은 성능은 아니다. 0.2Ghz다. 0.2Ghz!! 아마 피쳐폰보다 성능이 안좋을지도 모른다.
게다가 램도 겨우 500메가 정도로, 정말 20달러짜리 라즈베리파이보다 성능이 안좋을 것이다. 라즈베리파이는 단 돈 5만원에 2Ghz CPU 8개가 달려있는데…</p>

<p>아무튼 프리티어는 프리티어인 이유가 있다. 간단한 실증 정도의 테스트만 가능한 환경이니 너무 큰 프로젝트는 올리지 않는 편이 좋다.</p>

<h4 id="vm생성">VM생성</h4>

<p><a href="https://cloud.google.com/free/?utm_source=google&amp;utm_medium=cpc&amp;utm_campaign=japac-KR-all-en-dr-BKWS-all-core-trial-EXA-dr-1605216&amp;utm_content=text-ad-none-none-DEV_c-CRE_644033776725-ADGP_Hybrid+%7C+BKWS+-+EXA+%7C+Txt+~+GCP_General_core+brand_main-KWID_43700074755444107-kwd-87853815&amp;userloc_1009871-network_g&amp;utm_term=KW_gcp&amp;gad_source=1&amp;gclid=CjwKCAiArLyuBhA7EiwA-qo80PzDfq52iWQuvaP7LEccHJPst6zFmWL2s0Fu31ddUOkLIflDbWUbBxoCogEQAvD_BwE&amp;gclsrc=aw.ds&amp;hl=ko">이 페이지(GCP)</a>에서 회원가입을 한 후에,</p>

<p><img src="/img/posts/gcp/gcp2.png" style="width: 80%" /></p>

<p>“사용” 버튼을 누른후 인스턴스 만들기를 선택하면 된다. 그리고 난 뒤에</p>

<p><img src="/img/posts/gcp/gcp3.png" style="width: 80%" /></p>

<p>아까 언급했던 것처럼, 오리건, 아이오와, 사우스캐롤라이나와 같이 프리티어를 제공하는 리전을 선택한 뒤에(아마도 서부가 아주 조금이라도 더 빠를 것이다) 머신 구성에서는
 E2를 선택하고</p>

<p><img src="/img/posts/gcp/gcp6.png" style="width: 80%" /></p>

<p>엑세스 범위: 모든 클라우드 API에 대해 전체 액세스 허용, HTTP, HTTPS 트래픽 허용을 선택해 준다.</p>

<p><img src="/img/posts/gcp/gcp4.png" style="width: 80%" /></p>

<p>머신 유형에서는 프리티어를 제공해주는 e2-micro를 선택하자. 이후 부팅 디스크에서 새로운 SSD 영구 디스크, 크기는 30GB내에서 원하는 만큼 
선택하면 된다.</p>

<p><img src="/img/posts/gcp/gcp5.png" style="width: 80%" /></p>

<p>이후 인스턴스를 생성한 뒤 SSH로 접속을 선택하면 흔히 사용했던 bash가 새로운 브라우저 창으로 등장할 것이다.</p>

<h3 id="mysql-설치-및-설정">MYSQL 설치 및 설정</h3>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>apt-get install mariadb-server mariadb-client
/usr/bin/mysql_secure_installation (db초기화 작업)
</code></pre></div></div>

<p>나는 우분투 환경이기 때문에 apt-get install mariadb-server mariadb-client로 mysql을 설치했다. 그리고 이 이후에 방화벽을 설정해야한다.</p>

<p>VCP 네트워크의 방화벽 - 방화벽 규칙 만들기를 통해서 새로운 방화벽 규칙을 만들어야 한다 (프로젝트 창 옆에 있는 검색창에 방화벽이라고 검색해도 찾을 수 있다.)</p>

<p><img src="/img/posts/gcp/mysql1.png" style="width: 80%" /></p>

<p>8080포트, tcp/ip 프로토콜에 대해서 0.0.0.0/0 (모든 ip 입력에 대해서 허용, 자신의 IP범위를 적어 넣는편이 당연히 보안에 무조건 좋다)</p>

<p><img src="/img/posts/gcp/mysql2.png" style="width: 80%" /></p>

<p>3306포트에 대해서 (mysql) 접근 허용 방화벽 규칙을 설정해 준다. 이 이후에, 로컬에서만 접속할 수 있도록 바인딩 해 놓은 mysql 설정 파일도 수정해야한다.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>nano /etc/mysql/mariadb.conf.d/50-server.cnf 
</code></pre></div></div>

<p>룰 한 뒤에, bind-address= 127.0.0.1 을 지우던지, 주석처리 해야 한다.</p>

<p><img src="/img/posts/gcp/mysql3.png" style="width: 80%" /></p>

<p>이러면 mysql 서버를 사용할 기본적인 설정은 모두 끝났다!</p>]]></content><author><name>ash tensor</name></author><category term="WEB" /><summary type="html"><![CDATA[[WEB]GCP(google cloud platform) 프리 티어 VM 생성]]></summary></entry><entry><title type="html">[깃허브 블로그]지킬 블로그 카테고리 / SIDEBAR 기능 추가(clean blog theme)</title><link href="http://localhost:4000/%EA%B9%83%ED%97%88%EB%B8%8C/2024/02/08/jekyll-blog-theme-5-sidebar.html" rel="alternate" type="text/html" title="[깃허브 블로그]지킬 블로그 카테고리 / SIDEBAR 기능 추가(clean blog theme)" /><published>2024-02-08T00:00:00+09:00</published><updated>2024-02-08T00:00:00+09:00</updated><id>http://localhost:4000/%EA%B9%83%ED%97%88%EB%B8%8C/2024/02/08/jekyll-blog-theme-5-sidebar</id><content type="html" xml:base="http://localhost:4000/%EA%B9%83%ED%97%88%EB%B8%8C/2024/02/08/jekyll-blog-theme-5-sidebar.html"><![CDATA[<h2 id="깃허브-블로그-sidebar-기능-추가clean-blog-theme">깃허브 블로그 SIDEBAR 기능 추가(clean blog theme)</h2>

<p>블로그에 사이드바 기능을 추가할 지 말지 고민했는데, 그래도 기능은 많으면 많을수록 좋다고 느껴서 사이드바 기능을 추가했다. 
최근 HTML과 CSS를 공부하는 중이라서 공부하는 겸 sidebar 기능을 개발해 보기로 했다. 리퀴드를 이용해서 구현했고, 추가적으로 카테고리별로 축소시켰다, 늘렸다 하는 기능을 추가할까도 생각중이다.
CLEAN BLOG THEME은 자체적으로 사이드바를 지원하는 테마는 아니기 때문에 여타 다른 테마의 수려한 기능과는 거리가 멀긴 하지만 일단 작동은 하게 만들었으니, 이정도로 마무리 지을까 한다.</p>

<h3 id="카테고리-레이아웃">카테고리 레이아웃</h3>

<p>이를 구현하기 위해서는 사이드바와 컨텐츠를 수평으로 담기 위해서 최상의 컨테이너의 display 속성을 flex로 변경해야 한다. _layouts의 post.markdown 파일이다.</p>

<p><img src="/img/posts/sidebar/sidebar-1.png" style="width: 80%" /></p>

<p>그리고 너무 작은 화면에서는 사이드바가 나오지 않게 하기 위해(너무 작은 화면에서는 사이드바가 있어봐야 소용이 없기 때문에 / 그리고 화면이 너무 지저분해지기도 하고) general 스타일 시트를 변경하려고 했는데, general.scss 파일은 물론이고 asset의 main css, post.scss 파일을 아무리 수정해도 스타일이 먹지를 않아서 어쩔 수 없이 header에 직접 스타일을 때려넣어야만 했다.</p>

<p><img src="/img/posts/sidebar/sidebar-2.png" style="width: 80%" /></p>

<p>이런식으로, 기본적으로 사이드바의 display 설정은 none으로 하고, 일정 크기 이상으로 화면이 커져야만 display 되도록 하는 방식이다. 솔직히 아직도 너무 지저분한 방식이라고 생각은 하지만, 왜 적용이 안되는지 방법을 모르겠어서 어쩔 수 없었다… 아무튼, 이 이후에 .post문서의 세번째 컨테이너에 이 코드를 추가하면 된다. 첫번쨰 사진을 확인하면 어떻게 추가하는지 이해가 쉬울 것이다.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&lt;!-- sidebar를 추가하는 코드 --&gt;
&lt;sidebar id="sidebar" 
            style="width: 260px; 
            border-right: gray 1px solid; 
            padding-left: 0; 
            padding-right: 20px;"
            &gt;
    &lt;ul&gt;
        &lt;p style="font-weight: bold; border-top: black 1px solid; 
            border-bottom: black 1px solid; text-align: center; margin-top: 2px; 
            padding: 2px; padding-top: 4px"&gt;
            TENSOR STUDIO
        &lt;/p&gt;
        {% for category in site.categories %}
            &lt;p style="margin-bottom: 0; margin-top: 10px"&gt;
            &lt;a style= "margin-bottom: 0px; font-size: 15px; color: black; 
                font-weight: bold; font-family: 'Noto Sans KR', sans-serif;" 
                href= "{{ site.url }}/category/{{ category[0] }}.html"&gt;
                {{ category[0] }}
            &lt;/a&gt;
            &lt;a&gt; 🔽
            &lt;/a&gt;
        &lt;/p&gt;
        {% assign posts = category[1] | sort: 'date' | reverse | limit: 5 %}
        {% assign counter = 0 %}
        {% for post in posts %}
        {% if counter &lt; 3 %}
        &lt;li style="margin: 0px"&gt;
            &lt;a href="{{ site.baseurl }}{{ post.url }}" style= "color: black; 
                font-size: 12px; font-family: 'Noto Sans KR';"&gt;
                {{ post.title }}
            &lt;/a&gt;
            &lt;small style= "margin-bottom: 0px; font-size: 10px;"&gt;{{ post.date | date_to_string }}&lt;/small&gt;
        &lt;/li&gt;
            {% assign counter = counter | plus: 1 %}
            {% endif %}
            {% endfor %}
        {% endfor %}
    &lt;/ul&gt;
&lt;/sidebar&gt;
</code></pre></div></div>

<h3 id="완성된-모습">완성된 모습</h3>

<p><img src="/img/posts/sidebar/sidebar-3.png" style="width: 80%" /></p>

<p>현재는 최근 세 개의 포스트만 나오게 되어 있는데, 이는 내부 코드의 카운터 부분을 바꾸면 된다. 추가적으로 레이아웃에서 건드릴 것이 많기는 하지만(display 속성을 이용해서 완성도를 높일 수 있을 것 같다) 아무튼 여기서 마무리 지을 것이다!</p>]]></content><author><name>ash tensor</name></author><category term="깃허브" /><summary type="html"><![CDATA[깃허브 블로그 SIDEBAR 기능 추가(clean blog theme)]]></summary></entry><entry><title type="html">[리눅스] 애플 실리콘 맥에 리눅스 설치하는 법(UTM)</title><link href="http://localhost:4000/linux/2024/02/01/utm.html" rel="alternate" type="text/html" title="[리눅스] 애플 실리콘 맥에 리눅스 설치하는 법(UTM)" /><published>2024-02-01T00:00:00+09:00</published><updated>2024-02-01T00:00:00+09:00</updated><id>http://localhost:4000/linux/2024/02/01/utm</id><content type="html" xml:base="http://localhost:4000/linux/2024/02/01/utm.html"><![CDATA[<h2 id="리눅스-애플-실리콘-맥에-리눅스-설치-후기utm">[리눅스] 애플 실리콘 맥에 리눅스 설치 후기(UTM)</h2>

<h3 id="utm">UTM</h3>

<p><a href="https://mac.getutm.app/">UTM</a>은 이 링크에서 얻을 수 있다. 일단 <a href="https://gymdev.tistory.com/75">이 페이지</a>에서 너무 설치법을 잘 정리해 주고 있어서 내가 따로 첨언할 부분은 없었다. 아, 설치 중 중간에 <strong>display out을 확인할 수 없다</strong> 고 한동안 표시돼서 설치가 안되는건가 했는데, 조금 기다리면 문제 없이 리눅스가 부팅되니까 조금 기다리면 된다!</p>

<p><img src="/img/스크린샷 2024-02-01 오후 1.27.20.png" style="width: 80%" /></p>

<p>m1맥에서 제대로 구동되는 것을 확인했다.</p>]]></content><author><name>ash tensor</name></author><category term="linux" /><summary type="html"><![CDATA[[리눅스] 애플 실리콘 맥에 리눅스 설치 후기(UTM)]]></summary></entry><entry><title type="html">[백준] 백준 1931번 :: 회의실 배정 :: 실버 1</title><link href="http://localhost:4000/%EB%B0%B1%EC%A4%80/ps/%ED%8C%8C%EC%9D%B4%EC%8D%AC/java/2024/02/01/boj1931.html" rel="alternate" type="text/html" title="[백준] 백준 1931번 :: 회의실 배정 :: 실버 1" /><published>2024-02-01T00:00:00+09:00</published><updated>2024-02-01T00:00:00+09:00</updated><id>http://localhost:4000/%EB%B0%B1%EC%A4%80/ps/%ED%8C%8C%EC%9D%B4%EC%8D%AC/java/2024/02/01/boj1931</id><content type="html" xml:base="http://localhost:4000/%EB%B0%B1%EC%A4%80/ps/%ED%8C%8C%EC%9D%B4%EC%8D%AC/java/2024/02/01/boj1931.html"><![CDATA[<h2 id="백준-백준-1931번--회의실-배정--실버-1">[백준] 백준 1931번 :: 회의실 배정 :: 실버 1</h2>

<h3 id="문제-설명">문제 설명</h3>

<p>한 개의 회의실이 있는데 이를 사용하고자 하는 N개의 회의에 대하여 회의실 사용표를 만들려고 한다. 각 회의 I에 대해 시작시간과 끝나는 시간이 주어져 있고, 각 회의가 겹치지 않게 하면서 회의실을 사용할 수 있는 회의의 최대 개수를 찾아보자. 단, 회의는 한번 시작하면 중간에 중단될 수 없으며 한 회의가 끝나는 것과 동시에 다음 회의가 시작될 수 있다. 회의의 시작시간과 끝나는 시간이 같을 수도 있다. 이 경우에는 시작하자마자 끝나는 것으로 생각하면 된다.</p>

<p><strong>입력</strong></p>

<p>첫째 줄에 회의의 수 N(1 ≤ N ≤ 100,000)이 주어진다. 둘째 줄부터 N+1 줄까지 각 회의의 정보가 주어지는데 이것은 공백을 사이에 두고 회의의 시작시간과 끝나는 시간이 주어진다. 시작 시간과 끝나는 시간은 231-1보다 작거나 같은 자연수 또는 0이다.</p>

<p><strong>출력</strong></p>

<p>첫째 줄에 최대 사용할 수 있는 회의의 최대 개수를 출력한다.</p>

<h3 id="제한시간">제한시간</h3>

<p>2 초	128 MB</p>

<h3 id="예제-입력">예제 입력</h3>

<p>11</p>

<p>1 4</p>

<p>3 5</p>

<p>0 6</p>

<p>5 7</p>

<p>3 8</p>

<p>5 9</p>

<p>6 10</p>

<p>8 11</p>

<p>8 12</p>

<p>2 13</p>

<p>12 14</p>

<h3 id="예제-출력">예제 출력</h3>

<p>4</p>

<h4 id="접근방법">접근방법</h4>

<p>나는 이거 좀 어려웠다. 개인적으로 흔한 골드 문제보다도 어려웠던 것 같은데, 왜냐하면 그리디로 풀어야 하나? 하고 돌려봤더니 답이 안나와서 DP로 도전하다 다시 그리디로 돌아왔기 때문이다.</p>

<p>처음에는 회의 시작 시간 기준으로 그리디를 적용했으나, 정답이 나오지 않았다. 그리디의 특성상 최소단위로 나눈 작업의 결과가 항상 최적이라는 보장이 없기 때문에 그렇다. 이런 경우에는 작업을 나누는 기준이 잘못되었거나/그리디로 해결할 수 있는 문제가 아닌 경우가 많다. 아니면 기준/정렬이 잘못되었거나.</p>

<p>이 문제의 경우에는 회의가 끝나는 시간을 기준으로 정렬해서 그리디를 적용해야 풀이가 가능했다. 다음은 시작시간, 끝시간을 입력으로 받아서 튜플을 (끝시간, 시작시간)으로 저장한 예시 코드이다.</p>

<h4 id="파이썬-코드">파이썬 코드</h4>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="n">conference_number</span> <span class="o">=</span> <span class="nf">int</span><span class="p">(</span><span class="nf">input</span><span class="p">())</span>
<span class="n">conference_list</span> <span class="o">=</span> <span class="p">[]</span>
<span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="n">conference_number</span><span class="p">)</span> <span class="p">:</span>
    <span class="n">first</span><span class="p">,</span> <span class="n">second</span> <span class="o">=</span> <span class="nf">map</span><span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nf">input</span><span class="p">().</span><span class="nf">split</span><span class="p">())</span>
    <span class="n">conference_list</span><span class="p">.</span><span class="nf">append</span><span class="p">((</span><span class="n">second</span><span class="p">,</span> <span class="n">first</span><span class="p">))</span>

<span class="n">conference_list</span><span class="p">.</span><span class="nf">sort</span><span class="p">()</span>
<span class="n">n</span> <span class="o">=</span> <span class="mi">0</span>
<span class="n">answer</span> <span class="o">=</span> <span class="mi">0</span>

<span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">conference_list</span> <span class="p">:</span>
    <span class="k">if</span> <span class="n">n</span> <span class="o">&lt;=</span> <span class="n">c</span> <span class="p">:</span>
        <span class="n">answer</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="n">n</span> <span class="o">=</span> <span class="n">i</span>

<span class="nf">print</span><span class="p">(</span><span class="n">answer</span><span class="p">)</span>

</code></pre></div></div>

<h4 id="자바-코드시작시간-끝시간-정렬">자바 코드(시작시간, 끝시간) 정렬</h4>

<p>다음은 위 코드를 자바 코드로, 정렬을 (끝시간, 시작시간) 으로 해 풀이한 것이 아니라 (시작시간, 끝시간)을 기준으로 정렬해 풀이한 코드이다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="kn">package</span> <span class="nn">boj</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.lang.reflect.Array</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.ArrayList</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.Collections</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.Comparator</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.Scanner</span><span class="o">;</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">boj1931</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">Scanner</span> <span class="n">scanner</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Scanner</span><span class="o">(</span><span class="nc">System</span><span class="o">.</span><span class="na">in</span><span class="o">);</span>
        <span class="kt">int</span> <span class="n">conferenceNumber</span> <span class="o">=</span> <span class="n">scanner</span><span class="o">.</span><span class="na">nextInt</span><span class="o">();</span>

        <span class="nc">ArrayList</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">[]&gt;</span> <span class="n">conferenceList</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;();</span>

        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">conferenceNumber</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="kt">int</span><span class="o">[]</span> <span class="n">temp</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="mi">2</span><span class="o">];</span>
            <span class="kt">int</span> <span class="n">start</span> <span class="o">=</span> <span class="n">scanner</span><span class="o">.</span><span class="na">nextInt</span><span class="o">();</span>
            <span class="kt">int</span> <span class="n">end</span> <span class="o">=</span> <span class="n">scanner</span><span class="o">.</span><span class="na">nextInt</span><span class="o">();</span>
            <span class="n">temp</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span> <span class="o">=</span> <span class="n">start</span><span class="o">;</span>
            <span class="n">temp</span><span class="o">[</span><span class="mi">1</span><span class="o">]</span> <span class="o">=</span> <span class="n">end</span><span class="o">;</span>
            <span class="n">conferenceList</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">temp</span><span class="o">);</span>
        <span class="o">}</span>

        <span class="nc">Collections</span><span class="o">.</span><span class="na">sort</span><span class="o">(</span><span class="n">conferenceList</span><span class="o">,</span> <span class="k">new</span> <span class="nc">Comparator</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">[]&gt;()</span> <span class="o">{</span>
            <span class="nd">@Override</span>
            <span class="kd">public</span> <span class="kt">int</span> <span class="nf">compare</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">o1</span><span class="o">,</span> <span class="kt">int</span><span class="o">[]</span> <span class="n">o2</span><span class="o">)</span> <span class="o">{</span>
                <span class="k">if</span><span class="o">(</span><span class="n">o1</span><span class="o">[</span><span class="mi">1</span><span class="o">]</span> <span class="o">==</span> <span class="n">o2</span><span class="o">[</span><span class="mi">1</span><span class="o">])</span> <span class="o">{</span>
                    <span class="k">return</span> <span class="n">o1</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span> <span class="o">-</span> <span class="n">o2</span><span class="o">[</span><span class="mi">0</span><span class="o">];</span>
                <span class="o">}</span><span class="k">else</span> <span class="o">{</span>
                    <span class="k">return</span> <span class="n">o1</span><span class="o">[</span><span class="mi">1</span><span class="o">]</span> <span class="o">-</span> <span class="n">o2</span><span class="o">[</span><span class="mi">1</span><span class="o">];</span>
                <span class="o">}</span>
            <span class="o">}</span>
        <span class="o">}</span> <span class="o">);</span>
        <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">answer</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>

        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">conferenceList</span><span class="o">.</span><span class="na">size</span><span class="o">();</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">n</span> <span class="o">&lt;=</span> <span class="n">conferenceList</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">i</span><span class="o">)[</span><span class="mi">0</span><span class="o">])</span> <span class="o">{</span>
                <span class="n">answer</span> <span class="o">+=</span> <span class="mi">1</span><span class="o">;</span>
                <span class="n">n</span> <span class="o">=</span> <span class="n">conferenceList</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">i</span><span class="o">)[</span><span class="mi">1</span><span class="o">];</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">answer</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>


</code></pre></div></div>]]></content><author><name>ash tensor</name></author><category term="백준" /><category term="PS" /><category term="파이썬" /><category term="JAVA" /><summary type="html"><![CDATA[[백준] 백준 1931번 :: 회의실 배정 :: 실버 1]]></summary></entry><entry><title type="html">[백준][자료구조] 백준 2178번 :: 미로 탐색 :: 실버 1</title><link href="http://localhost:4000/%EB%B0%B1%EC%A4%80/ps/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0/%ED%8C%8C%EC%9D%B4%EC%8D%AC/java/2024/01/30/boj2178.html" rel="alternate" type="text/html" title="[백준][자료구조] 백준 2178번 :: 미로 탐색 :: 실버 1" /><published>2024-01-30T00:00:00+09:00</published><updated>2024-01-30T00:00:00+09:00</updated><id>http://localhost:4000/%EB%B0%B1%EC%A4%80/ps/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0/%ED%8C%8C%EC%9D%B4%EC%8D%AC/java/2024/01/30/boj2178</id><content type="html" xml:base="http://localhost:4000/%EB%B0%B1%EC%A4%80/ps/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0/%ED%8C%8C%EC%9D%B4%EC%8D%AC/java/2024/01/30/boj2178.html"><![CDATA[<h2 id="백준자료구조-백준-2178번--미로-탐색--실버-1">[백준][자료구조] 백준 2178번 :: 미로 탐색 :: 실버 1</h2>

<h3 id="문제-설명">문제 설명</h3>

<p>N * M 크기의 배열로 표현되는 미로가 있다. 미로에서 1은 이동할 수 있는 칸을 나타내고, 0은 이동할 수 없는 칸을 나타낸다. 이러한 미로가 주어졌을 때, (1, 1)에서 출발하여 (N, M)의 위치로 이동할 때 지나야 하는 최소의 칸 수를 구하는 프로그램을 작성하시오. 한 칸에서 다른 칸으로 이동할 때, 서로 인접한 칸으로만 이동할 수 있다.</p>

<p>위의 예에서는 15칸을 지나야 (N, M)의 위치로 이동할 수 있다. 칸을 셀 때에는 시작 위치와 도착 위치도 포함한다.</p>

<p><strong>입력</strong></p>

<p>첫째 줄에 두 정수 N, M(2 ≤ N, M ≤ 100)이 주어진다. 다음 N개의 줄에는 M개의 정수로 미로가 주어진다. 각각의 수들은 붙어서 입력으로 주어진다.</p>

<p><strong>출력</strong></p>

<p>첫째 줄에 지나야 하는 최소의 칸 수를 출력한다. 항상 도착위치로 이동할 수 있는 경우만 입력으로 주어진다.</p>

<h3 id="제한시간">제한시간</h3>

<p>1 초	192 MB</p>

<h3 id="예제-입력">예제 입력</h3>

<p>4 6
101111
101010
101011
111011</p>

<h3 id="예제-출력">예제 출력</h3>

<p>15</p>

<h4 id="접근방법">접근방법</h4>

<p>흔한 4방향 미로찾기 문제이다. 이런 문제는 너무 템플릿화 되어서, 푸는 방법이 정형화되어 있다.</p>
<ol>
  <li>첫번째로 이런 격자형 문제는 방향 배열을 사용해서 문제에 접근한다. 위, 아래, 좌, 우를 각각 dx, dy라는 방향 배열을 정의하는 것이다. 만약 방향 배열을 정의하지 않으면 코드가 너무 복잡해진다.</li>
  <li>또한 <strong>최단거리</strong>를 구하는 문제이기 때문에 BFS로 접근하는 편이 좋다.</li>
</ol>

<h5 id="방향배열">방향배열</h5>

<p>방향 배열을 사용하지 않은 예시를 보자. 이는 다음과 같다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="k">def</span> <span class="nf">connected_node_checker</span><span class="p">(</span><span class="n">the_map</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span> <span class="p">:</span>
    <span class="c1">## 가장 첫번쨰 열일때.
</span>    <span class="k">if</span> <span class="n">x</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">:</span>
        <span class="k">if</span> <span class="n">y</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">:</span>
            <span class="n">connected_node</span> <span class="o">=</span> <span class="p">[[</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="o">+</span><span class="mi">1</span><span class="p">],[</span><span class="n">x</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">y</span><span class="p">]]</span>
            <span class="n">valued_connected_node</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">connected_node</span> <span class="p">:</span>
                <span class="k">if</span> <span class="n">the_map</span><span class="p">[</span><span class="n">i</span><span class="p">[</span><span class="mi">0</span><span class="p">]][</span><span class="n">i</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span> <span class="o">==</span> <span class="mi">1</span> <span class="p">:</span>
                    <span class="n">valued_connected_node</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
                <span class="k">else</span> <span class="p">:</span>
                    <span class="k">pass</span>
            <span class="k">return</span> <span class="n">valued_connected_node</span>

        <span class="k">elif</span> <span class="n">y</span> <span class="o">==</span> <span class="nf">len</span><span class="p">(</span><span class="n">the_map</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">-</span><span class="mi">1</span> <span class="p">:</span>
            <span class="n">connected_node</span> <span class="o">=</span> <span class="p">[[</span><span class="n">x</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">y</span><span class="p">],[</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="o">-</span><span class="mi">1</span><span class="p">]]</span>
            <span class="n">valued_connected_node</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">connected_node</span> <span class="p">:</span>
                <span class="k">if</span> <span class="n">the_map</span><span class="p">[</span><span class="n">i</span><span class="p">[</span><span class="mi">0</span><span class="p">]][</span><span class="n">i</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span> <span class="o">==</span> <span class="mi">1</span> <span class="p">:</span>
                    <span class="n">valued_connected_node</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
                <span class="k">else</span> <span class="p">:</span>
                    <span class="k">pass</span>
            <span class="k">return</span> <span class="n">valued_connected_node</span>

        <span class="k">else</span> <span class="p">:</span>
            <span class="n">connected_node</span> <span class="o">=</span> <span class="p">[[</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="o">-</span><span class="mi">1</span><span class="p">],[</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="o">+</span><span class="mi">1</span><span class="p">],[</span><span class="n">x</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">y</span><span class="p">]]</span>
            <span class="n">valued_connected_node</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">connected_node</span> <span class="p">:</span>
                <span class="k">if</span> <span class="n">the_map</span><span class="p">[</span><span class="n">i</span><span class="p">[</span><span class="mi">0</span><span class="p">]][</span><span class="n">i</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="n">valued_connected_node</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
                <span class="k">else</span> <span class="p">:</span>
                    <span class="k">pass</span>
            <span class="k">return</span> <span class="n">valued_connected_node</span>

    <span class="k">elif</span> <span class="n">x</span> <span class="o">==</span> <span class="nf">len</span><span class="p">(</span><span class="n">the_map</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span> <span class="p">:</span>
        <span class="k">if</span> <span class="n">y</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">:</span>
            <span class="n">valued_connected_node</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">connected_node</span> <span class="o">=</span> <span class="p">[[</span><span class="n">x</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">y</span><span class="p">],[</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="o">+</span><span class="mi">1</span><span class="p">]]</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">connected_node</span> <span class="p">:</span>
                <span class="k">if</span> <span class="n">the_map</span><span class="p">[</span><span class="n">i</span><span class="p">[</span><span class="mi">0</span><span class="p">]][</span><span class="n">i</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span> <span class="o">==</span> <span class="mi">1</span> <span class="p">:</span>
                    <span class="n">valued_connected_node</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
                <span class="k">else</span> <span class="p">:</span>
                    <span class="k">pass</span>
            <span class="k">return</span> <span class="n">valued_connected_node</span>

        <span class="k">elif</span> <span class="n">y</span> <span class="o">==</span> <span class="nf">len</span><span class="p">(</span><span class="n">the_map</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">-</span> <span class="mi">1</span> <span class="p">:</span>
            <span class="n">valued_connected_node</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">connected_node</span> <span class="o">=</span> <span class="p">[[</span><span class="n">x</span><span class="o">-</span><span class="mi">1</span> <span class="p">,</span><span class="n">y</span><span class="p">],</span> <span class="p">[</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="o">-</span><span class="mi">1</span><span class="p">]]</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">connected_node</span> <span class="p">:</span>
                <span class="k">if</span> <span class="n">the_map</span><span class="p">[</span><span class="n">i</span><span class="p">[</span><span class="mi">0</span><span class="p">]][</span><span class="n">i</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span> <span class="o">==</span> <span class="mi">1</span> <span class="p">:</span>
                    <span class="n">valued_connected_node</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
                <span class="k">else</span> <span class="p">:</span>
                    <span class="k">pass</span>
            <span class="k">return</span> <span class="n">valued_connected_node</span>

        <span class="k">else</span> <span class="p">:</span>
            <span class="n">valued_connected_node</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">connected_node</span> <span class="o">=</span> <span class="p">[[</span><span class="n">x</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">y</span><span class="p">],</span> <span class="p">[</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">-</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]]</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">connected_node</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">the_map</span><span class="p">[</span><span class="n">i</span><span class="p">[</span><span class="mi">0</span><span class="p">]][</span><span class="n">i</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="n">valued_connected_node</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">pass</span>
            <span class="k">return</span> <span class="n">valued_connected_node</span>

    <span class="k">else</span> <span class="p">:</span>
        <span class="k">if</span> <span class="n">y</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">:</span>
            <span class="n">connected_node</span> <span class="o">=</span> <span class="p">[[</span><span class="n">x</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">y</span><span class="p">],[</span><span class="n">x</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">y</span><span class="p">],[</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="o">+</span><span class="mi">1</span><span class="p">]]</span>
            <span class="n">valued_connected_node</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">connected_node</span> <span class="p">:</span>
                <span class="k">if</span> <span class="n">the_map</span><span class="p">[</span><span class="n">i</span><span class="p">[</span><span class="mi">0</span><span class="p">]][</span><span class="n">i</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span> <span class="o">==</span> <span class="mi">1</span> <span class="p">:</span>
                    <span class="n">valued_connected_node</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
                <span class="k">else</span> <span class="p">:</span>
                    <span class="k">pass</span>
            <span class="k">return</span> <span class="n">valued_connected_node</span>

        <span class="k">elif</span> <span class="n">y</span> <span class="o">==</span> <span class="nf">len</span><span class="p">(</span><span class="n">the_map</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">-</span> <span class="mi">1</span> <span class="p">:</span>
            <span class="n">connected_node</span> <span class="o">=</span> <span class="p">[[</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="o">-</span><span class="mi">1</span><span class="p">],[</span><span class="n">x</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">y</span><span class="p">],[</span><span class="n">x</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">y</span><span class="p">]]</span>
            <span class="n">valued_connected_node</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">connected_node</span> <span class="p">:</span>
                <span class="k">if</span> <span class="n">the_map</span><span class="p">[</span><span class="n">i</span><span class="p">[</span><span class="mi">0</span><span class="p">]][</span><span class="n">i</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span> <span class="o">==</span> <span class="mi">1</span> <span class="p">:</span>
                    <span class="n">valued_connected_node</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
                <span class="k">else</span> <span class="p">:</span>
                    <span class="k">pass</span>
            <span class="k">return</span> <span class="n">valued_connected_node</span>

        <span class="k">else</span> <span class="p">:</span>
            <span class="n">connected_node</span> <span class="o">=</span> <span class="p">[[</span><span class="n">x</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">y</span><span class="p">],[</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="o">+</span><span class="mi">1</span> <span class="p">],[</span><span class="n">x</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">y</span><span class="p">],[</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="o">-</span><span class="mi">1</span><span class="p">]]</span>
            <span class="n">valued_connected_node</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">connected_node</span> <span class="p">:</span>
                <span class="k">if</span> <span class="n">the_map</span><span class="p">[</span><span class="n">i</span><span class="p">[</span><span class="mi">0</span><span class="p">]][</span><span class="n">i</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span> <span class="o">==</span> <span class="mi">1</span> <span class="p">:</span>
                    <span class="n">valued_connected_node</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
                <span class="k">else</span> <span class="p">:</span>
                    <span class="k">pass</span>
            <span class="k">return</span> <span class="n">valued_connected_node</span>

</code></pre></div></div>

<p>위 방법은 매우 불편하다. 물론 이 방법으로 문제를 접근한다고 하더라도 답은 똑같다. 하지만 이렇게 배열의 첫번째 인덱스, 두번쨰 인덱스 모두의 경우의 수를 다 따져서 하드코딩하는 경우에는 반복문의 수가 너무 많고, 구현 과정에서 Human error가 발생할 가능성이 높다. 따라서 이런 경우에는 방향배열이라는 방법을 사용한다. 위 방법과 마찬가지인 내용이지만 훨신 간단하다. 코드를 한번 보자.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="c1"># 방향 배열 정의 (상, 우, 하, 좌)
</span><span class="n">dx</span> <span class="o">=</span> <span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
<span class="n">dy</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">]</span>

<span class="k">def</span> <span class="nf">connected_node_checker_2</span><span class="p">(</span><span class="n">the_map</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span> <span class="p">:</span>
    <span class="n">valued_connected_node</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="mi">4</span><span class="p">):</span>
        <span class="n">nx</span><span class="p">,</span> <span class="n">ny</span> <span class="o">=</span> <span class="n">x</span> <span class="o">+</span> <span class="n">dx</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">y</span> <span class="o">+</span> <span class="n">dy</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="k">if</span> <span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">nx</span> <span class="o">&lt;</span> <span class="nf">len</span><span class="p">(</span><span class="n">the_map</span><span class="p">)</span> <span class="ow">and</span> <span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">ny</span> <span class="o">&lt;</span> <span class="nf">len</span><span class="p">(</span><span class="n">the_map</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="ow">and</span> <span class="n">the_map</span><span class="p">[</span><span class="n">nx</span><span class="p">][</span><span class="n">ny</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">valued_connected_node</span><span class="p">.</span><span class="nf">append</span><span class="p">([</span><span class="n">nx</span><span class="p">,</span> <span class="n">ny</span><span class="p">])</span>
    <span class="k">return</span> <span class="n">valued_connected_node</span>

</code></pre></div></div>

<p>코드가 훨신 간단해졌다. 코드의 내용은 간단하다. 중요한 부분은 5번째 라인의 if문이다. 주어진 조건 the_map[i][j] 에서 nx(배열의 첫번째 인덱스)가 0 이하가 될 수는 없다. 그런 경우에는 indexOutOf에러가 발생할 것이다. 또한 nx가 len(the_map)보다 커질 수도 없다. y도 마찬가지이다. if 0 &lt;= nx &lt; len(the_map) and 0 &lt;= ny &lt; len(the_map[0]) 이 부분이 바로 그러한 인덱스를 제한해 준 조건이다.</p>

<p>그리고 and the_map[nx][ny] == 1 부분은 실제로 값을 참조해서 연결되어 있는 노드가 있는지 확인하는 조건이다.
방향 배열을 사용하니 코드가 더 간단해졌다. 수없이 많은 반복문이 없어진 것은 덤이다.</p>

<h5 id="bfs">BFS</h5>

<p>위 함수를 사용하여 BFS를 구현한 함수이다.</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="k">def</span> <span class="nf">bfs_to_goal</span><span class="p">(</span><span class="n">the_map</span><span class="p">,</span> <span class="n">start_node</span> <span class="p">:</span> <span class="nb">list</span><span class="p">,</span> <span class="n">goal</span><span class="p">:</span> <span class="nb">list</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">:</span>
    <span class="n">open_list</span> <span class="o">=</span> <span class="nf">deque</span><span class="p">()</span>
    <span class="n">visited_set</span> <span class="o">=</span> <span class="p">[[</span><span class="bp">False</span><span class="p">]</span><span class="o">*</span><span class="nf">len</span><span class="p">(</span><span class="n">the_map</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="nf">len</span><span class="p">(</span><span class="n">the_map</span><span class="p">))]</span>

    <span class="n">open_list</span><span class="p">.</span><span class="nf">append</span><span class="p">([</span><span class="n">start_node</span><span class="p">])</span>
    <span class="n">visited_set</span><span class="p">[</span><span class="n">start_node</span><span class="p">[</span><span class="mi">0</span><span class="p">]][</span><span class="n">start_node</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span> <span class="o">=</span> <span class="bp">True</span> 

    <span class="k">while</span> <span class="n">open_list</span> <span class="p">:</span>
        <span class="n">selected_node</span> <span class="o">=</span> <span class="n">open_list</span><span class="p">.</span><span class="nf">popleft</span><span class="p">()</span>
        <span class="n">last_selected_node</span> <span class="o">=</span> <span class="n">selected_node</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">last_selected_node</span> <span class="o">==</span> <span class="n">goal</span> <span class="p">:</span>
            <span class="k">return</span> <span class="nf">len</span><span class="p">(</span><span class="n">selected_node</span><span class="p">)</span>

        <span class="n">connected_node_list</span> <span class="o">=</span> <span class="nf">connected_node_checker_2</span><span class="p">(</span><span class="n">the_map</span><span class="p">,</span> <span class="n">last_selected_node</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">last_selected_node</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">connected_node_list</span> <span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">visited_set</span><span class="p">[</span><span class="n">i</span><span class="p">[</span><span class="mi">0</span><span class="p">]][</span><span class="n">i</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span> <span class="p">:</span>
                <span class="n">temp</span> <span class="o">=</span> <span class="n">selected_node</span><span class="p">[:]</span>
                <span class="n">temp</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
                <span class="n">open_list</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">temp</span><span class="p">)</span>
                <span class="n">visited_set</span><span class="p">[</span><span class="n">i</span><span class="p">[</span><span class="mi">0</span><span class="p">]][</span><span class="n">i</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span> <span class="o">=</span> <span class="bp">True</span> 
    <span class="k">return</span> <span class="o">-</span><span class="mi">1</span>

</code></pre></div></div>

<p>open_list는 deque이다. 일반 list로 구현할 경우에는 굉장히 느려지기 때문에, deque를 사용해야 한다. 또한 visited_set은 2차원 boolean 배열인데, 처음에는 시간을 위해서 set을 사용했지만(list를 사용하면 안 된다. list는 매우 느리기 때문에 시간초과로 문제가 터져버린다) 이런 경우에 메모리가 초과되어 버렸다. 따라서 2차원 boolean 배열로 각각 노드마다 방문을 했는지 하지 않았는지를 검사했다.</p>

<h5 id="java-코드">java 코드</h5>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code>

<span class="kn">import</span> <span class="nn">java.util.*</span><span class="o">;</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Main</span> <span class="o">{</span>
    <span class="kd">static</span> <span class="kt">int</span><span class="o">[]</span> <span class="n">dx</span> <span class="o">=</span> <span class="o">{-</span><span class="mi">1</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">0</span><span class="o">};</span>
    <span class="kd">static</span> <span class="kt">int</span><span class="o">[]</span> <span class="n">dy</span> <span class="o">=</span> <span class="o">{</span><span class="mi">0</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="o">-</span><span class="mi">1</span><span class="o">};</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">Scanner</span> <span class="n">scanner</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Scanner</span><span class="o">(</span><span class="nc">System</span><span class="o">.</span><span class="na">in</span><span class="o">);</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">condition</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="mi">2</span><span class="o">];</span>
        <span class="n">condition</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span> <span class="o">=</span> <span class="n">scanner</span><span class="o">.</span><span class="na">nextInt</span><span class="o">();</span>
        <span class="n">condition</span><span class="o">[</span><span class="mi">1</span><span class="o">]</span> <span class="o">=</span> <span class="n">scanner</span><span class="o">.</span><span class="na">nextInt</span><span class="o">();</span>
        <span class="n">scanner</span><span class="o">.</span><span class="na">nextLine</span><span class="o">();</span>

        <span class="kt">int</span><span class="o">[][]</span> <span class="n">theMap</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">condition</span><span class="o">[</span><span class="mi">0</span><span class="o">]][</span><span class="n">condition</span><span class="o">[</span><span class="mi">1</span><span class="o">]];</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">condition</span><span class="o">[</span><span class="mi">0</span><span class="o">];</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="nc">String</span> <span class="n">temp</span> <span class="o">=</span> <span class="n">scanner</span><span class="o">.</span><span class="na">nextLine</span><span class="o">();</span>
            <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">temp</span><span class="o">.</span><span class="na">length</span><span class="o">();</span> <span class="n">j</span><span class="o">++)</span> <span class="o">{</span>
                <span class="n">theMap</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">]</span> <span class="o">=</span> <span class="n">temp</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">j</span><span class="o">)</span> <span class="o">-</span> <span class="sc">'0'</span><span class="o">;</span>
            <span class="o">}</span>
        <span class="o">}</span>

        <span class="kt">int</span><span class="o">[]</span> <span class="n">startNode</span> <span class="o">=</span> <span class="o">{</span><span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">};</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">goal</span> <span class="o">=</span> <span class="o">{</span><span class="n">condition</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span> <span class="o">-</span> <span class="mi">1</span><span class="o">,</span> <span class="n">condition</span><span class="o">[</span><span class="mi">1</span><span class="o">]</span> <span class="o">-</span> <span class="mi">1</span><span class="o">};</span>
        <span class="kt">int</span> <span class="n">answer</span> <span class="o">=</span> <span class="n">bfsToGoal</span><span class="o">(</span><span class="n">theMap</span><span class="o">,</span> <span class="n">startNode</span><span class="o">,</span> <span class="n">goal</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">answer</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="nc">ArrayList</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">[]&gt;</span> <span class="nf">connectedNodeChecker</span><span class="o">(</span><span class="kt">int</span><span class="o">[][]</span> <span class="n">theMap</span><span class="o">,</span> <span class="kt">int</span> <span class="n">x</span><span class="o">,</span> <span class="kt">int</span> <span class="n">y</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">ArrayList</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">[]&gt;</span> <span class="n">valuedConnectedNode</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;();</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">4</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="kt">int</span> <span class="n">nx</span> <span class="o">=</span> <span class="n">x</span> <span class="o">+</span> <span class="n">dx</span><span class="o">[</span><span class="n">i</span><span class="o">];</span>
            <span class="kt">int</span> <span class="n">ny</span> <span class="o">=</span> <span class="n">y</span> <span class="o">+</span> <span class="n">dy</span><span class="o">[</span><span class="n">i</span><span class="o">];</span>
            <span class="k">if</span><span class="o">(</span><span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">nx</span> <span class="o">&amp;&amp;</span> <span class="n">nx</span> <span class="o">&lt;</span> <span class="n">theMap</span><span class="o">.</span><span class="na">length</span> <span class="o">&amp;&amp;</span> <span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">ny</span> <span class="o">&amp;&amp;</span> <span class="n">ny</span> <span class="o">&lt;</span> <span class="n">theMap</span><span class="o">[</span><span class="mi">0</span><span class="o">].</span><span class="na">length</span> <span class="o">&amp;&amp;</span> <span class="n">theMap</span><span class="o">[</span><span class="n">nx</span><span class="o">][</span><span class="n">ny</span><span class="o">]</span> <span class="o">==</span> <span class="mi">1</span><span class="o">)</span> <span class="o">{</span>
                <span class="kt">int</span><span class="o">[]</span> <span class="n">temp</span> <span class="o">=</span> <span class="o">{</span><span class="n">nx</span><span class="o">,</span> <span class="n">ny</span><span class="o">};</span>
                <span class="n">valuedConnectedNode</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">temp</span><span class="o">);</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">valuedConnectedNode</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">int</span> <span class="nf">bfsToGoal</span><span class="o">(</span><span class="kt">int</span><span class="o">[][]</span> <span class="n">theMap</span><span class="o">,</span> <span class="kt">int</span><span class="o">[]</span> <span class="n">startNode</span><span class="o">,</span> <span class="kt">int</span><span class="o">[]</span> <span class="n">goal</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">Queue</span><span class="o">&lt;</span><span class="nc">ArrayList</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">[]&gt;&gt;</span> <span class="n">openList</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">LinkedList</span><span class="o">&lt;&gt;();</span>
        <span class="kt">boolean</span><span class="o">[][]</span> <span class="n">visitedSet</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">boolean</span><span class="o">[</span><span class="n">theMap</span><span class="o">.</span><span class="na">length</span><span class="o">][</span><span class="n">theMap</span><span class="o">[</span><span class="mi">0</span><span class="o">].</span><span class="na">length</span><span class="o">];</span>
        <span class="nc">ArrayList</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">[]&gt;</span> <span class="n">tempStartNode</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;();</span>
        <span class="n">tempStartNode</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">startNode</span><span class="o">);</span>
        <span class="n">openList</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">tempStartNode</span><span class="o">);</span>
        <span class="n">visitedSet</span><span class="o">[</span><span class="n">startNode</span><span class="o">[</span><span class="mi">0</span><span class="o">]][</span><span class="n">startNode</span><span class="o">[</span><span class="mi">1</span><span class="o">]]</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>

        <span class="k">while</span> <span class="o">(!</span><span class="n">openList</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">())</span> <span class="o">{</span>
            <span class="nc">ArrayList</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">[]&gt;</span> <span class="n">selectedNode</span> <span class="o">=</span> <span class="n">openList</span><span class="o">.</span><span class="na">poll</span><span class="o">();</span>
            <span class="kt">int</span><span class="o">[]</span> <span class="n">lastSelectedNode</span> <span class="o">=</span> <span class="n">selectedNode</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">selectedNode</span><span class="o">.</span><span class="na">size</span><span class="o">()</span> <span class="o">-</span> <span class="mi">1</span><span class="o">);</span>
            <span class="k">if</span> <span class="o">(</span><span class="nc">Arrays</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="n">lastSelectedNode</span><span class="o">,</span> <span class="n">goal</span><span class="o">))</span> <span class="o">{</span>
                <span class="k">return</span> <span class="n">selectedNode</span><span class="o">.</span><span class="na">size</span><span class="o">();</span>
            <span class="o">}</span>

            <span class="nc">ArrayList</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">[]&gt;</span> <span class="n">connectedNodeList</span> <span class="o">=</span> <span class="n">connectedNodeChecker</span><span class="o">(</span><span class="n">theMap</span><span class="o">,</span> <span class="n">lastSelectedNode</span><span class="o">[</span><span class="mi">0</span><span class="o">],</span> <span class="n">lastSelectedNode</span><span class="o">[</span><span class="mi">1</span><span class="o">]);</span>
            <span class="k">for</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">i</span> <span class="o">:</span> <span class="n">connectedNodeList</span><span class="o">)</span> <span class="o">{</span>
                <span class="k">if</span> <span class="o">(!</span><span class="n">visitedSet</span><span class="o">[</span><span class="n">i</span><span class="o">[</span><span class="mi">0</span><span class="o">]][</span><span class="n">i</span><span class="o">[</span><span class="mi">1</span><span class="o">]])</span> <span class="o">{</span>
                    <span class="n">visitedSet</span><span class="o">[</span><span class="n">i</span><span class="o">[</span><span class="mi">0</span><span class="o">]][</span><span class="n">i</span><span class="o">[</span><span class="mi">1</span><span class="o">]]</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
                    <span class="nc">ArrayList</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">[]&gt;</span> <span class="n">clonedSelectedNode</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;(</span><span class="n">selectedNode</span><span class="o">);</span>
                    <span class="n">clonedSelectedNode</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">i</span><span class="o">);</span>
                    <span class="n">openList</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">clonedSelectedNode</span><span class="o">);</span>
                <span class="o">}</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>

</code></pre></div></div>]]></content><author><name>ash tensor</name></author><category term="백준" /><category term="PS" /><category term="자료구조" /><category term="파이썬" /><category term="JAVA" /><summary type="html"><![CDATA[[백준][자료구조] 백준 2178번 :: 미로 탐색 :: 실버 1]]></summary></entry></feed>