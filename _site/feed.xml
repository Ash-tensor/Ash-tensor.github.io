<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.3.2">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2024-05-02T17:48:24+09:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">Tensor Studio</title><subtitle>텐서 스튜디오</subtitle><author><name>ash tensor</name></author><entry><title type="html">[백준][JAVA] 백준 7562번 :: 나이트의 이동 :: 실버 1</title><link href="http://localhost:4000/java/ps/%EB%B0%B1%EC%A4%80/2024/03/28/boj7562.html" rel="alternate" type="text/html" title="[백준][JAVA] 백준 7562번 :: 나이트의 이동 :: 실버 1" /><published>2024-03-28T00:00:00+09:00</published><updated>2024-03-28T00:00:00+09:00</updated><id>http://localhost:4000/java/ps/%EB%B0%B1%EC%A4%80/2024/03/28/boj7562</id><content type="html" xml:base="http://localhost:4000/java/ps/%EB%B0%B1%EC%A4%80/2024/03/28/boj7562.html"><![CDATA[<h2 id="백준java-백준-7562번--나이트의-이동--실버-1">[백준][JAVA] 백준 7562번 :: 나이트의 이동 :: 실버 1</h2>

<h3 id="문제-설명">문제 설명</h3>

<p>체스판 위에 한 나이트가 놓여져 있다. 나이트가 한 번에 이동할 수 있는 칸은 아래 그림에 나와있다. 
나이트가 이동하려고 하는 칸이 주어진다. 나이트는 몇 번 움직이면 이 칸으로 이동할 수 있을까?</p>

<h3 id="문제-입력">문제 입력</h3>

<p>입력의 첫째 줄에는 테스트 케이스의 개수가 주어진다.</p>

<p>각 테스트 케이스는 세 줄로 이루어져 있다. 첫째 줄에는 체스판의 한 변의 길이 l(4 ≤ l ≤ 300)이 주어진다. 
체스판의 크기는 l × l이다. 체스판의 각 칸은 두 수의 쌍 {0, …, l-1} × {0, …, l-1}로 나타낼 수 있다. 
둘째 줄과 셋째 줄에는 나이트가 현재 있는 칸, 나이트가 이동하려고 하는 칸이 주어진다.</p>

<h3 id="출력">출력</h3>

<p>각 테스트 케이스마다 나이트가 최소 몇 번만에 이동할 수 있는지 출력한다.</p>

<h3 id="예제-입력">예제 입력</h3>

<p>3</p>

<p>8</p>

<p>0 0</p>

<p>7 0</p>

<p>100</p>

<p>0 0</p>

<p>30 50</p>

<p>10</p>

<p>1 1</p>

<p>1 1</p>

<h3 id="예제-출력">예제 출력</h3>

<p>5</p>

<p>28</p>

<p>0</p>

<h4 id="접근방법">접근방법</h4>

<p>오랜만에 푸는 알고리즘 문제였다!! 빅데이터 분석기사(필기), 정보처리기사(실기) 시험을 준비하느라 알고리즘 문제를 풀지 못했는데, 
오랜만에 풀어보니까 너무 재밌었다. 다행히 두 시험 다 합격했는데, 이제부터 조금씩이라도 알고리즘 문제를 풀고 싶다.</p>

<p>문제는 그렇게 어렵지 않아서 금방 풀 수 있었고, 살짝 흔한 BFS 문제였다. 나는 알고리즘 문제를 밀리의 서재에 있는
[주요기업/금융권 IT 디지털 직무 채용대비 한권으로 합격하는 취업 코딩테스트] 라는 책을 참고하면서 풀고 있는데, 
올해 안에 이 책의 모든 문제를 풀이하고 시간이 허락한다면 PCCP라는 알고리즘 자격증 시험에서 높은 점수를 얻는게 목표다(우선순위는 낮지만).</p>

<p>이 책은 솔직히 엄청 좋냐? 하면 그건 아닌 것 같은데 그렇다고 엄청 나쁘냐 하면 그렇지는 않다. 왜냐하면 알고리즘 문제는 그냥 많이 풀어보는게 답이라고 생각하기 때문이다.
시간을 들인 만큼 정직하게 결과가 나오기 떄문에 그냥 많이 풀어보는게 답이라고 생각한다. 그래서 이 책이 아니라 다른 책을 찾는다고 해도 
솔직히 큰 차이가 없을 것 같다.</p>

<p>아무튼 최소거리를 구하라고 하면 BFS 문제이고, 이동한 구체적인 루트를 적으라고 하지는 않았으니 노드 각각 방문한 노드를 개별로 구현할 필요는 없고, 
전체 BFS 내에서 방문한 노드를 체크하기만 하면 된다.</p>

<h3 id="코드">코드</h3>

<p>나이트 노드 클래스와 메인 클래스를 구현했는데, 지금 보니 KnightNode 클래스 내에 getKnightMoves 메소드를 구현하는 것이 더 좋았을 것 같다.
지금은 메인 클래스 내에 존재하는데, 객체지향적으로 생각했을때 좋은 설계가 아니었다는 생각이 든다.</p>

<p>KnightNode 클래스는 나이트의 현재 위치, 방문한 노드들, 깊이를 저장하는 클래스이고, 
나이트가 방문한 노드를 표시하는 int[][] visitedNodes를 가지고 있다. visitedNodes는 나이트 기물에 각각 생성되는 게 아니라,
전역의 visitedNodes를 가리킨다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="kn">package</span> <span class="nn">boj</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">java.util.ArrayDeque</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.ArrayList</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.Arrays</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.Scanner</span><span class="o">;</span>

<span class="kd">class</span> <span class="nc">KnightNode</span> <span class="o">{</span>
    <span class="kt">int</span><span class="o">[]</span> <span class="n">coordinate</span><span class="o">;</span>
    <span class="kt">int</span><span class="o">[][]</span> <span class="n">visitedNodes</span><span class="o">;</span>
    <span class="kt">int</span> <span class="n">depth</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
    
    <span class="c1">//최초의 나이트 노드 생성용</span>
    
    <span class="kd">public</span> <span class="nf">KnightNode</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">coordinate</span><span class="o">,</span> <span class="kt">int</span> <span class="n">boardLength</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">coordinate</span> <span class="o">=</span> <span class="n">coordinate</span><span class="o">;</span>
        <span class="k">this</span><span class="o">.</span><span class="na">visitedNodes</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">boardLength</span><span class="o">][</span><span class="n">boardLength</span><span class="o">];</span>
        <span class="k">this</span><span class="o">.</span><span class="na">visit</span><span class="o">(</span><span class="n">coordinate</span><span class="o">);</span>
    <span class="o">}</span>
    
    <span class="c1">// bfs를 돌며 생성되는 나이트 노드 생성용 생성자</span>
    <span class="kd">public</span> <span class="nf">KnightNode</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">coordinate</span><span class="o">,</span> <span class="kt">int</span><span class="o">[][]</span> <span class="n">visitedNodes</span><span class="o">,</span> <span class="kt">int</span> <span class="n">depth</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">coordinate</span> <span class="o">=</span> <span class="n">coordinate</span><span class="o">;</span>
        
        <span class="c1">//new int[][] visitedNodes를 하지 않고 visitedNodes를 그대로 가리키게 하면</span>
        <span class="c1">//각각의 나이트 노드가 같은 visitedNodes를 가리키게 되어서</span>
        <span class="c1">//나이트 노드 각각의 visitedNodes가 생성되는 것이 아니라</span>
        <span class="c1">//전역의 visitedNodes를 가리키게 된다.</span>
        
        <span class="k">this</span><span class="o">.</span><span class="na">visitedNodes</span> <span class="o">=</span> <span class="n">visitedNodes</span><span class="o">;</span>
        <span class="k">this</span><span class="o">.</span><span class="na">depth</span> <span class="o">=</span> <span class="n">depth</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">visit</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">coordinate</span><span class="o">)</span> <span class="o">{</span>
    <span class="c1">// 방문한 노드를 표시한다.</span>
        <span class="k">this</span><span class="o">.</span><span class="na">visitedNodes</span><span class="o">[</span><span class="n">coordinate</span><span class="o">[</span><span class="mi">0</span><span class="o">]][</span><span class="n">coordinate</span><span class="o">[</span><span class="mi">1</span><span class="o">]]</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">checkVisited</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">coordinate</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// 방문했으면 참, 방문하지 않았으면 거짓</span>
        <span class="k">if</span> <span class="o">(</span><span class="k">this</span><span class="o">.</span><span class="na">visitedNodes</span><span class="o">[</span><span class="n">coordinate</span><span class="o">[</span><span class="mi">0</span><span class="o">]][</span><span class="n">coordinate</span><span class="o">[</span><span class="mi">1</span><span class="o">]]</span> <span class="o">==</span> <span class="mi">1</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="k">else</span> <span class="o">{</span>
            <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">newboj7562</span> <span class="o">{</span>
    <span class="kd">static</span> <span class="kt">int</span> <span class="n">testCaseNumber</span><span class="o">;</span>
    <span class="kd">static</span> <span class="nc">ArrayList</span><span class="o">&lt;</span><span class="nc">ArrayList</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">[]&gt;&gt;</span> <span class="n">testCases</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;();</span>
    <span class="kd">static</span> <span class="nc">ArrayList</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">[]&gt;</span> <span class="n">movementMetrix</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;();</span>
    <span class="kd">static</span> <span class="kt">int</span><span class="o">[][]</span> <span class="n">visitedList</span><span class="o">;</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">Scanner</span> <span class="n">scanner</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Scanner</span><span class="o">(</span><span class="nc">System</span><span class="o">.</span><span class="na">in</span><span class="o">);</span>
        <span class="n">inputMethod</span><span class="o">(</span><span class="n">scanner</span><span class="o">);</span>
        
        <span class="c1">//나이트가 이동할 수 있는 방향을 저장한다.</span>
        
        <span class="n">movementMetrix</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="k">new</span> <span class="kt">int</span><span class="o">[]</span> <span class="o">{-</span><span class="mi">2</span><span class="o">,</span> <span class="o">-</span><span class="mi">1</span><span class="o">});</span>
        <span class="n">movementMetrix</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="k">new</span> <span class="kt">int</span><span class="o">[]</span> <span class="o">{-</span><span class="mi">2</span><span class="o">,</span> <span class="mi">1</span><span class="o">});</span>
        <span class="n">movementMetrix</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="k">new</span> <span class="kt">int</span><span class="o">[]</span> <span class="o">{-</span><span class="mi">1</span><span class="o">,</span> <span class="o">-</span><span class="mi">2</span><span class="o">});</span>
        <span class="n">movementMetrix</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="k">new</span> <span class="kt">int</span><span class="o">[]</span> <span class="o">{</span><span class="mi">1</span><span class="o">,</span> <span class="o">-</span><span class="mi">2</span><span class="o">});</span>
        <span class="n">movementMetrix</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="k">new</span> <span class="kt">int</span><span class="o">[]</span> <span class="o">{-</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">});</span>
        <span class="n">movementMetrix</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="k">new</span> <span class="kt">int</span><span class="o">[]</span> <span class="o">{+</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">});</span>
        <span class="n">movementMetrix</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="k">new</span> <span class="kt">int</span><span class="o">[]</span> <span class="o">{</span><span class="mi">2</span><span class="o">,</span> <span class="o">-</span><span class="mi">1</span><span class="o">});</span>
        <span class="n">movementMetrix</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="k">new</span> <span class="kt">int</span><span class="o">[]</span> <span class="o">{</span><span class="mi">2</span><span class="o">,</span> <span class="mi">1</span><span class="o">});</span>

        <span class="k">for</span><span class="o">(</span><span class="nc">ArrayList</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">[]&gt;</span> <span class="n">testCase</span> <span class="o">:</span> <span class="n">testCases</span><span class="o">)</span> <span class="o">{</span>
            <span class="nc">KnightNode</span> <span class="n">answerKnight</span> <span class="o">=</span> <span class="n">bfs</span><span class="o">(</span><span class="n">testCase</span><span class="o">);</span>
            <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">answerKnight</span><span class="o">.</span><span class="na">depth</span><span class="o">);</span>

        <span class="o">}</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="nc">KnightNode</span> <span class="nf">bfs</span><span class="o">(</span><span class="nc">ArrayList</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">[]&gt;</span> <span class="n">testCase</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">boardLength</span> <span class="o">=</span> <span class="n">testCase</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="mi">0</span><span class="o">);</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">nowPosition</span> <span class="o">=</span> <span class="n">testCase</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="mi">1</span><span class="o">);</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">destination</span> <span class="o">=</span> <span class="n">testCase</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="mi">2</span><span class="o">);</span>

        <span class="n">visitedList</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">boardLength</span><span class="o">[</span><span class="mi">0</span><span class="o">]][</span><span class="n">boardLength</span><span class="o">[</span><span class="mi">0</span><span class="o">]];</span>

        <span class="nc">ArrayDeque</span><span class="o">&lt;</span><span class="nc">KnightNode</span><span class="o">&gt;</span> <span class="n">model</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayDeque</span><span class="o">&lt;&gt;();</span>
        <span class="n">model</span><span class="o">.</span><span class="na">addLast</span><span class="o">(</span><span class="k">new</span> <span class="nc">KnightNode2</span><span class="o">(</span><span class="n">nowPosition</span><span class="o">,</span> <span class="n">boardLength</span><span class="o">[</span><span class="mi">0</span><span class="o">]));</span>

        <span class="k">while</span> <span class="o">(</span><span class="n">model</span><span class="o">.</span><span class="na">size</span><span class="o">()</span> <span class="o">!=</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
            <span class="nc">KnightNode</span> <span class="n">selectedKnight</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="na">pollFirst</span><span class="o">();</span>
            <span class="k">if</span> <span class="o">(</span><span class="nc">Arrays</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="n">selectedKnight</span><span class="o">.</span><span class="na">coordinate</span><span class="o">,</span> <span class="n">destination</span><span class="o">))</span> <span class="o">{</span>
                <span class="k">return</span> <span class="n">selectedKnight</span><span class="o">;</span>
            <span class="o">}</span>
            <span class="k">else</span> <span class="o">{</span>
                <span class="nc">ArrayList</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">[]&gt;</span> <span class="n">coordinates</span> <span class="o">=</span> <span class="n">getKnightMoves</span><span class="o">(</span><span class="n">boardLength</span><span class="o">[</span><span class="mi">0</span><span class="o">],</span>
                        <span class="n">selectedKnight</span><span class="o">.</span><span class="na">coordinate</span><span class="o">);</span>

                <span class="k">for</span> <span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">x</span> <span class="o">:</span> <span class="n">coordinates</span><span class="o">)</span> <span class="o">{</span>
                    <span class="k">if</span><span class="o">(</span><span class="n">selectedKnight</span><span class="o">.</span><span class="na">checkVisited</span><span class="o">(</span><span class="n">x</span><span class="o">))</span> <span class="o">{</span><span class="c1">// 방문했으면 pass</span>
                    <span class="o">}</span>
                    <span class="k">else</span> <span class="o">{</span>
                        <span class="nc">KnightNode</span> <span class="n">tempKnight</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">KnightNode2</span><span class="o">(</span><span class="n">x</span><span class="o">,</span> 
                         <span class="n">selectedKnight</span><span class="o">.</span><span class="na">visitedNodes</span><span class="o">,</span> <span class="n">selectedKnight</span><span class="o">.</span><span class="na">depth</span> <span class="o">+</span> <span class="mi">1</span><span class="o">);</span>
                        <span class="n">tempKnight</span><span class="o">.</span><span class="na">visit</span><span class="o">(</span><span class="n">x</span><span class="o">);</span>
                        <span class="n">model</span><span class="o">.</span><span class="na">addLast</span><span class="o">(</span><span class="n">tempKnight</span><span class="o">);</span>
                    <span class="o">}</span>
                <span class="o">}</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="kc">null</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="nc">ArrayList</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">[]&gt;</span> <span class="nf">getKnightMoves</span><span class="o">(</span><span class="kt">int</span> <span class="n">boardLength</span><span class="o">,</span> <span class="kt">int</span><span class="o">[]</span> <span class="n">coordinates</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">ArrayList</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">[]&gt;</span> <span class="n">returnArray</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;();</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">x</span> <span class="o">:</span> <span class="n">movementMetrix</span><span class="o">)</span> <span class="o">{</span>
            <span class="kt">int</span><span class="o">[]</span> <span class="n">tempCoordinates</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="mi">2</span><span class="o">];</span>
            <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
            <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">y</span> <span class="o">:</span> <span class="n">x</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">tempCoordinates</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="n">coordinates</span><span class="o">[</span><span class="n">i</span><span class="o">++]</span> <span class="o">+</span> <span class="n">y</span><span class="o">;</span>
            <span class="o">}</span>
            <span class="k">if</span><span class="o">(</span><span class="n">checkBoardLimit</span><span class="o">(</span><span class="n">boardLength</span><span class="o">,</span> <span class="n">tempCoordinates</span><span class="o">))</span> <span class="o">{</span>
                <span class="c1">// BoardLimit내에 위치하면</span>
                <span class="n">returnArray</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">tempCoordinates</span><span class="o">);</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">returnArray</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">boolean</span> <span class="nf">checkBoardLimit</span><span class="o">(</span><span class="kt">int</span> <span class="n">boardLength</span><span class="o">,</span> <span class="kt">int</span><span class="o">[]</span> <span class="n">coordinate</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">x</span> <span class="o">:</span> <span class="n">coordinate</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">x</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
                <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
            <span class="o">}</span>
            <span class="k">else</span> <span class="nf">if</span> <span class="o">(</span><span class="n">x</span> <span class="o">&gt;=</span> <span class="n">boardLength</span><span class="o">)</span> <span class="o">{</span>
                <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">inputMethod</span><span class="o">(</span><span class="nc">Scanner</span> <span class="n">scanner</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">newboj7562</span><span class="o">.</span><span class="na">testCaseNumber</span> <span class="o">=</span> <span class="n">scanner</span><span class="o">.</span><span class="na">nextInt</span><span class="o">();</span>
        <span class="n">scanner</span><span class="o">.</span><span class="na">nextLine</span><span class="o">();</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">newboj7562</span><span class="o">.</span><span class="na">testCaseNumber</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="nc">ArrayList</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">[]&gt;</span> <span class="n">testCase</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;();</span>
            <span class="kt">int</span> <span class="n">boardLength</span> <span class="o">=</span> <span class="n">scanner</span><span class="o">.</span><span class="na">nextInt</span><span class="o">();</span>
            <span class="n">testCase</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="k">new</span> <span class="kt">int</span><span class="o">[]</span> <span class="o">{</span><span class="n">boardLength</span><span class="o">});</span>
            <span class="n">scanner</span><span class="o">.</span><span class="na">nextLine</span><span class="o">();</span>

            <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="o">;</span> <span class="n">j</span><span class="o">++)</span> <span class="o">{</span>
                <span class="nc">String</span> <span class="n">coordinates</span> <span class="o">=</span> <span class="n">scanner</span><span class="o">.</span><span class="na">nextLine</span><span class="o">();</span>
                <span class="kt">int</span><span class="o">[]</span> <span class="n">parsedLine</span> <span class="o">=</span> <span class="n">parsingString</span><span class="o">(</span><span class="n">coordinates</span><span class="o">);</span>
                <span class="n">testCase</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">parsedLine</span><span class="o">);</span>
            <span class="o">}</span>
            <span class="n">testCases</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">testCase</span><span class="o">);</span>
        <span class="o">}</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">int</span><span class="o">[]</span> <span class="nf">parsingString</span><span class="o">(</span><span class="nc">String</span> <span class="n">string</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">String</span><span class="o">[]</span> <span class="n">tempString</span> <span class="o">=</span> <span class="n">string</span><span class="o">.</span><span class="na">split</span><span class="o">(</span><span class="s">" "</span><span class="o">);</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">ints</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="mi">2</span><span class="o">];</span>

        <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="k">for</span> <span class="o">(</span><span class="nc">String</span> <span class="n">x</span> <span class="o">:</span> <span class="n">tempString</span><span class="o">)</span> <span class="o">{</span>
            <span class="kt">int</span> <span class="n">temp</span> <span class="o">=</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="n">x</span><span class="o">);</span>
            <span class="n">ints</span><span class="o">[</span><span class="n">i</span><span class="o">++]</span> <span class="o">=</span> <span class="n">temp</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">ints</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>

</code></pre></div></div>

<p>좀 더 깔끔하게 풀이할 수도 있을 것 같은데, 오랜만에 알고리즘 문제를 푼 것 치고는 감을 잡는데 도움이 된 것 같아서 만족스럽다.</p>]]></content><author><name>ash tensor</name></author><category term="JAVA" /><category term="PS" /><category term="백준" /><summary type="html"><![CDATA[[백준][JAVA] 백준 7562번 :: 나이트의 이동 :: 실버 1]]></summary></entry><entry><title type="html">[백준][JAVA] 백준 12100번 :: 2048(Easy) :: 골드 2</title><link href="http://localhost:4000/java/ps/%EB%B0%B1%EC%A4%80/2024/03/28/boj12100.html" rel="alternate" type="text/html" title="[백준][JAVA] 백준 12100번 :: 2048(Easy) :: 골드 2" /><published>2024-03-28T00:00:00+09:00</published><updated>2024-03-28T00:00:00+09:00</updated><id>http://localhost:4000/java/ps/%EB%B0%B1%EC%A4%80/2024/03/28/boj12100</id><content type="html" xml:base="http://localhost:4000/java/ps/%EB%B0%B1%EC%A4%80/2024/03/28/boj12100.html"><![CDATA[<h2 id="백준java-백준-12100번--2048easy--골드-2">[백준][JAVA] 백준 12100번 :: 2048(Easy) :: 골드 2</h2>

<h3 id="문제-설명">문제 설명</h3>

<p>2048 게임은 4×4 크기의 보드에서 혼자 즐기는 재미있는 게임이다. 이 링크를 누르면 게임을 해볼 수 있다.</p>

<p>이 게임에서 한 번의 이동은 보드 위에 있는 전체 블록을 상하좌우 네 방향 중 하나로 이동시키는 것이다. 
이때, 같은 값을 갖는 두 블록이 충돌하면 두 블록은 하나로 합쳐지게 된다. 한 번의 이동에서 이미 합쳐진 블록은 또 다른 블록과 다시 합쳐질 수 없다. 
(실제 게임에서는 이동을 한 번 할 때마다 블록이 추가되지만, 이 문제에서 블록이 추가되는 경우는 없다)</p>

<p><img src="/img/posts/boj12100/1.png" width="80%" /></p>

<p>마지막으로, 똑같은 수가 세 개가 있는 경우에는 이동하려고 하는 쪽의 칸이 먼저 합쳐진다. 
예를 들어, 위로 이동시키는 경우에는 위쪽에 있는 블록이 먼저 합쳐지게 된다. &lt;그림 14&gt;의 경우에 위로 이동하면 &lt;그림 15&gt;를 만든다.</p>

<p>이 문제에서 다루는 2048 게임은 보드의 크기가 N×N 이다. 
보드의 크기와 보드판의 블록 상태가 주어졌을 때, 최대 5번 이동해서 만들 수 있는 가장 큰 블록의 값을 구하는 프로그램을 작성하시오.</p>

<h3 id="문제-입력">문제 입력</h3>

<p>첫째 줄에 보드의 크기 N (1 ≤ N ≤ 20)이 주어진다. 둘째 줄부터 N개의 줄에는 게임판의 초기 상태가 주어진다. 
0은 빈 칸을 나타내며, 이외의 값은 모두 블록을 나타낸다. 블록에 쓰여 있는 수는 2보다 크거나 같고, 1024보다 작거나 같은 2의 제곱꼴이다. 
블록은 적어도 하나 주어진다.</p>

<h3 id="출력">출력</h3>

<p>최대 5번 이동시켜서 얻을 수 있는 가장 큰 블록을 출력한다.</p>

<h3 id="예제-입력">예제 입력</h3>

<p>3</p>

<p>2 2 2</p>

<p>4 4 4</p>

<p>8 8 8</p>

<h3 id="예제-출력">예제 출력</h3>

<p>16</p>

<h4 id="접근방법">접근방법</h4>

<p>사실 이 문제가 골드 2라고는 생각하지 않는다. 왜냐하면 무식한 구현문제라고 생각하기 때문이다. 개인적으로 생각하기엔, 
이 정도 수준의 구현을 해당 언어가 제공하는 다양한 문법을 이용해서 풀 수 있다면(GPT 등을 최소한으로 이용하고) 
해당 언어를 어느정도 사용할 수 있다고 말할 수 있다고 말해도 좋다.</p>

<p>문제를 해결하고 다른 사람이 어떻게 접근했는지 살펴봤는데, 나처럼 무식하게 전부 구현해버린 사람은 조금 드문것 같다는 생각이 들었다.
일단 이 문제를 해결하는데 있어서 가장 중요한 것은 보드의 칸(이하 노드라고 설명)의 움직임과 숫자가 병합되는 규칙등을 
제대로 구현하는 것이다.</p>

<p>왜냐하면 최대 5번 움직여서 가장 큰 수를 출력하는 것 이라는 조건이 붙어있기는 하지만 단순히 5번 움직이는 것의 중복 조합의 갯수를 구해봐야
 고작 4^5 수준의 문제공간이기 때문이다. 이정도는 컴퓨터가 모든 중복조합의 경우를 다 구해버리고도 시간이 충분히 남기 때문에, 결국 올바른 구현이
 가장 중요하다.</p>

<p>개인적으로 이 문제는 자바를 이용해서 푸는 것도 좋다고 생각하는데, 해당 문제가 객체지향을 연습하기 좀 좋은 예제라고 생각하기 때문이다.</p>

<h3 id="코드">코드</h3>

<p>일단 문제를 node 클래스와, board 클래스로 나누어서 구현했다. node 클래스는 각 노드의 값을 저장하고, 이동하는 함수를 구현했다.
보드는 방향 명령을 내리거나 초기화를 하거나 하는 메소드로 구성되어 있고, 노드 클래스에서는 그 명령을 받아 각 노드의 행동을 구현했다.</p>

<p>노드의 이동을 구현할때, 주의해야 할 점은 예를 들어서 왼쪽 명령을 보드에서 노드에 내린다고 해 보자. 그렇다고 하더라도 실제 노드가 이동하는 것이 아니다.
노드는 가만히 있고 해당 노드의 값만 바뀌는 것이다.</p>

<p>0 0 2 라는 열이 존재할 때 왼쪽 명령을 가장 오른쪽 노드가 받는다고 쳐보자. 그런 경우에는 첫번째로 [0, 2]노드가 [0, 1] 노드의 값을 변경한다.
그리고 [0, 1]의 노드의 leftmove 메소드를 호출한다. 이런 식으로 연쇄적으로 방향 명령이 호출되고 병합되는 방식으로 구현된다.</p>

<p>또한 중요한 점은, 한번의 이동에 하나의 노드는 한 번밖에는 병합되지 않는다는 점이다.
다시말해서</p>

<p>[2, 2, 2, 2] 라는 열이 있다고 할 때, 왼쪽 명령을 받는다고 치자. 그 경우에 올바른 결과는 [4, 4, 0, 0] 이다.
또한 [4, 2, 2] 라는 열이 있다고 할 때, 왼쪽 명령을 받으면 그 경우에 올바른 결과는 [4, 4, 0] 이다.</p>

<p>첫번째까지는 생각하기 쉬워도 두번째 예시는 한번에 생각해내기 어렵다. 단순히 병합된 후에 연쇄적인 left 콜이 없으면 연쇄가 끊기니까 문제가 없을것이라고 생각했는데, 
이러한 경우에는 두번째 예시를 만족시키지 못하고 [8, 0, 0] 으로 병합되어버리고 만다. 
그래서 이런 경우에는 노드의 concated라는 변수를 이용해서 만약 concated가 true이면 한번만 병합되도록 구현했다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
 <span class="kn">package</span> <span class="nn">boj</span><span class="o">;</span>
 
 <span class="kn">import</span> <span class="nn">java.util.ArrayDeque</span><span class="o">;</span>
 <span class="kn">import</span> <span class="nn">java.util.ArrayList</span><span class="o">;</span>
 <span class="kn">import</span> <span class="nn">java.util.Scanner</span><span class="o">;</span>
 
 <span class="kd">public</span> <span class="kd">class</span> <span class="nc">boj12100</span> <span class="o">{</span>
     <span class="kd">static</span> <span class="kt">int</span> <span class="n">inputedMaximunNumber</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
     <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
         <span class="nc">Scanner</span> <span class="n">scanner</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Scanner</span><span class="o">(</span><span class="nc">System</span><span class="o">.</span><span class="na">in</span><span class="o">);</span>
         <span class="nc">ArrayList</span><span class="o">&lt;</span><span class="n">node</span><span class="o">&gt;</span> <span class="n">nodeList</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;();</span>
         <span class="n">node</span><span class="o">[][]</span> <span class="n">inputModel</span> <span class="o">=</span> <span class="n">gameSetter</span><span class="o">(</span><span class="n">scanner</span><span class="o">);</span>
         <span class="n">board</span> <span class="nc">Board</span> <span class="o">=</span> <span class="k">new</span> <span class="n">board</span><span class="o">(</span><span class="n">inputModel</span><span class="o">);</span>
 
         <span class="kt">int</span> <span class="n">allMaxNumber</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
 
         <span class="nc">ArrayDeque</span><span class="o">&lt;</span><span class="nc">ArrayList</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;&gt;</span> <span class="n">orderList</span> <span class="o">=</span> <span class="no">BFS</span><span class="o">();</span>
         <span class="k">for</span> <span class="o">(</span><span class="nc">ArrayList</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">row</span> <span class="o">:</span> <span class="n">orderList</span><span class="o">)</span> <span class="o">{</span>
             <span class="k">for</span> <span class="o">(</span><span class="nc">Integer</span> <span class="n">order</span> <span class="o">:</span> <span class="n">row</span><span class="o">)</span> <span class="o">{</span>
                 <span class="n">orderInterpreter</span><span class="o">(</span><span class="n">order</span><span class="o">,</span> <span class="nc">Board</span><span class="o">);</span>
             <span class="o">}</span>
             <span class="kt">int</span> <span class="n">tempMaxNumber</span> <span class="o">=</span> <span class="nc">Board</span><span class="o">.</span><span class="na">getMaxNumber</span><span class="o">();</span>
             <span class="k">if</span> <span class="o">(</span><span class="n">allMaxNumber</span> <span class="o">&lt;</span> <span class="n">tempMaxNumber</span><span class="o">)</span> <span class="o">{</span>
                 <span class="n">allMaxNumber</span> <span class="o">=</span> <span class="n">tempMaxNumber</span><span class="o">;</span>
             <span class="o">}</span>
             <span class="nc">Board</span><span class="o">.</span><span class="na">resetBoard</span><span class="o">();</span>
         <span class="o">}</span>
         <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">allMaxNumber</span><span class="o">);</span>
 
     <span class="o">}</span>
     <span class="kd">public</span> <span class="kd">static</span> <span class="n">node</span><span class="o">[][]</span> <span class="nf">gameSetter</span><span class="o">(</span><span class="nc">Scanner</span> <span class="n">scanner</span><span class="o">)</span> <span class="o">{</span>
         <span class="kt">int</span> <span class="n">boardSize</span> <span class="o">=</span> <span class="n">scanner</span><span class="o">.</span><span class="na">nextInt</span><span class="o">();</span>
         <span class="n">scanner</span><span class="o">.</span><span class="na">nextLine</span><span class="o">();</span>
 
         <span class="n">node</span><span class="o">[][]</span> <span class="n">tempBoard</span> <span class="o">=</span> <span class="k">new</span> <span class="n">node</span><span class="o">[</span><span class="n">boardSize</span><span class="o">][</span><span class="n">boardSize</span><span class="o">];</span>
 
         <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">boardSize</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
             <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">k</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">k</span> <span class="o">&lt;</span> <span class="n">boardSize</span><span class="o">;</span> <span class="n">k</span><span class="o">++)</span> <span class="o">{</span>
                 <span class="kt">int</span><span class="o">[]</span> <span class="n">coordinate</span> <span class="o">=</span> <span class="o">{</span><span class="n">i</span><span class="o">,</span> <span class="n">k</span><span class="o">};</span>
                 <span class="kt">int</span> <span class="n">tempValue</span> <span class="o">=</span> <span class="n">scanner</span><span class="o">.</span><span class="na">nextInt</span><span class="o">();</span>
                 <span class="n">inputedMaximunNumber</span> <span class="o">+=</span> <span class="n">tempValue</span><span class="o">;</span>
                 <span class="n">node</span> <span class="n">tempNode</span> <span class="o">=</span> <span class="k">new</span> <span class="n">node</span><span class="o">(</span><span class="n">tempValue</span><span class="o">,</span> <span class="n">coordinate</span><span class="o">,</span> <span class="n">tempBoard</span><span class="o">);</span>
             <span class="o">}</span>
             <span class="n">scanner</span><span class="o">.</span><span class="na">nextLine</span><span class="o">();</span>
         <span class="o">}</span>
         <span class="k">return</span> <span class="n">tempBoard</span><span class="o">;</span>
     <span class="o">}</span>
 
     <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">orderInterpreter</span><span class="o">(</span><span class="kt">int</span> <span class="n">number</span><span class="o">,</span> <span class="n">board</span> <span class="nc">Board</span><span class="o">)</span> <span class="o">{</span>
         <span class="k">switch</span> <span class="o">(</span><span class="n">number</span><span class="o">)</span> <span class="o">{</span>
             <span class="k">case</span> <span class="mi">0</span> <span class="o">:</span>
                 <span class="nc">Board</span><span class="o">.</span><span class="na">left</span><span class="o">();</span>
                 <span class="k">break</span><span class="o">;</span>
 
             <span class="k">case</span> <span class="mi">1</span> <span class="o">:</span>
                 <span class="nc">Board</span><span class="o">.</span><span class="na">right</span><span class="o">();</span>
                 <span class="k">break</span><span class="o">;</span>
 
             <span class="k">case</span> <span class="mi">2</span> <span class="o">:</span>
                 <span class="nc">Board</span><span class="o">.</span><span class="na">up</span><span class="o">();</span>
                 <span class="k">break</span><span class="o">;</span>
 
             <span class="k">case</span> <span class="mi">3</span> <span class="o">:</span>
                 <span class="nc">Board</span><span class="o">.</span><span class="na">down</span><span class="o">();</span>
                 <span class="k">break</span><span class="o">;</span>
         <span class="o">}</span>
     <span class="o">}</span>
 
     <span class="kd">public</span> <span class="kd">static</span> <span class="nc">ArrayDeque</span><span class="o">&lt;</span><span class="nc">ArrayList</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;&gt;</span> <span class="nf">BFS</span><span class="o">()</span> <span class="o">{</span>
         <span class="kt">int</span><span class="o">[]</span> <span class="n">problemSpace</span> <span class="o">=</span> <span class="o">{</span><span class="mi">0</span><span class="o">,</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">3</span><span class="o">};</span>
         <span class="nc">ArrayDeque</span><span class="o">&lt;</span><span class="nc">ArrayList</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;&gt;</span> <span class="n">openList</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayDeque</span><span class="o">&lt;&gt;();</span>
         <span class="nc">ArrayDeque</span><span class="o">&lt;</span><span class="nc">ArrayList</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;&gt;</span> <span class="n">closedList</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayDeque</span><span class="o">&lt;&gt;();</span>
 
         <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">problemSpace</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
             <span class="kt">int</span> <span class="n">tempNode</span> <span class="o">=</span> <span class="n">problemSpace</span><span class="o">[</span><span class="n">i</span><span class="o">];</span>
             <span class="nc">ArrayList</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">tempArray</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;();</span>
             <span class="n">tempArray</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">tempNode</span><span class="o">);</span>
             <span class="n">openList</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">tempArray</span><span class="o">);</span>
         <span class="o">}</span>
 
         <span class="k">while</span> <span class="o">(</span><span class="kc">true</span><span class="o">)</span> <span class="o">{</span>
             <span class="k">if</span> <span class="o">(</span><span class="n">openList</span><span class="o">.</span><span class="na">size</span><span class="o">()</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
                 <span class="k">return</span> <span class="n">closedList</span><span class="o">;</span>
             <span class="o">}</span>
             <span class="k">else</span> <span class="o">{</span>
                 <span class="nc">ArrayList</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">selectedNode</span> <span class="o">=</span> <span class="n">openList</span><span class="o">.</span><span class="na">pollFirst</span><span class="o">();</span>
                 <span class="k">if</span> <span class="o">(</span><span class="n">selectedNode</span><span class="o">.</span><span class="na">size</span><span class="o">()</span> <span class="o">==</span> <span class="mi">5</span><span class="o">)</span> <span class="o">{</span>
                     <span class="n">closedList</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">selectedNode</span><span class="o">);</span>
                 <span class="o">}</span>
                 <span class="k">else</span> <span class="o">{</span>
                     <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">:</span> <span class="n">problemSpace</span><span class="o">)</span> <span class="o">{</span>
                         <span class="nc">ArrayList</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">clonedSelectedNode</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;(</span><span class="n">selectedNode</span><span class="o">);</span>
                         <span class="n">clonedSelectedNode</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">i</span><span class="o">);</span>
                         <span class="n">openList</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">clonedSelectedNode</span><span class="o">);</span>
                     <span class="o">}</span>
                 <span class="o">}</span>
             <span class="o">}</span>
         <span class="o">}</span>
     <span class="o">}</span>
 <span class="o">}</span>
 
 <span class="kd">class</span> <span class="nc">node</span> <span class="o">{</span>
 
     <span class="n">node</span><span class="o">[][]</span> <span class="n">model</span><span class="o">;</span>
     <span class="kt">int</span> <span class="n">value</span><span class="o">;</span>
     <span class="kt">int</span><span class="o">[]</span> <span class="n">coordinate</span><span class="o">;</span>
     <span class="kt">int</span> <span class="n">initialValue</span><span class="o">;</span>
     <span class="kt">boolean</span> <span class="n">concated</span><span class="o">;</span>
 <span class="c1">// 생성자임</span>
 
     <span class="kd">public</span> <span class="nf">node</span><span class="o">(</span><span class="kt">int</span> <span class="n">value</span><span class="o">,</span> <span class="kt">int</span><span class="o">[]</span> <span class="n">coordinate</span><span class="o">,</span> <span class="n">node</span><span class="o">[][]</span> <span class="n">model</span><span class="o">)</span> <span class="o">{</span>
         <span class="k">this</span><span class="o">.</span><span class="na">initialValue</span> <span class="o">=</span> <span class="n">value</span><span class="o">;</span>
         <span class="k">this</span><span class="o">.</span><span class="na">model</span> <span class="o">=</span> <span class="n">model</span><span class="o">;</span>
         <span class="k">this</span><span class="o">.</span><span class="na">value</span> <span class="o">=</span> <span class="n">value</span><span class="o">;</span>
         <span class="k">this</span><span class="o">.</span><span class="na">coordinate</span> <span class="o">=</span> <span class="n">coordinate</span><span class="o">;</span>
         <span class="k">this</span><span class="o">.</span><span class="na">model</span><span class="o">[</span><span class="n">coordinate</span><span class="o">[</span><span class="mi">0</span><span class="o">]][</span><span class="n">coordinate</span><span class="o">[</span><span class="mi">1</span><span class="o">]]</span> <span class="o">=</span> <span class="k">this</span><span class="o">;</span>
         <span class="k">this</span><span class="o">.</span><span class="na">concated</span> <span class="o">=</span> <span class="kc">false</span><span class="o">;</span>
     <span class="o">}</span>
     <span class="kd">public</span> <span class="kt">void</span> <span class="nf">concatedReset</span><span class="o">()</span> <span class="o">{</span>
         <span class="k">this</span><span class="o">.</span><span class="na">concated</span> <span class="o">=</span> <span class="kc">false</span><span class="o">;</span>
     <span class="o">}</span>
 
     <span class="kd">public</span> <span class="kt">void</span> <span class="nf">reset</span><span class="o">()</span> <span class="o">{</span>
         <span class="k">this</span><span class="o">.</span><span class="na">value</span> <span class="o">=</span> <span class="k">this</span><span class="o">.</span><span class="na">initialValue</span><span class="o">;</span>
     <span class="o">}</span>
 
     <span class="c1">// 그런데 그러면 board를 업데이트해야함</span>
     <span class="kd">public</span> <span class="kt">void</span> <span class="nf">leftMove</span><span class="o">()</span> <span class="o">{</span>
         <span class="k">if</span> <span class="o">(</span><span class="n">leftCheck</span><span class="o">()</span> <span class="o">==</span> <span class="mi">1</span><span class="o">){</span>
         
             <span class="c1">// 왼쪽으로 갈 수 있으면 왼쪽으로 감</span>
             <span class="c1">// this.coordinate[0] -= 1; &lt;&lt; 이런식으로 직접 노드를 옮겨서는 안 됨.</span>
             <span class="c1">// value를 좌측으로 옮기고 이 노드의 value는 0이 되어야 함.</span>
             <span class="c1">// 각 체크의 결과는 1 0 value의 값이 나옴, 1인 경우는 옮길 수 있고, 0인 경우는 못옮김</span>
             
             <span class="kt">int</span> <span class="n">temp</span> <span class="o">=</span> <span class="k">this</span><span class="o">.</span><span class="na">value</span><span class="o">;</span>
             <span class="k">this</span><span class="o">.</span><span class="na">value</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
             
             <span class="c1">// 이 노드의 값을 0으로 초기화하고</span>
             <span class="c1">// 좌측이므로</span>
             <span class="n">node</span> <span class="n">targetNode</span> <span class="o">=</span> <span class="k">this</span><span class="o">.</span><span class="na">model</span><span class="o">[</span><span class="k">this</span><span class="o">.</span><span class="na">coordinate</span><span class="o">[</span><span class="mi">0</span><span class="o">]][</span><span class="k">this</span><span class="o">.</span><span class="na">coordinate</span><span class="o">[</span><span class="mi">1</span><span class="o">]</span> <span class="o">-</span> <span class="mi">1</span><span class="o">];</span>
             <span class="c1">// 좌측 노드의 값을 이 노드의 값으로 치환함</span>
             <span class="n">targetNode</span><span class="o">.</span><span class="na">value</span> <span class="o">=</span> <span class="n">temp</span><span class="o">;</span>
             <span class="c1">// 그리고 그 노드가 왼쪽 끝까지 가야하기 때문에 연쇄적으로 leftMove콜을 함</span>
             <span class="n">targetNode</span><span class="o">.</span><span class="na">leftMove</span><span class="o">();</span>
         <span class="o">}</span>
         <span class="k">else</span> <span class="nf">if</span> <span class="o">(</span><span class="n">leftCheck</span><span class="o">()</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
         <span class="o">}</span>
         <span class="k">else</span> <span class="o">{</span>
             <span class="c1">// 만약 왼편에 존재하는 노드가 값을 가지고 있는 노드의 경우에는</span>
             <span class="c1">// &lt;&lt; 현재 노드의 값과 같으면 합쳐진다</span>
             <span class="n">node</span> <span class="n">targetNode</span> <span class="o">=</span> <span class="k">this</span><span class="o">.</span><span class="na">model</span><span class="o">[</span><span class="k">this</span><span class="o">.</span><span class="na">coordinate</span><span class="o">[</span><span class="mi">0</span><span class="o">]][</span><span class="k">this</span><span class="o">.</span><span class="na">coordinate</span><span class="o">[</span><span class="mi">1</span><span class="o">]</span> <span class="o">-</span> <span class="mi">1</span><span class="o">];</span>
             <span class="c1">// 만약 현재 노드의 값과 같아도 concated flag가 true 면 패스한다</span>
             <span class="k">if</span> <span class="o">(!</span><span class="n">targetNode</span><span class="o">.</span><span class="na">concated</span><span class="o">)</span> <span class="o">{</span>
                 <span class="k">if</span> <span class="o">(</span><span class="n">targetNode</span><span class="o">.</span><span class="na">value</span> <span class="o">==</span> <span class="k">this</span><span class="o">.</span><span class="na">value</span><span class="o">)</span> <span class="o">{</span>
                     <span class="n">targetNode</span><span class="o">.</span><span class="na">value</span> <span class="o">=</span> <span class="n">targetNode</span><span class="o">.</span><span class="na">value</span> <span class="o">*</span> <span class="mi">2</span><span class="o">;</span>
                     <span class="k">this</span><span class="o">.</span><span class="na">value</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
                     <span class="n">targetNode</span><span class="o">.</span><span class="na">concated</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
 
                     <span class="c1">// 보니까 한번만 합쳐지는것같음 모든 블록은 한번만 </span>
                     <span class="c1">// 합쳐져야하기때문에 합친 후에는 연쇄콜을 하면 안됨</span>
 <span class="c1">//                targetNode.leftMove();</span>
                 <span class="o">}</span>
             <span class="o">}</span>
         <span class="o">}</span>
     <span class="o">}</span>
     <span class="kd">public</span> <span class="kt">void</span> <span class="nf">rightMove</span><span class="o">()</span> <span class="o">{</span>
         <span class="c1">// leftMove와 작동방식이 같기 때문에 굳이 주석은 적지 않겠다</span>
         <span class="k">if</span> <span class="o">(</span><span class="n">rightCheck</span><span class="o">()</span> <span class="o">==</span> <span class="mi">1</span><span class="o">)</span> <span class="o">{</span>
             <span class="kt">int</span> <span class="n">temp</span> <span class="o">=</span> <span class="k">this</span><span class="o">.</span><span class="na">value</span><span class="o">;</span>
             <span class="n">node</span> <span class="n">targetNode</span> <span class="o">=</span> <span class="k">this</span><span class="o">.</span><span class="na">model</span><span class="o">[</span><span class="k">this</span><span class="o">.</span><span class="na">coordinate</span><span class="o">[</span><span class="mi">0</span><span class="o">]][</span><span class="k">this</span><span class="o">.</span><span class="na">coordinate</span><span class="o">[</span><span class="mi">1</span><span class="o">]</span> <span class="o">+</span> <span class="mi">1</span><span class="o">];</span>
             <span class="n">targetNode</span><span class="o">.</span><span class="na">value</span> <span class="o">=</span> <span class="n">temp</span><span class="o">;</span>
             <span class="k">this</span><span class="o">.</span><span class="na">value</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
             <span class="n">targetNode</span><span class="o">.</span><span class="na">rightMove</span><span class="o">();</span>
         <span class="o">}</span> <span class="k">else</span> <span class="k">if</span> <span class="o">(</span><span class="n">rightCheck</span><span class="o">()</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{}</span>
         <span class="k">else</span> <span class="o">{</span>
             <span class="n">node</span> <span class="n">targetNode</span> <span class="o">=</span> <span class="k">this</span><span class="o">.</span><span class="na">model</span><span class="o">[</span><span class="k">this</span><span class="o">.</span><span class="na">coordinate</span><span class="o">[</span><span class="mi">0</span><span class="o">]][</span><span class="k">this</span><span class="o">.</span><span class="na">coordinate</span><span class="o">[</span><span class="mi">1</span><span class="o">]</span> <span class="o">+</span> <span class="mi">1</span><span class="o">];</span>
             <span class="k">if</span> <span class="o">(!</span><span class="n">targetNode</span><span class="o">.</span><span class="na">concated</span><span class="o">)</span> <span class="o">{</span>
                 <span class="k">if</span> <span class="o">(</span><span class="n">targetNode</span><span class="o">.</span><span class="na">value</span> <span class="o">==</span> <span class="k">this</span><span class="o">.</span><span class="na">value</span><span class="o">)</span> <span class="o">{</span>
                     <span class="n">targetNode</span><span class="o">.</span><span class="na">value</span> <span class="o">=</span> <span class="n">targetNode</span><span class="o">.</span><span class="na">value</span> <span class="o">*</span> <span class="mi">2</span><span class="o">;</span>
                     <span class="k">this</span><span class="o">.</span><span class="na">value</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
                     <span class="n">targetNode</span><span class="o">.</span><span class="na">concated</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
 <span class="c1">//                targetNode.rightMove();</span>
                 <span class="o">}</span>
             <span class="o">}</span>
         <span class="o">}</span>
     <span class="o">}</span>
     <span class="kd">public</span> <span class="kt">void</span> <span class="nf">upMove</span><span class="o">()</span> <span class="o">{</span>
         <span class="k">if</span> <span class="o">(</span><span class="n">upCheck</span><span class="o">()</span> <span class="o">==</span> <span class="mi">1</span><span class="o">)</span> <span class="o">{</span>
             <span class="kt">int</span> <span class="n">temp</span> <span class="o">=</span> <span class="k">this</span><span class="o">.</span><span class="na">value</span><span class="o">;</span>
             <span class="n">node</span> <span class="n">targetNode</span> <span class="o">=</span> <span class="k">this</span><span class="o">.</span><span class="na">model</span><span class="o">[</span><span class="k">this</span><span class="o">.</span><span class="na">coordinate</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span> <span class="o">-</span> <span class="mi">1</span><span class="o">][</span><span class="k">this</span><span class="o">.</span><span class="na">coordinate</span><span class="o">[</span><span class="mi">1</span><span class="o">]];</span>
             <span class="n">targetNode</span><span class="o">.</span><span class="na">value</span> <span class="o">=</span> <span class="n">temp</span><span class="o">;</span>
             <span class="k">this</span><span class="o">.</span><span class="na">value</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
             <span class="n">targetNode</span><span class="o">.</span><span class="na">upMove</span><span class="o">();</span>
         <span class="o">}</span> <span class="k">else</span> <span class="k">if</span> <span class="o">(</span><span class="n">upCheck</span><span class="o">()</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{}</span>
         <span class="k">else</span> <span class="o">{</span>
             <span class="n">node</span> <span class="n">targetNode</span> <span class="o">=</span> <span class="k">this</span><span class="o">.</span><span class="na">model</span><span class="o">[</span><span class="k">this</span><span class="o">.</span><span class="na">coordinate</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span> <span class="o">-</span> <span class="mi">1</span><span class="o">][</span><span class="k">this</span><span class="o">.</span><span class="na">coordinate</span><span class="o">[</span><span class="mi">1</span><span class="o">]];</span>
             <span class="k">if</span> <span class="o">(!</span><span class="n">targetNode</span><span class="o">.</span><span class="na">concated</span><span class="o">)</span> <span class="o">{</span>
                 <span class="k">if</span> <span class="o">(</span><span class="n">targetNode</span><span class="o">.</span><span class="na">value</span> <span class="o">==</span> <span class="k">this</span><span class="o">.</span><span class="na">value</span><span class="o">)</span> <span class="o">{</span>
                     <span class="n">targetNode</span><span class="o">.</span><span class="na">value</span> <span class="o">=</span> <span class="n">targetNode</span><span class="o">.</span><span class="na">value</span> <span class="o">*</span> <span class="mi">2</span><span class="o">;</span>
                     <span class="k">this</span><span class="o">.</span><span class="na">value</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
                     <span class="n">targetNode</span><span class="o">.</span><span class="na">concated</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
 <span class="c1">//                targetNode.upMove();</span>
                 <span class="o">}</span>
             <span class="o">}</span>
         <span class="o">}</span>
     <span class="o">}</span>
     <span class="kd">public</span> <span class="kt">void</span> <span class="nf">downMove</span><span class="o">()</span> <span class="o">{</span>
 <span class="c1">//        downCheck는 0이면 움직일 수 없는 곳, 1이면 움직일 수 있는 곳,</span>
         <span class="k">if</span> <span class="o">(</span><span class="n">downCheck</span><span class="o">()</span> <span class="o">==</span> <span class="mi">1</span><span class="o">)</span> <span class="o">{</span>
             <span class="kt">int</span> <span class="n">temp</span> <span class="o">=</span> <span class="k">this</span><span class="o">.</span><span class="na">value</span><span class="o">;</span>
             <span class="n">node</span> <span class="n">targetNode</span> <span class="o">=</span> <span class="k">this</span><span class="o">.</span><span class="na">model</span><span class="o">[</span><span class="k">this</span><span class="o">.</span><span class="na">coordinate</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span> <span class="o">+</span> <span class="mi">1</span><span class="o">][</span><span class="k">this</span><span class="o">.</span><span class="na">coordinate</span><span class="o">[</span><span class="mi">1</span><span class="o">]];</span>
             <span class="n">targetNode</span><span class="o">.</span><span class="na">value</span> <span class="o">=</span> <span class="n">temp</span><span class="o">;</span>
             <span class="k">this</span><span class="o">.</span><span class="na">value</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
             <span class="n">targetNode</span><span class="o">.</span><span class="na">downMove</span><span class="o">();</span>
         <span class="o">}</span> <span class="k">else</span> <span class="k">if</span> <span class="o">(</span><span class="n">downCheck</span><span class="o">()</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{}</span>
 <span class="c1">//        1도 0도 아닌 정수값인경우</span>
         <span class="k">else</span> <span class="o">{</span>
             <span class="n">node</span> <span class="n">targetNode</span> <span class="o">=</span> <span class="k">this</span><span class="o">.</span><span class="na">model</span><span class="o">[</span><span class="k">this</span><span class="o">.</span><span class="na">coordinate</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span> <span class="o">+</span> <span class="mi">1</span><span class="o">][</span><span class="k">this</span><span class="o">.</span><span class="na">coordinate</span><span class="o">[</span><span class="mi">1</span><span class="o">]];</span>
             <span class="k">if</span> <span class="o">(!</span><span class="n">targetNode</span><span class="o">.</span><span class="na">concated</span><span class="o">)</span> <span class="o">{</span>
                 <span class="k">if</span> <span class="o">(</span><span class="n">targetNode</span><span class="o">.</span><span class="na">value</span> <span class="o">==</span> <span class="k">this</span><span class="o">.</span><span class="na">value</span><span class="o">)</span> <span class="o">{</span>
                     <span class="n">targetNode</span><span class="o">.</span><span class="na">value</span> <span class="o">=</span> <span class="n">targetNode</span><span class="o">.</span><span class="na">value</span> <span class="o">*</span> <span class="mi">2</span><span class="o">;</span>
                     <span class="k">this</span><span class="o">.</span><span class="na">value</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
                     <span class="n">targetNode</span><span class="o">.</span><span class="na">concated</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
 <span class="c1">//                targetNode.downMove();</span>
                 <span class="o">}</span>
             <span class="o">}</span>
         <span class="o">}</span>
 
     <span class="o">}</span>
     <span class="kd">public</span> <span class="kt">int</span> <span class="nf">leftCheck</span><span class="o">()</span> <span class="o">{</span>
         <span class="kt">int</span> <span class="n">xIndex</span> <span class="o">=</span> <span class="k">this</span><span class="o">.</span><span class="na">coordinate</span><span class="o">[</span><span class="mi">0</span><span class="o">];</span>
         <span class="kt">int</span> <span class="n">yIndex</span> <span class="o">=</span> <span class="k">this</span><span class="o">.</span><span class="na">coordinate</span><span class="o">[</span><span class="mi">1</span><span class="o">];</span>
         <span class="k">if</span> <span class="o">(</span><span class="n">yIndex</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
             <span class="k">return</span> <span class="mi">0</span><span class="o">;</span>
             <span class="c1">// 0 이면 불가능함</span>
         <span class="o">}</span>
         <span class="k">else</span> <span class="o">{</span>
             <span class="k">if</span> <span class="o">(</span><span class="k">this</span><span class="o">.</span><span class="na">model</span><span class="o">[</span><span class="n">xIndex</span><span class="o">][</span><span class="n">yIndex</span> <span class="o">-</span> <span class="mi">1</span><span class="o">].</span><span class="na">value</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
                 <span class="k">return</span> <span class="mi">1</span><span class="o">;</span>
                 <span class="c1">// 1이면 옮길 수 있음</span>
             <span class="o">}</span>
             <span class="k">else</span> <span class="o">{</span>
                 <span class="k">return</span> <span class="k">this</span><span class="o">.</span><span class="na">model</span><span class="o">[</span><span class="n">xIndex</span><span class="o">][</span><span class="n">yIndex</span> <span class="o">-</span> <span class="mi">1</span><span class="o">].</span><span class="na">value</span><span class="o">;</span>
                 <span class="c1">// 모두 아닌 경우에는 그 노드의 값을 리턴함</span>
             <span class="o">}</span>
         <span class="o">}</span>
     <span class="o">}</span>
     <span class="kd">public</span> <span class="kt">int</span> <span class="nf">rightCheck</span><span class="o">()</span> <span class="o">{</span>
         <span class="kt">int</span> <span class="n">xIndex</span> <span class="o">=</span> <span class="k">this</span><span class="o">.</span><span class="na">coordinate</span><span class="o">[</span><span class="mi">0</span><span class="o">];</span>
         <span class="kt">int</span> <span class="n">yIndex</span> <span class="o">=</span> <span class="k">this</span><span class="o">.</span><span class="na">coordinate</span><span class="o">[</span><span class="mi">1</span><span class="o">];</span>
         <span class="c1">// 문제 공간은 정사각형 형태이고 가장 오른쪽에 위치해 있을 때이고</span>
         <span class="c1">// length는 index보다 1높게 나오므로 1빼줘야함 ㅇㄱㄹㅇ</span>
         <span class="k">if</span> <span class="o">(</span><span class="n">yIndex</span> <span class="o">==</span> <span class="k">this</span><span class="o">.</span><span class="na">model</span><span class="o">[</span><span class="mi">0</span><span class="o">].</span><span class="na">length</span> <span class="o">-</span> <span class="mi">1</span><span class="o">)</span> <span class="o">{</span>
             <span class="k">return</span> <span class="mi">0</span><span class="o">;</span>
         <span class="o">}</span>
         <span class="k">else</span> <span class="o">{</span>
             <span class="k">if</span> <span class="o">(</span><span class="k">this</span><span class="o">.</span><span class="na">model</span><span class="o">[</span><span class="n">xIndex</span><span class="o">][</span><span class="n">yIndex</span> <span class="o">+</span> <span class="mi">1</span><span class="o">].</span><span class="na">value</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
                 <span class="c1">//오른쪽 노드가 공노드이면</span>
                 <span class="k">return</span> <span class="mi">1</span><span class="o">;</span>
             <span class="o">}</span>
             <span class="k">else</span> <span class="o">{</span>
                 <span class="k">return</span> <span class="k">this</span><span class="o">.</span><span class="na">model</span><span class="o">[</span><span class="n">xIndex</span><span class="o">][</span><span class="n">yIndex</span> <span class="o">+</span> <span class="mi">1</span><span class="o">].</span><span class="na">value</span><span class="o">;</span>
             <span class="o">}</span>
         <span class="o">}</span>
     <span class="o">}</span>
     <span class="kd">public</span> <span class="kt">int</span> <span class="nf">upCheck</span><span class="o">()</span> <span class="o">{</span>
         <span class="kt">int</span> <span class="n">xIndex</span> <span class="o">=</span> <span class="k">this</span><span class="o">.</span><span class="na">coordinate</span><span class="o">[</span><span class="mi">0</span><span class="o">];</span>
         <span class="kt">int</span> <span class="n">yIndex</span> <span class="o">=</span> <span class="k">this</span><span class="o">.</span><span class="na">coordinate</span><span class="o">[</span><span class="mi">1</span><span class="o">];</span>
         <span class="k">if</span> <span class="o">(</span><span class="n">xIndex</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
             <span class="c1">//위로 더 이상 올라갈 수 없으면</span>
             <span class="k">return</span> <span class="mi">0</span><span class="o">;</span>
         <span class="o">}</span>
         <span class="k">else</span> <span class="o">{</span>
             <span class="k">if</span> <span class="o">(</span><span class="k">this</span><span class="o">.</span><span class="na">model</span><span class="o">[</span><span class="n">xIndex</span> <span class="o">-</span> <span class="mi">1</span><span class="o">][</span><span class="n">yIndex</span><span class="o">].</span><span class="na">value</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
                 <span class="k">return</span> <span class="mi">1</span><span class="o">;</span>
             <span class="o">}</span>
             <span class="k">else</span> <span class="o">{</span>
                 <span class="k">return</span> <span class="k">this</span><span class="o">.</span><span class="na">model</span><span class="o">[</span><span class="n">xIndex</span> <span class="o">-</span> <span class="mi">1</span><span class="o">][</span><span class="n">yIndex</span><span class="o">].</span><span class="na">value</span><span class="o">;</span>
             <span class="o">}</span>
         <span class="o">}</span>
     <span class="o">}</span>
     <span class="cm">/**
      * 아래로 움직일 수 있는지 아닌지를 검사하는 함수임
      *
      * @return 아래로 움직일 수 있으면 0, 아래로 움직일 수 없으면 1, 다른 값이면 해당 노드의 값을 리턴
      */</span>
     <span class="kd">public</span> <span class="kt">int</span> <span class="nf">downCheck</span><span class="o">()</span> <span class="o">{</span>
         <span class="kt">int</span> <span class="n">xIndex</span> <span class="o">=</span> <span class="k">this</span><span class="o">.</span><span class="na">coordinate</span><span class="o">[</span><span class="mi">0</span><span class="o">];</span>
         <span class="kt">int</span> <span class="n">yIndex</span> <span class="o">=</span> <span class="k">this</span><span class="o">.</span><span class="na">coordinate</span><span class="o">[</span><span class="mi">1</span><span class="o">];</span>
         <span class="k">if</span> <span class="o">(</span><span class="n">xIndex</span> <span class="o">==</span> <span class="k">this</span><span class="o">.</span><span class="na">model</span><span class="o">[</span><span class="mi">0</span><span class="o">].</span><span class="na">length</span> <span class="o">-</span> <span class="mi">1</span><span class="o">)</span> <span class="o">{</span>
             <span class="c1">//아래로 더 이상 내려갈 수 없으면</span>
             <span class="k">return</span> <span class="mi">0</span><span class="o">;</span>
         <span class="o">}</span>
         <span class="k">else</span> <span class="o">{</span>
             <span class="k">if</span> <span class="o">(</span><span class="k">this</span><span class="o">.</span><span class="na">model</span><span class="o">[</span><span class="n">xIndex</span> <span class="o">+</span> <span class="mi">1</span><span class="o">][</span><span class="n">yIndex</span><span class="o">].</span><span class="na">value</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
                 <span class="k">return</span> <span class="mi">1</span><span class="o">;</span>
             <span class="o">}</span>
             <span class="k">else</span> <span class="o">{</span>
                 <span class="k">return</span> <span class="k">this</span><span class="o">.</span><span class="na">model</span><span class="o">[</span><span class="n">xIndex</span> <span class="o">+</span> <span class="mi">1</span><span class="o">][</span><span class="n">yIndex</span><span class="o">].</span><span class="na">value</span><span class="o">;</span>
             <span class="o">}</span>
         <span class="o">}</span>
     <span class="o">}</span>
 <span class="o">}</span>
 <span class="kd">class</span> <span class="nc">board</span> <span class="o">{</span>
     <span class="n">node</span><span class="o">[][]</span> <span class="n">model</span><span class="o">;</span>
 
     <span class="kd">public</span> <span class="nf">board</span><span class="o">(</span><span class="n">node</span><span class="o">[][]</span> <span class="n">inputModel</span><span class="o">)</span> <span class="o">{</span>
         <span class="c1">//정사각형이니까</span>
         <span class="k">this</span><span class="o">.</span><span class="na">model</span> <span class="o">=</span> <span class="n">inputModel</span><span class="o">;</span>
     <span class="o">}</span>
     <span class="kd">public</span> <span class="kt">void</span> <span class="nf">resetBoard</span><span class="o">()</span> <span class="o">{</span>
         <span class="k">for</span> <span class="o">(</span><span class="n">node</span><span class="o">[]</span> <span class="n">nodes</span> <span class="o">:</span> <span class="n">model</span><span class="o">)</span> <span class="o">{</span>
             <span class="k">for</span> <span class="o">(</span><span class="n">node</span> <span class="n">x</span> <span class="o">:</span> <span class="n">nodes</span><span class="o">)</span> <span class="o">{</span>
                 <span class="n">x</span><span class="o">.</span><span class="na">reset</span><span class="o">();</span>
             <span class="o">}</span>
         <span class="o">}</span>
     <span class="o">}</span>
 
     <span class="kd">public</span> <span class="kt">void</span> <span class="nf">printBoard</span><span class="o">()</span> <span class="o">{</span>
         <span class="k">for</span> <span class="o">(</span><span class="n">node</span><span class="o">[]</span> <span class="n">x</span> <span class="o">:</span> <span class="n">model</span><span class="o">)</span> <span class="o">{</span>
             <span class="k">for</span> <span class="o">(</span><span class="n">node</span> <span class="n">y</span> <span class="o">:</span> <span class="n">x</span><span class="o">)</span> <span class="o">{</span>
                 <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">printf</span><span class="o">(</span><span class="s">"%d "</span><span class="o">,</span> <span class="n">y</span><span class="o">.</span><span class="na">value</span><span class="o">);</span>
             <span class="o">}</span>
             <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">();</span>
         <span class="o">}</span>
     <span class="o">}</span>
 
     <span class="kd">public</span> <span class="kt">int</span> <span class="nf">getMaxNumber</span><span class="o">()</span> <span class="o">{</span>
         <span class="kt">int</span> <span class="n">maxNumber</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
         <span class="k">for</span> <span class="o">(</span><span class="n">node</span><span class="o">[]</span> <span class="n">x</span> <span class="o">:</span> <span class="n">model</span><span class="o">)</span> <span class="o">{</span>
             <span class="k">for</span> <span class="o">(</span><span class="n">node</span> <span class="n">y</span> <span class="o">:</span> <span class="n">x</span><span class="o">)</span> <span class="o">{</span>
                 <span class="k">if</span> <span class="o">(</span><span class="n">y</span><span class="o">.</span><span class="na">value</span> <span class="o">&gt;</span> <span class="n">maxNumber</span><span class="o">)</span> <span class="o">{</span>
                     <span class="n">maxNumber</span> <span class="o">=</span> <span class="n">y</span><span class="o">.</span><span class="na">value</span><span class="o">;</span>
                 <span class="o">}</span>
             <span class="o">}</span>
         <span class="o">}</span>
         <span class="k">return</span> <span class="n">maxNumber</span><span class="o">;</span>
     <span class="o">}</span>
 
     <span class="kd">public</span> <span class="kt">void</span> <span class="nf">setModel</span><span class="o">(</span><span class="n">node</span><span class="o">[][]</span> <span class="n">model</span><span class="o">)</span> <span class="o">{</span>
         <span class="k">this</span><span class="o">.</span><span class="na">model</span> <span class="o">=</span> <span class="n">model</span><span class="o">;</span>
     <span class="o">}</span>
     <span class="kd">public</span> <span class="n">node</span><span class="o">[][]</span> <span class="nf">getModel</span><span class="o">()</span> <span class="o">{</span>
         <span class="k">return</span> <span class="n">model</span><span class="o">;</span>
     <span class="o">}</span>
 
     <span class="cm">/**
      * 모든 노드에 대해서 왼쪽 명령을 내림
      */</span>
     <span class="kd">public</span> <span class="kt">void</span> <span class="nf">left</span><span class="o">()</span> <span class="o">{</span>
         <span class="c1">// 모든 노드에 대해서 왼쪽 노드로 이동</span>
         <span class="k">for</span> <span class="o">(</span><span class="n">node</span><span class="o">[]</span> <span class="n">x</span> <span class="o">:</span> <span class="n">model</span><span class="o">)</span> <span class="o">{</span>
             <span class="k">for</span> <span class="o">(</span><span class="n">node</span> <span class="n">y</span> <span class="o">:</span> <span class="n">x</span><span class="o">)</span> <span class="o">{</span>
                 <span class="n">y</span><span class="o">.</span><span class="na">leftMove</span><span class="o">();</span>
             <span class="o">}</span>
         <span class="o">}</span>
         <span class="c1">// 한번 움직임이 끝났으면 concated 플래그를 다시 reset 해야함</span>
         <span class="k">for</span> <span class="o">(</span><span class="n">node</span><span class="o">[]</span> <span class="n">x</span> <span class="o">:</span> <span class="n">model</span><span class="o">)</span> <span class="o">{</span>
             <span class="k">for</span> <span class="o">(</span><span class="n">node</span> <span class="n">y</span> <span class="o">:</span> <span class="n">x</span><span class="o">)</span> <span class="o">{</span>
                 <span class="n">y</span><span class="o">.</span><span class="na">concatedReset</span><span class="o">();</span>
             <span class="o">}</span>
         <span class="o">}</span>
     <span class="o">}</span>
     <span class="kd">public</span> <span class="kt">void</span> <span class="nf">right</span><span class="o">()</span> <span class="o">{</span>
         <span class="c1">// 모든 노드에 대해서 오른쪽 노드로 이동</span>
 <span class="c1">//        for (node[] x : model) {</span>
 <span class="c1">//            for (node y : x) {</span>
 <span class="c1">//                y.rightMove();</span>
 <span class="c1">//            }</span>
 <span class="c1">//        }</span>
         <span class="c1">// 근데 위의 left식으로 구현하면 안 됨, 왜냐하면 가장 오른편부터 합쳐져야 하기 때문임</span>
         <span class="kt">int</span> <span class="n">max</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="na">length</span> <span class="o">-</span> <span class="mi">1</span><span class="o">;</span>
         <span class="k">for</span> <span class="o">(</span><span class="n">node</span><span class="o">[]</span> <span class="n">x</span> <span class="o">:</span> <span class="n">model</span><span class="o">)</span> <span class="o">{</span>
             <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">max</span><span class="o">;</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span><span class="o">--)</span> <span class="o">{</span>
                 <span class="n">x</span><span class="o">[</span><span class="n">i</span><span class="o">].</span><span class="na">rightMove</span><span class="o">();</span>
             <span class="o">}</span>
         <span class="o">}</span>
         <span class="k">for</span> <span class="o">(</span><span class="n">node</span><span class="o">[]</span> <span class="n">x</span> <span class="o">:</span> <span class="n">model</span><span class="o">)</span> <span class="o">{</span>
             <span class="k">for</span> <span class="o">(</span><span class="n">node</span> <span class="n">y</span> <span class="o">:</span> <span class="n">x</span><span class="o">)</span> <span class="o">{</span>
                 <span class="n">y</span><span class="o">.</span><span class="na">concatedReset</span><span class="o">();</span>
             <span class="o">}</span>
         <span class="o">}</span>
     <span class="o">}</span>
     <span class="kd">public</span> <span class="kt">void</span> <span class="nf">up</span><span class="o">()</span> <span class="o">{</span>
         <span class="k">for</span> <span class="o">(</span><span class="n">node</span><span class="o">[]</span> <span class="n">x</span> <span class="o">:</span> <span class="n">model</span><span class="o">)</span> <span class="o">{</span>
             <span class="k">for</span> <span class="o">(</span><span class="n">node</span> <span class="n">y</span> <span class="o">:</span> <span class="n">x</span><span class="o">)</span> <span class="o">{</span>
                 <span class="n">y</span><span class="o">.</span><span class="na">upMove</span><span class="o">();</span>
             <span class="o">}</span>
         <span class="o">}</span>
         <span class="k">for</span> <span class="o">(</span><span class="n">node</span><span class="o">[]</span> <span class="n">x</span> <span class="o">:</span> <span class="n">model</span><span class="o">)</span> <span class="o">{</span>
             <span class="k">for</span> <span class="o">(</span><span class="n">node</span> <span class="n">y</span> <span class="o">:</span> <span class="n">x</span><span class="o">)</span> <span class="o">{</span>
                 <span class="n">y</span><span class="o">.</span><span class="na">concatedReset</span><span class="o">();</span>
             <span class="o">}</span>
         <span class="o">}</span>
     <span class="o">}</span>
     <span class="kd">public</span> <span class="kt">void</span> <span class="nf">down</span><span class="o">()</span> <span class="o">{</span>
 <span class="c1">//        for (node[] x : model) {</span>
 <span class="c1">//            for (node y : x) {</span>
 <span class="c1">//                y.downMove();</span>
 <span class="c1">//            }</span>
 <span class="c1">//        }</span>
 
         <span class="c1">// 근데 위의 down 식으로 구현하면 안 됨, 왜냐하면 가장 아래쪽부터 합쳐져야 하기 때문임니당</span>
         <span class="kt">int</span> <span class="n">max</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="na">length</span> <span class="o">-</span> <span class="mi">1</span><span class="o">;</span>
         <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">max</span><span class="o">;</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span><span class="o">--)</span> <span class="o">{</span>
             <span class="n">node</span><span class="o">[]</span> <span class="n">targetRow</span> <span class="o">=</span> <span class="n">model</span><span class="o">[</span><span class="n">i</span><span class="o">];</span>
             <span class="k">for</span> <span class="o">(</span><span class="n">node</span> <span class="n">x</span> <span class="o">:</span> <span class="n">targetRow</span><span class="o">)</span> <span class="o">{</span>
                 <span class="n">x</span><span class="o">.</span><span class="na">downMove</span><span class="o">();</span>
             <span class="o">}</span>
         <span class="o">}</span>
         <span class="k">for</span> <span class="o">(</span><span class="n">node</span><span class="o">[]</span> <span class="n">x</span> <span class="o">:</span> <span class="n">model</span><span class="o">)</span> <span class="o">{</span>
             <span class="k">for</span> <span class="o">(</span><span class="n">node</span> <span class="n">y</span> <span class="o">:</span> <span class="n">x</span><span class="o">)</span> <span class="o">{</span>
                 <span class="n">y</span><span class="o">.</span><span class="na">concatedReset</span><span class="o">();</span>
             <span class="o">}</span>
         <span class="o">}</span>
     <span class="o">}</span>
 <span class="o">}</span>
</code></pre></div></div>]]></content><author><name>ash tensor</name></author><category term="JAVA" /><category term="PS" /><category term="백준" /><summary type="html"><![CDATA[[백준][JAVA] 백준 12100번 :: 2048(Easy) :: 골드 2]]></summary></entry><entry><title type="html">[자격증] 리눅스 마스터 2급 2401회 합격 후기</title><link href="http://localhost:4000/%EC%9E%90%EA%B2%A9%EC%A6%9D/2024/03/28/linux-master.html" rel="alternate" type="text/html" title="[자격증] 리눅스 마스터 2급 2401회 합격 후기" /><published>2024-03-28T00:00:00+09:00</published><updated>2024-03-28T00:00:00+09:00</updated><id>http://localhost:4000/%EC%9E%90%EA%B2%A9%EC%A6%9D/2024/03/28/linux-master</id><content type="html" xml:base="http://localhost:4000/%EC%9E%90%EA%B2%A9%EC%A6%9D/2024/03/28/linux-master.html"><![CDATA[<h2 id="자격증-리눅스-마스터-2급-2401회-합격-후기--시험-정보">[자격증] 리눅스 마스터 2급 2401회 합격 후기 / 시험 정보</h2>

<h3 id="리눅스-마스터-2급">리눅스 마스터 2급</h3>

<p>2401회차 리눅스 마스터 2급 시험을 보고 합격했다. 온라인등에서 리눅스 마스터 2급은 이제 좀 누구나 합격하는 수준의 자격증이라는 느낌이지만,
내가 대신 약간의 변호를 하자면 평균 합격률이 약 30% 정도의 자격증으로 공부 하나도 필요 없이 하루 이틀 전에 공부해서 합격하는 수준은 아닌 것 같다. 
기사 수준의 시험도 합격률이 30%대인 시험도 많으니까 말이다. 그리고-</p>

<blockquote>
  <p>인터넷에서는 공부할 필요 없다, 하루 이틀 기출만 풀면 합격할 수 있다</p>
</blockquote>

<p>이런 말을 많이 하는데 이런 식의 말은 조금 무책임한 느낌이고, 혹시라도 누군가 이 시험을 도전할 사람이 있다면, 조금 더 차분히 공부해서 
기본적인 리눅스에 대한 지식을 어느정도 쌓고 가는 것이 좋다고 생각한다.</p>

<h4 id="시험-난이도">시험 난이도</h4>

<p>2022년 합격률은 약 22% 정도로, 2021년에 비해서는 하락했다. 2021년에는 약 30% 정도의 합격률이었는데, 2022년에는 22% 정도로 하락했다.
일단 리눅스 마스터 2급은 단순 암기 시험으로, 4지선다 80문제에 60점 이상 맞으면 합격인데…</p>

<p>말만 들으면 엄청 쉬운 시험이고 기출문제도 많이 있는 이상 기출을 많이 풀면 해결할 수 있다고 생각할 수 있지만 어려운 이유는 
문제가 꽤나 <strong>악의적으로</strong> 나온다는 점이다.</p>

<p>어떻게 예를 들어야 될지 잘 생각은 안나지만, 예를 들어서</p>

<ul>
  <li>리눅스 명령어 중에서 파일의 권한을 표시하는 문제가 출제되는데</li>
</ul>

<p>권한을 물어보다 보니까 “권한? chmod나 chown 인가?” 하고 생각하고 실제로 선지에도 그렇게 나오지만 실제로는 ls 라는 명령어를 선택해야한다. 
게다가, 그냥 ls 명령어를 실행하면 권한이 나오지 않고 옵션을 넣어서 검색해야 권한이 출력되고, 선지에도 ls 밖에는 표시되어 있지 않아서 사람을 헷갈리게 만든다.</p>

<ul>
  <li>또한 리눅스의 다양한 옵션들 (apt-get의 삭제 옵션이 -r인가 -R인가, e인가 d인가, 등)로 장난을 치는 것은 물론이다</li>
</ul>

<p>전부 다 생각나지는 않지만 꽤나 이렇듯 악의적인 문제가 많이 나온다. 게다가, 이제 2401회차와 전회차와 달라진 점으로는 더 이상 문제를 풀고
 문제지를 제공하지 않고 회수한다는 점에 있다. 이전에는 문제지를 제공하고 문제를 풀고 나서 문제지를 회수했기 때문에 기출문제를 
복원하기 쉬웠지만 이제부터는 기출문제를 복원하기가 어려워져서 앞으로의 난이도가 조금 더 어려워질 수 있다는 생각이 들었다.</p>

<p>그럼에도 불구하고, 쉬운 자격증인 건 맞다. 일단 계산문제가 나오지 않고, 단순히 리눅스 명령어를 많이 외우고, 리눅스에 대한 개념들만 머리속에
 정리해 가면 되기 때문에 어려운 자격증은 아니다. 그렇지만 단순히 기출문제를 암기하는 식으로 접근하기 보다는 리눅스에 대한 기본적인 지식을 쌓고 가는 것이 좋다.
그래야 남는 것도 있을테니까.</p>

<h4 id="공부법">공부법</h4>

<blockquote>
  <p>인터넷에 돌아다니는 리눅스 마스터 공부법에 대한 조언으로 기출문제 최대한 많이 풀기, 책은 살 필요 없음</p>
</blockquote>

<p>인데 책은 살 필요가 없는건 맞다…! 책은 살 필요가 없다. 그 이유는 어차피 위에서 말했듯, 단순 암기 시험이기도 하고, 문제가 악의적으로 나오기 때문에
 문제가 어떤 식으로 나오는지 감을 잡아야 하기 때문에 책을 사서 공부하는 것은 별로 의미가 없다고 생각한다. 오히려 책을 사서 공부하면 더 헷갈릴 수도 있다.
나는 밀리의 서재에 있는 리눅스 마스터 2급 책을 참고했는데, 솔직히 도움이 안 됐다… 오히려 기출문제와 인터넷에 돌아다니는 리눅스 마스터 2급 정리 PDF를 바탕으로
 내가 풀어본 기출문제에 새로 나왔거나, 개념이 어떻게 기출문제에 나오는지를 정리하면서 공부하는 것이 더 도움이 됐다.</p>

<p>음, 그런데 이제부터는 시험지를 나올때 제출하라고 하니까 기출문제를 복원하기가 어려워져서 앞으로는 기출문제를 풀어보는 것이 더 어려워질 수도 있다. 
왜냐면 나도 시험을 칠 때 기출문제에 안 나왔던 새로운 문제들이 보였기 때문이다. 그래서 혹시라도 책을 구매하려면 최신 기출문제가 수록되어있는
 책을 구매한다면, 그건 좋을 것 같다.</p>

<h4 id="마무리">마무리</h4>

<p>전공자 기준 약 2주 정도(암기를 못한다면) 시험 공부를 하는 게 좋을 것 같고, 비전공자 기준으로도 약 2주 정도 시험 공부를 하는 편이 좋다.
나는 기출문제 약 2년치 정도(8회분)를 1주일에 걸쳐서 풀고 정리하는 식으로 시험 공부를 하긴 했는데 시험 점수가 생각했던 것보다 아슬아슬하게 나와서(70점)
 떨어질 수도 있겠다 싶겠어서, 한 2주 정도는 차분히 공부하는 것이 좋을 것 같다.</p>

<p><img src="/img/posts/linuxmaster/1.png" style="width: 80%" /></p>

<p>아무튼 그래도 합격해서 다행이긴 하다! 떨어지는 것보다는 합격하는게 더 나으니까</p>]]></content><author><name>ash tensor</name></author><category term="자격증" /><summary type="html"><![CDATA[[자격증] 리눅스 마스터 2급 2401회 합격 후기 / 시험 정보]]></summary></entry><entry><title type="html">[데이터]개인정보 처리 위탁과 제 3자 제공의 차이</title><link href="http://localhost:4000/ml/2024/03/19/personal-information.html" rel="alternate" type="text/html" title="[데이터]개인정보 처리 위탁과 제 3자 제공의 차이" /><published>2024-03-19T00:00:00+09:00</published><updated>2024-03-19T00:00:00+09:00</updated><id>http://localhost:4000/ml/2024/03/19/personal-information</id><content type="html" xml:base="http://localhost:4000/ml/2024/03/19/personal-information.html"><![CDATA[<h2 id="데이터개인정보-처리-위탁과-제-3자-제공의-차이">[데이터]개인정보 처리 위탁과 제 3자 제공의 차이</h2>

<p>개인정보의 처리 위탁과 개인정보의 제 3자 제공은 언뜻 보면 비슷한 개념으로 보일 수 있지만, 실제로는 매우 다른 개념이다.
빅데이터분석기사나 보안 등의 과목에서 개인정보의 이전에 관련된 과목에서</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>개인정보의 처리 위탁은 개인정보처리자의 업무를 처리할 목적으로 제 3자에게 이전되는 것이다.
</code></pre></div></div>

<p>라고 설명하고, 개인정보의 제 3자 제공은</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>해당 정보를 제공받는 자의 고유한 업무를 처리할 목적 및 이익을 위하여 개인정보가 이전되는 것이다.
</code></pre></div></div>

<p>라고 설명하고 있다. 이 말만 들어서는 정확히 어떤 차이가 있는지 명확히 이해하기는 어렵다. 대법원에서는 개인정보의 처리위탁은 본래의 개인정보 수집 이용 목적과 관련된
 위탁자의 업무 처리와 이익을 위하여 개인정보가 이전되는 경우를 의미한다,고 판시한 적이 있다. 아니, 생각해보면 개인정보의 제 3자 제공이나 개인정보의 위탁이나
 어쨌든 회사에게 내 개인정보를 넘기는 것이고, 대법원이 판시한 것처럼, 중간에 있는 회사를 위해서 개인정보가 제공되는 것 같은데 왜 제 3자 제공과는 다른가? 라는 생각이 들 수 있다.</p>

<p>또한 문제에서는</p>

<ul>
  <li>해당 정보를 제공받는 자의 고유한 업무를 처리할 목적 및 이익을 위하여 개인정보가 이전되는 것이다.</li>
  <li>개인정보를 제공하는 자의 업무 처리와 이익을 위하는 경우이다.</li>
  <li>개인정보를 제공받는 자의 업무 처리와 이익을 위하는 경우이다.</li>
  <li>개인정보처리자의 업무를 처리할 목적으로 제 3자에게 이전되는 것이다.</li>
  <li>해당 정보를 제공받는 자의 고유한 업무를 처리할 목적 및 이익을 위하여 개인정보가 이전되는 것이다.</li>
</ul>

<p>등의 선지로 등장하기 때문에, 제대로 차이점을 이해하지 못했다면 헷갈릴 수가 있다. 그 이유는 해당 문장들에서 주어나 목적어등이 생략된 나머지 정보가 
완전하지 않기 때문이다.</p>

<h3 id="개인정보의-처리-위탁">개인정보의 처리 위탁</h3>

<p>개인정보의 처리 위탁은 개인정보처리자의 업무를 처리할 목적으로 제 3자에게 이전되는 것이다. 또한 위의 선지에서 골라보자면</p>

<ul>
  <li>개인정보를 제공하는 자의 업무 처리와 이익을 위하는 경우</li>
  <li>개인정보처리자의 업무를 처리할 목적으로 제 3자에게 이전되는 것이다.</li>
</ul>

<p>이렇게 고를 수 있다. 차이를 알기 위해서는 그림을 그려보면 간단하다.</p>

<p><img src="/img/posts/personal-information/1.png" width="80%" /></p>

<p>이러한 관계가 있다고 하자, 첫번째로 개인정보의 처리 위탁이 일어날 때, 위 관계는 다음과 같이 표현할 수 있다.</p>

<p><img src="/img/posts/personal-information/2.png" width="80%" /></p>

<p>개인정보의 처리 위탁은 본래의 개인정보 수집 이용 목적과 관련된 위탁자의 업무 처리와 이익을 위하여 개인정보가 이전되는 것이다. 
즉 위의 나왔던 선지와 문장의 이익은 개인정보를 제공한 자의 이익과 그 개인정보를 1차적으로 받고, 타 사에 위탁한 위탁자의 업무 처리와 관련된 이익을 말한다.</p>

<p>여기서 개인정보는 비즈니스를 수행하는데 필요한 정보여야만 하고, 이를 최종적으로 마지막에 위탁받은 자 역시, 그 개인정보를 자신의 이익을 위하여 사용해서는 안 된다.</p>

<p>따라서 위 문장들 중에서 개인정보를 제공받는 자의 고유한 업무를 처리할 목적 및 이익을 위하여 개인정보가 이전되는 것이다 « 이 문장은 개인정보 위탁이 아닌 개인정보 제 3자 제공에 관련된 문장이 된다.
왜냐하면 택배를 예시로 들어보자, 분명 이렇게 생각할 수 있다. 택배 회사에 개인정보를 제공한다고 했을 때, 택배 회사의 업무를 위해서 개인정보를 제공하는 것이니까 택배회사의 고유한 업무를 수행하기 때문에 제 3자 제공이다. 이렇게 생각할 수도 있지만
 사실 택배 회사의 업무는 특정 쇼핑몰의 요청에 따라 사용자에게 물건을 배송하는 것이고, 이는 특정 쇼핑몰의 비즈니스의 일부분인 것이고, 택배 회사의 고유한 업무를 처리할 목적으로 개인정보를 사용하는 것은 아니다.</p>

<p>이러한 경우에는 정보를 다루는 주체가 정보를 어떻게 이용할지 예측이 가능하기 때문에 관리 감독 의무는 위탁자(중간에 끼어있는 회사)에게 존재하고, 손해배상의 책임은 위탁자 및 수탁자가 공통으로 부담한다.</p>

<h3 id="개인정보의-제-3자-제공">개인정보의 제 3자 제공</h3>

<p><img src="/img/posts/personal-information/3.png" width="80%" /></p>

<p>개인정보의 제 3자 제공은 해당 정보를 제공받는 자의 고유한 업무를 처리할 목적 및 이익을 위하여 개인정보가 이전되는 것이다. 이걸 보면 개인정보 위탁과는 다르다는 점이 이해가 확 될 것이다.
위 그림에서 확인할 수 있는 것과 같이, 중간의 회사가 누군가에게 개인정보 제 3자 제공을 한다면, 그건 중간의 회사와 고객간의 비즈니스와는 관련이 없는,
그냥 개인정보를 제공할 뿐인 것이다. 즉, 광고 전화나 판촉 전화, 개인정보 판매와 같은 일이 일어난다는 것이다. 이는 개인정보를 최초에 제공한 고객의 이익과는 아무런 관련이 없다. 또한 중간에 존재하는 회사와 고객간의 비즈니스에는 
아무런 관련이 없다. 오직 제 3자의 회사의 특정한 이익과 업무를 위해 사용될 뿐인 것이다.</p>

<p>이러한 경우에는 제공자가 정보가 어떻게 이용될지 예측이 알 수 없고 개인정보의 제 3자의 이익을 위해 사용되기 때문에, 관리 감독 의무나 손해배상 책임이 제 3자에게 존재한다.</p>]]></content><author><name>ash tensor</name></author><category term="ML" /><summary type="html"><![CDATA[[데이터]개인정보 처리 위탁과 제 3자 제공의 차이]]></summary></entry><entry><title type="html">[후기] 알리익스프레스 SD카드 배송 후기 / 용량 뻥튀기 확인하는법</title><link href="http://localhost:4000/%EB%A6%AC%EB%B7%B0/2024/03/06/sd-card.html" rel="alternate" type="text/html" title="[후기] 알리익스프레스 SD카드 배송 후기 / 용량 뻥튀기 확인하는법" /><published>2024-03-06T00:00:00+09:00</published><updated>2024-03-06T00:00:00+09:00</updated><id>http://localhost:4000/%EB%A6%AC%EB%B7%B0/2024/03/06/sd-card</id><content type="html" xml:base="http://localhost:4000/%EB%A6%AC%EB%B7%B0/2024/03/06/sd-card.html"><![CDATA[<h2 id="후기-알리익스프레스-sd카드-배송-리뷰">[후기] 알리익스프레스 SD카드 배송 리뷰</h2>

<p>최근 알리익스프레스에서 SD카드를 주문했다. 왜냐하면, 라즈베리파이를 웹 데이터베이스로 사용하고 싶었는데, 그러기 위해서는 SD카드가 필요했기 때문이다.
기본적으로 라즈베리파이나 오렌지파이 같은 원보드 컴퓨터들은 저장공간으로 SD카드를 사용하고, 부트로더도 SD카드를 사용하기 때문에, 한번 키기 위해서라도 SD카드가 필수적이다.</p>

<p>아무래도 웹 데이터베이스로 사용할 것이기 때문에 큰 용량이 필요했고, 256GB SD카드를 주문했다.</p>

<p><img src="/img/posts/sdcard/1.png" width="80%" /></p>

<p>이게 모든 문제의 시작이었다.</p>

<h3 id="문제-설명">문제 설명</h3>

<p>알리익스프레스에서 저장장치를 사지 말라고 하는건 굉장히 널리 퍼진 조언이지만, 예전에 SSD를 저렴하게 구매한 적이 있는데, 그 SSD는 아무런 문제 없이 작동했고,
꽤나 성능도 괜찮았기 때문에 “설마 SSD도 제대로 오는데 SD카드가 제대로 오지 않겠어?” 라고 생각했기 때문이다…</p>

<p>그때 500GB SSD를 2만원 안 되게 산 것 같은데, 이번 SD카드도 1만원 좀 안 되길래 용량 뻥튀기나 사기가 아니지 않을까? 라는 헛된 생각이 있었고,
그리고 AliExpress Choice 라는 딱지가 붙어 있었기 때문에, 뭔가 나에게 약간의 신뢰감을 줬다. 그래서 구매했지만…</p>

<h3 id="와-실제-사용할-수-있는-용량은-500메가도-안-돼">와 실제 사용할 수 있는 용량은 500메가도 안 돼?</h3>

<p>SD카드를 받고, 라즈베리파이 운영체제 이미지를 굽기 위해서 balenaEtcher를 이용해서 깔기 시작했는데 초기 500메가 정도만 인스톨되고 그 이후에는 초당 0.3메가 정도로 떨어지더니 
전부 인스톨되는데 예상시간이 하염없이 길어지기 시작했다. 여기서 눈치챘다. 아, 내가 당했구나 라고…</p>

<p>이런 경우에 사용할 수 있는 프로그램으로 <strong>H2testw</strong> 라는 프로그램이 있다. 이 프로그램은 SD카드의 실제 용량을 확인할 수 있는 프로그램이다. 더미 파일을 만들고, 그 파일을 validate하는 방식으로 용량을 확인한다.
그래서 확인해 본 결과…</p>

<p><img src="/img/posts/sdcard/2.png" width="80%" /></p>

<p>실제 사용할 수 있는 용량은 500메가 정도 밖에는 안 되고, 나머지는 전부 오류가 나는 모습을 확인할 수 있다. 
게다가 악질인 건, SD 카드의 모습이 마치 SanDisk 제품인 것처럼 래핑을 해 놓은 모습인데(실제로는 SanDian 으로 적혀있다..) 이런 가짜 SSD 카드가 알리 익스프레스에
널려 있다는 것이다.</p>

<ol>
  <li>이렇게 SanDian과 같이 이미 존재하는 브랜드를 흉내내는 경우</li>
  <li>그리고 레노버 SD카드라고 판매하는 제품이 있는데 « 레노버는 SD카드를 판매하지 않는다고 하니까 의심해 볼만 하다.</li>
  <li>용량에 비해 가격이 너무 저렴한 경우</li>
</ol>

<p>에는 의심을 해야 할 것 같다.</p>

<p>환불 받고 싶지만 환불하기까지의 과정이 너무 복잡하고, 고객센터 및 판매자와의 소통이 너무 어려워서 그냥 포기하고, 다시 SD카드를 구매하기로 했다.
쿠팡에서 삼성 SD 카드로..</p>]]></content><author><name>ash tensor</name></author><category term="리뷰" /><summary type="html"><![CDATA[[후기] 알리익스프레스 SD카드 배송 리뷰]]></summary></entry><entry><title type="html">[DB] 구체화된 뷰는 테이블과 어떻게 다를까?</title><link href="http://localhost:4000/db/2024/02/29/materialized-view.html" rel="alternate" type="text/html" title="[DB] 구체화된 뷰는 테이블과 어떻게 다를까?" /><published>2024-02-29T00:00:00+09:00</published><updated>2024-02-29T00:00:00+09:00</updated><id>http://localhost:4000/db/2024/02/29/materialized-view</id><content type="html" xml:base="http://localhost:4000/db/2024/02/29/materialized-view.html"><![CDATA[<h2 id="db-물리-뷰는-테이블과-어떻게-다를까">[DB] 물리 뷰는 테이블과 어떻게 다를까?</h2>

<h3 id="문제-설명">문제 설명</h3>

<p>테이블은 데이터베이스의 기본적인 저장 단위로, 행과 열로 구성되어 있고, 실제로 데이터를 저장한다. 그리고 뷰는 실제 데이터를 저장하지 않는다.
뷰는 하나 이상의 테이블을 가상의 테이블처럼 보이게 하는 것이다. 
뷰는 쿼리를 이용해서 생성되며, 실제 데이터를 저장하지는 않고, 데이터에 대한 참조만을 저장한다.</p>

<p>이는 일반적인 논리적 뷰의 설명이다. 그렇다면 물리적 뷰는 테이블과 어떻게 다를까?</p>

<h3 id="물리적-뷰--구체화된-뷰">물리적 뷰 / 구체화된 뷰</h3>

<p>“물리적 뷰는 테이블과 어떻게 다르지?” 라는 질문을 받았는데, 대답을 하지 못해서 당황했었다. 왜냐하면, 물리 뷰라는 이름에서 다가오는 늬앙스가 
뷰라는 실체가 없고 가상의 테이블이라는 늬앙스와는 다르게 느껴졌기 때문이다.</p>

<p>뷰는 실제 데이터를 저장하지 않는데, 물리 뷰라고? 그렇다면 Physical view라는 말인가? 그럼 피지컬한 실체가 있는 건가? 이런 식으로 생각이 흘러갔기 때문이다.
하지만 물리적 뷰, 즉 materialized view는 이런 개념과는 거리가 있다.</p>

<p>물리적 뷰는 뷰와는 다르게 실제 데이터를 저장한다. 뷰는 쿼리를 이용하여 생성되며, 실제 데이터를 저장하지 않는다. 하지만 물리적 뷰는 쿼리를 이용하여 생성되며, 실제 데이터를 저장한다.
일반적인 뷰와는 다르게, 물리적 뷰는 DB상에 그 실체가 있다.</p>

<p>그렇다면 정말로, 테이블이라고 할 수 있을 것이다. 그렇다면 물리적 뷰는 테이블과 어떻게 다를까?</p>

<h3 id="물리적-뷰는-새로운-데이터를-저장하는-것이-아니라-기존의-데이터를-저장한다">물리적 뷰는 새로운 데이터를 저장하는 것이 아니라, 기존의 데이터를 저장한다.</h3>

<p>그러니까 즉, 물리적 뷰는 이미 존재하는 데이터를 이용해서, 일정부분 가공하고, 필터링된 데이터를 저장한다고 볼 수 있다. 새로운 데이터를 저장하는 테이블과는 거리가 있다. 정규화가 잘 된 테이블이 존재한다고 해 보자. 그런 경우에는 
사업 또는 비즈니스 사이클에 필요한 데이터를 얻는다고 할 때, 정규화된 여러 테이블을 조인해야만 필요한 데이터를 얻어야 하는 경우가 많다.</p>

<p>하지만 이런 경우에는 데이터를 조회할 때마다 계속 조인이 발생하고, 매번 쿼리할 때마다 계산이 필요해진다. 이런 경우에는 정규화가 잘 된 테이블이지만 오히려 서비스의 성능을 낮출 수 있다.</p>

<h3 id="반정규화">반정규화?</h3>

<p>아마 DB이론을 공부한 사람이라면 이 경우에 바로 반정규화를 떠올릴 것이다. 중복 테이블을 생성하거나, 중복 컬럼 생성, 테이블 병합 등, 여러 방법이 존재하지만 이 경우에 DB의 무결성이 깨지게 되고, 이는 
시스템의 안정성을 해칠 수 있다. 반정규화에 대한 대안으로 물리적 뷰를 사용할 수 있다.</p>

<p>물리적 뷰, 구체화된 뷰는 특정 쿼리의 결과를 데이터베이스에 물리적 실체로 저장하고, 뷰에 엑세스 할 때마다 
복잡한 쿼리(JOIN, GROUP BY, ORDER BY 등)를 실행하지 않고, 저장된 결과를 단순히 조회함으로써 성능을 향상시킬 수 있다.</p>

<h3 id="예제">예제</h3>

<p>아래 쿼리는 sales 테이블에서 sale_date를 기준으로 월별 매출 합계를 계산하여 
monthly_sales_summary 매터리얼라이즈드 뷰를 생성한다. 
이제 이 매터리얼라이즈드 뷰를 사용하여 월별 매출에 대한 정보를 조회 한 번으로 얻을 수 있다.</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="c1">-- 매터리얼라이즈드 뷰 생성 쿼리</span>
<span class="k">CREATE</span> <span class="n">MATERIALIZED</span> <span class="k">VIEW</span> <span class="n">monthly_sales_summary</span> <span class="k">AS</span>
<span class="k">SELECT</span>
    <span class="k">EXTRACT</span><span class="p">(</span><span class="nb">YEAR</span> <span class="k">FROM</span> <span class="n">sale_date</span><span class="p">)</span> <span class="k">AS</span> <span class="n">sale_year</span><span class="p">,</span>
    <span class="k">EXTRACT</span><span class="p">(</span><span class="k">MONTH</span> <span class="k">FROM</span> <span class="n">sale_date</span><span class="p">)</span> <span class="k">AS</span> <span class="n">sale_month</span><span class="p">,</span>
    <span class="k">SUM</span><span class="p">(</span><span class="n">amount</span><span class="p">)</span> <span class="k">AS</span> <span class="n">total_sales</span>
<span class="k">FROM</span>
    <span class="n">sales</span>
<span class="k">GROUP</span> <span class="k">BY</span>
    <span class="k">EXTRACT</span><span class="p">(</span><span class="nb">YEAR</span> <span class="k">FROM</span> <span class="n">sale_date</span><span class="p">),</span>
    <span class="k">EXTRACT</span><span class="p">(</span><span class="k">MONTH</span> <span class="k">FROM</span> <span class="n">sale_date</span><span class="p">);</span>

</code></pre></div></div>

<p>다음은 매터리얼라이즈드 뷰 새로고침 명령이다. 이 명령은 매터리얼라이즈드 뷰의 데이터를 새로 고쳐서 최신 데이터로 업데이트한다.</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="n">REFRESH</span> <span class="n">MATERIALIZED</span> <span class="k">VIEW</span> <span class="n">monthly_sales_summary</span><span class="p">;</span>

</code></pre></div></div>

<h3 id="dbms-별-구체화된-뷰-지원">DBMS 별 구체화된 뷰 지원</h3>

<p>구체화된 뷰는 DBMS에 따라 지원 여부가 다르다. MYSQL은 지원하지 않는다. 오라클은 지원한다. 오라클은 보통 자동으로 새로 고치지만,
수동으로 새로고침을 할 수도 있다. SQL Server는 Indexed View라는 이름으로 지원한다.</p>]]></content><author><name>ash tensor</name></author><category term="DB" /><summary type="html"><![CDATA[[DB] 물리 뷰는 테이블과 어떻게 다를까?]]></summary></entry><entry><title type="html">[JAVA] 배열에서는 왜 contains() 메소드가 제대로 작동하지 않을까?</title><link href="http://localhost:4000/java/2024/02/28/java-contain.html" rel="alternate" type="text/html" title="[JAVA] 배열에서는 왜 contains() 메소드가 제대로 작동하지 않을까?" /><published>2024-02-28T00:00:00+09:00</published><updated>2024-02-28T00:00:00+09:00</updated><id>http://localhost:4000/java/2024/02/28/java-contain</id><content type="html" xml:base="http://localhost:4000/java/2024/02/28/java-contain.html"><![CDATA[<h2 id="java-배열에서는-왜-contains-메소드가-제대로-작동하지-않을까">[JAVA] 배열에서는 왜 contains() 메소드가 제대로 작동하지 않을까?</h2>

<h3 id="문제-설명">문제 설명</h3>

<p>자바의 contain() 메소드는 배열에서 제대로 작동하지 않는다. 다시 말하면, 예를 들어서 ArrayList에 int[] 타입의 배열을 넣고, contains() 메소드를 사용하여 같은 값을 가진 배열을 찾아내는 것이 불가능하다.
하지만 ArrayList에 Integer 타입의 배열을 넣고, contains() 메소드를 사용하여 같은 값을 가진 배열을 찾아내는 것은 가능하다.
분명 contains() 메소드도 eqauls() 메소드를 사용하여 값을 비교하도록 되어있는데, ArrayList<Integer>의 경우에는 가능하고, int[]의 경우에는 불가능하다.</Integer></p>

<p>왜 가능할까?</p>

<h4 id="배열의-경우">배열의 경우</h4>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="kn">package</span> <span class="nn">boj</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">java.util.ArrayList</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.Arrays</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.List</span><span class="o">;</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">equal_test</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
    
    <span class="c1">// 테스트용 ArrayList 생성</span>
        <span class="nc">ArrayList</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">[]&gt;</span> <span class="n">testArrayList</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;();</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">targetIntArray</span> <span class="o">=</span> <span class="o">{</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">};</span>

        <span class="n">testArrayList</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">targetIntArray</span><span class="o">);</span>
        <span class="kt">boolean</span> <span class="n">question1</span> <span class="o">=</span> <span class="n">testArrayList</span><span class="o">.</span><span class="na">contains</span><span class="o">(</span><span class="n">targetIntArray</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">question1</span><span class="o">);</span>
        <span class="c1">// true 출력</span>

        <span class="c1">// 같은 값을 가진 배열을 생성하여 contains() 메소드를 사용</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">sameValueArray</span> <span class="o">=</span> <span class="o">{</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">};</span>
        <span class="kt">boolean</span> <span class="n">question2</span> <span class="o">=</span> <span class="n">testArrayList</span><span class="o">.</span><span class="na">contains</span><span class="o">(</span><span class="n">sameValueArray</span><span class="o">);</span>
        
        <span class="c1">// false 출력</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">question2</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>

</code></pre></div></div>

<p><img src="/img/posts/JAVA/equals/2.png" style="display: block; margin-left: auto; margin-right: auto; width: 100%" /></p>

<p>아마 감이 좋다면 String에서 == 연산자와 equals() 메소드의 차이점을 떠올리며 감을 잡을 수 있을 것이다. String의 경우에는 == 연산자를 사용하여 두 String의 주소를 비교하고, equals() 메소드를 사용하여 두 String의 값을 비교했었다.
contain() 역시 equal() 메소드를 사용한다. 그렇다면 왜 같은 값을 가진 배열을 찾아내지 못할까?</p>

<p>위 코드의 예시를 통해 확인할 수 있듯, 배열의 경우 contains() 메소드를 사용하여 같은 값을 가진 배열을 찾아내는 것이 불가능하다. 디버거를 이용해서 주소를 확인해 보면 다음과 같은데
배열 변수의 주소가 다른 것을 확인할 수 있다. 하지만 배열 변수의 주소가 다르기 때문에 false를 반환하는 것이 아니다. ArrayList의 equals() 메소드는 단순히 배열 변수의 주소만을 비교하지는 않는다. 이는 다음 코드를 확인하면 더욱 명확해진다.</p>

<h4 id="arraylist-의-경우">ArrayList<Integer> 의 경우</Integer></h4>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="kn">package</span> <span class="nn">boj</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">java.util.ArrayList</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.Arrays</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.List</span><span class="o">;</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">equal_test</span> <span class="o">{</span>
<span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
    
    <span class="c1">// 테스트용 ArrayList 생성</span>
        <span class="nc">ArrayList</span><span class="o">&lt;</span><span class="nc">ArrayList</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;&gt;</span> <span class="n">testArrayList</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;();</span>

    <span class="c1">// ArrayList에 Integer 타입의 ArrayList를 넣음</span>
        <span class="nc">ArrayList</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">targetIntArrayList</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;();</span>
        <span class="n">targetIntArrayList</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="mi">1</span><span class="o">);</span>
        <span class="n">targetIntArrayList</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="mi">2</span><span class="o">);</span>
        <span class="n">testArrayList</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">targetIntArrayList</span><span class="o">);</span>
        
        <span class="kt">boolean</span> <span class="n">question1</span> <span class="o">=</span> <span class="n">testArrayList</span><span class="o">.</span><span class="na">contains</span><span class="o">(</span><span class="n">targetIntArrayList</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">question1</span><span class="o">);</span>
    <span class="c1">// true 출력</span>

        <span class="nc">ArrayList</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">sameValueArray</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;();</span>
        
    <span class="c1">// 같은 값을 가진 ArrayList를 생성하여 contains() 메소드를 사용</span>
        <span class="n">sameValueArray</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="mi">1</span><span class="o">);</span>
        <span class="n">sameValueArray</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="mi">2</span><span class="o">);</span>
        <span class="kt">boolean</span> <span class="n">question2</span> <span class="o">=</span> <span class="n">testArrayList</span><span class="o">.</span><span class="na">contains</span><span class="o">(</span><span class="n">sameValueArray</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">question2</span><span class="o">);</span>
    <span class="c1">// true 출력</span>
    <span class="o">}</span>
<span class="o">}</span>

</code></pre></div></div>

<p>위 코드를 실행해 보면 알 수 있듯, 배열과는 달리, 같은 값을 가진 ArrayList<Integer> 의 경우에는 둘 다 true를 반환하는 것을 확인할 수 있다. 하지만 이를 디버거로 확인해 보면, 두 ArrayList<Integer>의 
주소는 다르다. 그런데도 불구하고, contains() 메소드는 두 ArrayList<Integer>의 값을 비교하여 같은 값을 가진 것으로 판단한다.</Integer></Integer></Integer></p>

<p><img src="/img/posts/JAVA/equals/4.png" style="display: block; margin-left: auto; margin-right: auto; width: 100%" /></p>

<p>이는 ArrayList<Integer>의 경우에, int 값이 아닌 Integer 객체를 비교하기 때문이다. 위 사진을 보면 코드상에서는 분명, 둘 다 각각 int(1, 2)를 집어넣었는데도 불구하고
Integer 객체의 경우에 두 ArrayList 모두 똑같은 객체의 Integer 객체를 가리키고 있는 것을 확인할 수 있다. 이 이전의 배열 사진을 확인해 보면 각각의 int는 다른 객체를 가리키고 있는 것을 확인할 수 있다.
자바에서 기본 자료형 (int, char 등)은 객체로 취급받지 않고 특정한 값으로 취급받는다. 하지만 Integer, Character 등은 객체로 취급받고, java의 Heap 영역에 적재되어 있다. 
따라서 아무리 많은 Integer, Character, String 등의 객체를 사용하더라도, 같은 값을 가지고 있으면 같은 주소를 가지는 동일한 객체를 가리키고 있는 것이다.</Integer></p>

<p>또한 ArrayList<Integer>의 경우에는 equals() 메소드를 사용하여 두 객체의 값을 비교한다. equals() 메소드는 객체의 값을 비교하기 위해 equals() 메소드를 오버라이딩하여 사용한다.</Integer></p>

<p>그래서 ArrayList<Integer>의 경우에는 contains() 메소드를 사용하여 같은 값을 가진 객체를 찾아낼 수 있다!!</Integer></p>]]></content><author><name>ash tensor</name></author><category term="JAVA" /><summary type="html"><![CDATA[[JAVA] 배열에서는 왜 contains() 메소드가 제대로 작동하지 않을까?]]></summary></entry><entry><title type="html">[백준] 백준 1743번 :: 음식물 피하기 :: 실버 1</title><link href="http://localhost:4000/%EB%B0%B1%EC%A4%80/ps/java/%ED%8C%8C%EC%9D%B4%EC%8D%AC/2024/02/27/boj1743.html" rel="alternate" type="text/html" title="[백준] 백준 1743번 :: 음식물 피하기 :: 실버 1" /><published>2024-02-27T00:00:00+09:00</published><updated>2024-02-27T00:00:00+09:00</updated><id>http://localhost:4000/%EB%B0%B1%EC%A4%80/ps/java/%ED%8C%8C%EC%9D%B4%EC%8D%AC/2024/02/27/boj1743</id><content type="html" xml:base="http://localhost:4000/%EB%B0%B1%EC%A4%80/ps/java/%ED%8C%8C%EC%9D%B4%EC%8D%AC/2024/02/27/boj1743.html"><![CDATA[<h2 id="백준-백준-1743번--음식물-피하기--실버-1">[백준] 백준 1743번 :: 음식물 피하기 :: 실버 1</h2>

<h3 id="문제-설명">문제 설명</h3>

<p>코레스코 콘도미니엄 8층은 학생들이 3끼의 식사를 해결하는 공간이다. 그러나 몇몇 비양심적인 학생들의 만행으로 음식물이 통로 중간 중간에 떨어져 있다. 이러한 음식물들은 근처에 있는 것끼리 뭉치게 돼서 큰 음식물 쓰레기가 된다.</p>

<p>이 문제를 출제한 선생님은 개인적으로 이러한 음식물을 실내화에 묻히는 것을 정말 진정으로 싫어한다. 참고로 우리가 구해야 할 답은 이 문제를 낸 조교를 맞추는 것이 아니다.</p>

<p>통로에 떨어진 음식물을 피해가기란 쉬운 일이 아니다. 따라서 선생님은 떨어진 음식물 중에 제일 큰 음식물만은 피해 가려고 한다.</p>

<p>선생님을 도와 제일 큰 음식물의 크기를 구해서 “10ra”를 외치지 않게 도와주자.</p>

<p><strong>입력</strong></p>

<p>첫째 줄에 통로의 세로 길이 N(1 ≤ N ≤ 100)과 가로 길이 M(1 ≤ M ≤ 100) 그리고 음식물 쓰레기의 개수 K(1 ≤ K ≤ N×M)이 주어진다.  그리고 다음 K개의 줄에 음식물이 떨어진 좌표 (r, c)가 주어진다.</p>

<p>좌표 (r, c)의 r은 위에서부터, c는 왼쪽에서부터가 기준이다. 입력으로 주어지는 좌표는 중복되지 않는다.</p>

<p><strong>출력</strong></p>

<p>첫째 줄에 음식물 중 가장 큰 음식물의 크기를 출력하라.</p>

<h3 id="제한시간">제한시간</h3>

<p>2 초	256 MB</p>

<h3 id="예제-입력">예제 입력</h3>

<p>3 4 5</p>

<p>3 2</p>

<p>2 2</p>

<p>3 1</p>

<p>2 3</p>

<p>1 1</p>

<h3 id="예제-출력">예제 출력</h3>

<p>4</p>

<h3 id="힌트">힌트</h3>

<p>O . . .</p>

<p>. O O .</p>

<p>O O . .</p>

<h4 id="접근방법">접근방법</h4>

<p>탐색 문제이고, 군집군 검사? 이런 문제를 어떻게 부르는지는 잘 모르겠지만, 가까이 있는 동일한 개체를 찾아내는 문제의 표본이라고 할 수 있는 문제이다.
단순한 BFS / DFS 탐색 문제하고는 다른데, 그 이유는 이 문제는 군집을 찾아내는 문제이기 때문이다. 왜냐하면 DFS/BFS로 탐색을 하더라도, 한번의 Depth에서 모든 연결되어 있는 노드를
검색할 수 없기 때문에, 중간에 탐색이 한 번 끊기게 되고 그 다음에 탐색을 시작하게 되면 사실 붙어있는 같은 군집인데 실제로는 다른 군집을 찾게 되기 때문이다.</p>

<p>위의 힌트를 가지고 예를 들어 보자.</p>

<p>(2, 2)의 점(이 문제에서는 첫번째 행과 첫번째 열이 1로 주어졌다)에서 DFS로 탐색을 시작한다고 해 보자.</p>

<p>그렇다면 실제로 연결되어 있는 노드는 (2, 3), (3, 2), (3, 1)이다. 하지만 첫번째 Depth에서는 (2, 3)과 (3, 2)를 탐색하고, 다음 Depth에서 (3, 1)을 탐색하게 되는데,
이 경우에 각각의 Depth에서의 탐색은 서로 다른 군집으로 인식할 수 있기 때문에, 이를 제대로 세 주어야 한다.</p>

<p>그리고 이 문제를 풀면서, 처음에는 각각의 노드의 순서쌍을 배열 int[] node = new int[2]로 선언해서 사용했는데, 이렇게 하면 HashSet에 넣을 때, 같은 순서쌍이라도 다른 객체로 인식되어서
HashSet에 중복된 노드가 들어가게 된다. 또한 중복 검사, 예를 들면 visitedNodes.contains()와 같은 메소드에서 항상 false만을 리턴하게 된다.
그래서 ArrayList<Integer>로 선언해서 사용했는데, 더 간단한 방법이 있을 것 같아서 조금 더 공부할 필요를 느꼈다.</Integer></p>

<h4 id="자바-코드">자바 코드</h4>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="kn">package</span> <span class="nn">boj</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">java.util.*</span><span class="o">;</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">newboj1743</span> <span class="o">{</span>

    <span class="kd">static</span> <span class="kt">int</span><span class="o">[]</span> <span class="no">MAX_AMOUNT</span><span class="o">;</span> <span class="c1">// 군집을 세기 위해서 선언한 배열</span>
    <span class="c1">// 각각 노드의 군집의 크기를 저장하기 위한 배열로 크기는 nodeList.size()와 같다.</span>
    <span class="kd">static</span> <span class="nc">HashSet</span><span class="o">&lt;</span><span class="nc">ArrayList</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;&gt;</span> <span class="n">visitedNodes</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HashSet</span><span class="o">&lt;&gt;();</span>
    <span class="c1">// 방문한 노드를 저장하기 위한 HashSet</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">Scanner</span> <span class="n">scanner</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Scanner</span><span class="o">(</span><span class="nc">System</span><span class="o">.</span><span class="na">in</span><span class="o">);</span>
        <span class="nc">ArrayList</span><span class="o">&lt;</span><span class="nc">ArrayList</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;&gt;</span> <span class="n">condition</span> <span class="o">=</span> <span class="n">setCondition</span><span class="o">(</span><span class="n">scanner</span><span class="o">);</span>
        <span class="nc">ArrayList</span><span class="o">&lt;</span><span class="nc">ArrayList</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;&gt;</span> <span class="n">nodeList</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;();</span>

        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">condition</span><span class="o">.</span><span class="na">size</span><span class="o">();</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="n">nodeList</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">condition</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">i</span><span class="o">));</span>
        <span class="o">}</span>

        <span class="no">MAX_AMOUNT</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">nodeList</span><span class="o">.</span><span class="na">size</span><span class="o">()];</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="no">MAX_AMOUNT</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="no">MAX_AMOUNT</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span>
            
            <span class="c1">//군집 배열의 값을 1로 초기화</span>
        <span class="o">}</span>

        <span class="k">for</span> <span class="o">(</span><span class="nc">ArrayList</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">node</span> <span class="o">:</span> <span class="n">nodeList</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">if</span> <span class="o">(!</span><span class="n">visitedNodes</span><span class="o">.</span><span class="na">contains</span><span class="o">(</span><span class="n">node</span><span class="o">))</span> <span class="o">{</span>
            <span class="c1">//nodeList에 있어서 각각의 node가 방문한 노드가 아니라면 dfs를 시작한다.</span>
                <span class="n">dfs</span><span class="o">(</span><span class="n">node</span><span class="o">,</span> <span class="n">nodeList</span><span class="o">,</span> <span class="n">condition</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="mi">0</span><span class="o">),</span> <span class="n">nodeList</span><span class="o">.</span><span class="na">indexOf</span><span class="o">(</span><span class="n">node</span><span class="o">));</span>
            <span class="o">}</span>
        <span class="o">}</span>

        <span class="nc">OptionalInt</span> <span class="n">max</span> <span class="o">=</span> <span class="nc">Arrays</span><span class="o">.</span><span class="na">stream</span><span class="o">(</span><span class="no">MAX_AMOUNT</span><span class="o">).</span><span class="na">max</span><span class="o">();</span>
        <span class="kt">int</span> <span class="n">answer</span> <span class="o">=</span> <span class="n">max</span><span class="o">.</span><span class="na">getAsInt</span><span class="o">();</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">answer</span><span class="o">);</span>


    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="nc">ArrayList</span><span class="o">&lt;</span><span class="nc">ArrayList</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;&gt;</span> <span class="nf">setCondition</span><span class="o">(</span><span class="nc">Scanner</span> <span class="n">scanner</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="n">scanner</span><span class="o">.</span><span class="na">nextInt</span><span class="o">();</span>
        <span class="kt">int</span> <span class="n">y</span> <span class="o">=</span> <span class="n">scanner</span><span class="o">.</span><span class="na">nextInt</span><span class="o">();</span>
        <span class="kt">int</span> <span class="n">repeat</span> <span class="o">=</span> <span class="n">scanner</span><span class="o">.</span><span class="na">nextInt</span><span class="o">();</span>
        <span class="n">scanner</span><span class="o">.</span><span class="na">nextLine</span><span class="o">();</span>

        <span class="nc">ArrayList</span><span class="o">&lt;</span><span class="nc">ArrayList</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;&gt;</span> <span class="n">answer</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;();</span>
        <span class="nc">ArrayList</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">condition</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;();</span>
        <span class="n">condition</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">x</span><span class="o">);</span>
        <span class="n">condition</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">y</span><span class="o">);</span>
        <span class="n">answer</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">condition</span><span class="o">);</span>

        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">repeat</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="kt">int</span> <span class="n">first</span> <span class="o">=</span> <span class="n">scanner</span><span class="o">.</span><span class="na">nextInt</span><span class="o">();</span>
            <span class="kt">int</span> <span class="n">second</span> <span class="o">=</span> <span class="n">scanner</span><span class="o">.</span><span class="na">nextInt</span><span class="o">();</span>
            <span class="nc">ArrayList</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">temp</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;();</span>
            <span class="n">temp</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">first</span><span class="o">);</span>
            <span class="n">temp</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">second</span><span class="o">);</span>

            <span class="n">answer</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">temp</span><span class="o">);</span>

        <span class="o">}</span>
        <span class="k">return</span> <span class="n">answer</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="nc">ArrayList</span><span class="o">&lt;</span><span class="nc">ArrayList</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;&gt;</span> <span class="nf">connectedNodeChecker</span>
            <span class="o">(</span><span class="nc">ArrayList</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">node</span><span class="o">,</span> <span class="nc">ArrayList</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">limit</span><span class="o">,</span> <span class="nc">ArrayList</span><span class="o">&lt;</span><span class="nc">ArrayList</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;&gt;</span> <span class="n">condition</span><span class="o">)</span> <span class="o">{</span>
            
        <span class="c1">// 방향 배열 선언</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">xDirections</span> <span class="o">=</span> <span class="o">{-</span><span class="mi">1</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">};</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">yDirections</span> <span class="o">=</span> <span class="o">{</span><span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="o">-</span><span class="mi">1</span><span class="o">,</span> <span class="mi">1</span><span class="o">};</span>

        <span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="mi">0</span><span class="o">);</span>
        <span class="kt">int</span> <span class="n">y</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="mi">1</span><span class="o">);</span>

        <span class="nc">ArrayList</span><span class="o">&lt;</span><span class="nc">ArrayList</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;&gt;</span> <span class="n">answer</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;();</span>

        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">4</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="kt">int</span> <span class="n">calculatedX</span> <span class="o">=</span> <span class="n">x</span> <span class="o">+</span> <span class="n">xDirections</span><span class="o">[</span><span class="n">i</span><span class="o">];</span>
            <span class="kt">int</span> <span class="n">calculatedY</span> <span class="o">=</span> <span class="n">y</span> <span class="o">+</span> <span class="n">yDirections</span><span class="o">[</span><span class="n">i</span><span class="o">];</span>

            <span class="k">if</span> <span class="o">(</span><span class="n">calculatedX</span> <span class="o">&lt;</span> <span class="mi">1</span> <span class="o">||</span> <span class="n">calculatedX</span> <span class="o">&gt;</span> <span class="n">limit</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="mi">0</span><span class="o">)</span> <span class="o">||</span>
            <span class="n">calculatedY</span> <span class="o">&lt;</span> <span class="mi">1</span> <span class="o">||</span> <span class="n">calculatedY</span> <span class="o">&gt;</span> <span class="n">limit</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="mi">1</span><span class="o">))</span> <span class="o">{</span>
            <span class="o">}</span>
            <span class="k">else</span> <span class="o">{</span>
                <span class="nc">ArrayList</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">temp</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;();</span>
                <span class="n">temp</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">calculatedX</span><span class="o">);</span>
                <span class="n">temp</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">calculatedY</span><span class="o">);</span>
                
                <span class="c1">// 각각 4방향의 연결된 노드 중에서, condition에 포함되어 있는 노드라면 answer에 추가한다.</span>

                <span class="k">if</span> <span class="o">(</span><span class="n">condition</span><span class="o">.</span><span class="na">contains</span><span class="o">(</span><span class="n">temp</span><span class="o">))</span> <span class="o">{</span>
                    <span class="n">answer</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">temp</span><span class="o">);</span>
                <span class="o">}</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">answer</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">dfs</span><span class="o">(</span><span class="nc">ArrayList</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">node</span><span class="o">,</span> <span class="nc">ArrayList</span><span class="o">&lt;</span><span class="nc">ArrayList</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;&gt;</span> <span class="n">nodeList</span><span class="o">,</span>
                           <span class="nc">ArrayList</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">limit</span><span class="o">,</span> <span class="kt">int</span> <span class="n">number</span><span class="o">)</span> <span class="o">{</span>
                           
        <span class="c1">// number는 군집 배열의 인덱스를 나타낸다.</span>
                           
        <span class="n">visitedNodes</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">node</span><span class="o">);</span>
        
        <span class="c1">// connectedNodeChecker를 통해서 연결된 노드를 찾아내고, 그 노드가 방문한 노드가 아니라면 dfs를 시작한다.</span>
        <span class="nc">ArrayList</span><span class="o">&lt;</span><span class="nc">ArrayList</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;&gt;</span> <span class="n">connectedNodes</span> <span class="o">=</span> <span class="n">connectedNodeChecker</span><span class="o">(</span><span class="n">node</span><span class="o">,</span> <span class="n">limit</span><span class="o">,</span> <span class="n">nodeList</span><span class="o">);</span>

        <span class="k">if</span> <span class="o">(</span><span class="n">connectedNodes</span><span class="o">.</span><span class="na">size</span><span class="o">()</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">return</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="k">else</span> <span class="o">{</span>
            <span class="k">for</span> <span class="o">(</span><span class="nc">ArrayList</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">connectedNode</span> <span class="o">:</span> <span class="n">connectedNodes</span><span class="o">)</span> <span class="o">{</span>
                <span class="k">if</span> <span class="o">(!</span><span class="n">visitedNodes</span><span class="o">.</span><span class="na">contains</span><span class="o">(</span><span class="n">connectedNode</span><span class="o">))</span> <span class="o">{</span>
                
                    <span class="no">MAX_AMOUNT</span><span class="o">[</span><span class="n">number</span><span class="o">]</span> <span class="o">+=</span> <span class="mi">1</span><span class="o">;</span>
                    <span class="n">dfs</span><span class="o">(</span><span class="n">connectedNode</span><span class="o">,</span> <span class="n">nodeList</span><span class="o">,</span> <span class="n">limit</span><span class="o">,</span> <span class="n">number</span><span class="o">);</span>
                <span class="o">}</span>
            <span class="o">}</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>

</code></pre></div></div>]]></content><author><name>ash tensor</name></author><category term="백준" /><category term="PS" /><category term="JAVA" /><category term="파이썬" /><summary type="html"><![CDATA[[백준] 백준 1743번 :: 음식물 피하기 :: 실버 1]]></summary></entry><entry><title type="html">[백준] 백준 1987번 :: 알파벳 :: 골드 4</title><link href="http://localhost:4000/%EB%B0%B1%EC%A4%80/ps/java/2024/02/21/boj1987.html" rel="alternate" type="text/html" title="[백준] 백준 1987번 :: 알파벳 :: 골드 4" /><published>2024-02-21T00:00:00+09:00</published><updated>2024-02-21T00:00:00+09:00</updated><id>http://localhost:4000/%EB%B0%B1%EC%A4%80/ps/java/2024/02/21/boj1987</id><content type="html" xml:base="http://localhost:4000/%EB%B0%B1%EC%A4%80/ps/java/2024/02/21/boj1987.html"><![CDATA[<h2 id="백준-백준-1987번--알파벳--골드-4">[백준] 백준 1987번 :: 알파벳 :: 골드 4</h2>

<h3 id="문제-설명">문제 설명</h3>

<p>세로
$R$칸, 가로
$C$칸으로 된 표 모양의 보드가 있다. 보드의 각 칸에는 대문자 알파벳이 하나씩 적혀 있고, 좌측 상단 칸 (
$1$행
$1$열) 에는 말이 놓여 있다.</p>

<p>말은 상하좌우로 인접한 네 칸 중의 한 칸으로 이동할 수 있는데, 새로 이동한 칸에 적혀 있는 알파벳은 지금까지 지나온 모든 칸에 적혀 있는 알파벳과는 달라야 한다. 즉, 같은 알파벳이 적힌 칸을 두 번 지날 수 없다.</p>

<p>좌측 상단에서 시작해서, 말이 최대한 몇 칸을 지날 수 있는지를 구하는 프로그램을 작성하시오. 말이 지나는 칸은 좌측 상단의 칸도 포함된다.</p>

<p><strong>입력</strong></p>

<p>첫째 줄에
$R$과
$C$가 빈칸을 사이에 두고 주어진다. (
$1 ≤ R,C ≤ 20$) 둘째 줄부터
$R$개의 줄에 걸쳐서 보드에 적혀 있는
$C$개의 대문자 알파벳들이 빈칸 없이 주어진다.</p>

<p><strong>출력</strong></p>

<p>첫째 줄에 말이 지날 수 있는 최대의 칸 수를 출력한다.</p>

<h3 id="제한시간">제한시간</h3>

<p>2 초	256 MB</p>

<h3 id="예제-입력">예제 입력</h3>

<p>2 4
CAAB
ADCB</p>

<h3 id="예제-출력">예제 출력</h3>

<p>3</p>

<h4 id="접근방법">접근방법</h4>

<p>처음에는 백트래킹을 위해 지금까지 지나온 경로를 모두 기억하는 무식한 방법으로 접근했다. 하지만 이 방법은 풀이는 성공했지만 메모리 조건을 초과해서 메모리 초과가 발생했다.
(그 와중에도 파이썬으로는 풀이가 성공했지만 자바로는 메모리 초과가 발생했다는 점이 재밌다. 아무래도 파이썬의 메모리 보정이 꽤 크기도 하고, 파이썬으로 문제풀이를 하던 습관 때문에 파이썬의 리스트에 대응되는
자바의 ArrayList를 남발하면서 메모리 초과가 발생했던 것 같다.)</p>

<p>그래서 백트래킹을 위해 지금까지 지나온 경로를 모두 기억하는 것이 아니라 알파벳의 원소별로 방문 여부를 체크하는 방법으로 접근했다. 이 방법은 메모리 초과가 발생하지 않았다.</p>

<p>사실 BFS 또는 DFS로 접근하는데 있어서, 개인적으로는 재귀로 구현하는 DFS는 메모리 초과가 발생할 가능성이 크기 때문에 되도록이면 피하는 방법이지만 이번에는 재귀로 구현한 DFS로 풀이했다.</p>

<p>또한 98%의 테스트케이스에서 멈췄는데, 역시나 이는 입력 : 1 1 / A 일때, 1이 출력되어야 하는데 0이 출력되었기 때문이다. 이는 최소한 한 번은 이동해야 answer에 값이 할당되는데, 그렇지 않아서 발생한 문제였다.
이런 실수를 하지 말아야 한다고 생각하는데, 안타깝다 ㅠㅠ</p>

<p>아, 그리고 어차피 알파벳은 26개이기 떼문에 26이 넘어가면 더 이상 탐색할 필요가 없다.</p>

<h4 id="자바-코드">자바 코드</h4>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="kn">package</span> <span class="nn">boj</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.io.BufferedReader</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.io.IOException</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.io.InputStreamReader</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.ArrayList</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.StringTokenizer</span><span class="o">;</span>


<span class="kd">public</span> <span class="kd">class</span> <span class="nc">newboj1987</span> <span class="o">{</span>
    <span class="c1">// 상하좌우 순서로 방향배열 선언</span>
    <span class="kd">static</span> <span class="kt">int</span> <span class="no">R</span><span class="o">,</span> <span class="no">C</span><span class="o">;</span>
    <span class="kd">static</span> <span class="kt">int</span><span class="o">[][]</span> <span class="n">theMap</span><span class="o">;</span>
    <span class="kd">static</span> <span class="kt">int</span><span class="o">[]</span> <span class="n">x_way</span> <span class="o">=</span> <span class="o">{-</span><span class="mi">1</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">};</span>
    <span class="kd">static</span> <span class="kt">int</span><span class="o">[]</span> <span class="n">y_way</span> <span class="o">=</span> <span class="o">{</span><span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="o">-</span><span class="mi">1</span><span class="o">,</span> <span class="mi">1</span><span class="o">};</span>
    <span class="kd">static</span> <span class="kt">int</span> <span class="n">answer</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
    <span class="kd">static</span> <span class="kt">boolean</span><span class="o">[]</span> <span class="n">visited</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">boolean</span><span class="o">[</span><span class="mi">26</span><span class="o">];</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">dfs</span><span class="o">(</span><span class="kt">int</span> <span class="n">x</span><span class="o">,</span> <span class="kt">int</span> <span class="n">y</span><span class="o">,</span> <span class="kt">int</span> <span class="n">count</span><span class="o">)</span> <span class="o">{</span>
    
    <span class="c1">//answer를 1로 초기화 하거나 문제공간이 1, 1인 경우에는 1로 리턴해도 된다.</span>
        <span class="k">if</span> <span class="o">(</span><span class="no">R</span> <span class="o">==</span> <span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="no">C</span> <span class="o">==</span> <span class="mi">1</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">answer</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span>
            <span class="k">return</span><span class="o">;</span>
        <span class="o">}</span>
        
        <span class="c1">// 26개 이상의 알파벳을 지나면 더 이상 탐색할 필요가 없다.</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">count</span> <span class="o">&gt;=</span> <span class="mi">26</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">answer</span> <span class="o">=</span> <span class="n">count</span><span class="o">;</span>
            <span class="k">return</span><span class="o">;</span>
        <span class="o">}</span>
        
        <span class="c1">// 이미 방문한 알파벳이라면 answer에 count를 할당하고 리턴한다.</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">visited</span><span class="o">[</span><span class="n">theMap</span><span class="o">[</span><span class="n">x</span><span class="o">][</span><span class="n">y</span><span class="o">]])</span> <span class="o">{</span>
            <span class="n">answer</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">answer</span><span class="o">,</span> <span class="n">count</span><span class="o">);</span>
            <span class="k">return</span><span class="o">;</span>
        <span class="o">}</span>
       
        <span class="k">else</span> <span class="o">{</span>
            <span class="n">visited</span><span class="o">[</span><span class="n">theMap</span><span class="o">[</span><span class="n">x</span><span class="o">][</span><span class="n">y</span><span class="o">]]</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
            <span class="nc">ArrayList</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">[]&gt;</span> <span class="n">moveList</span> <span class="o">=</span>  <span class="n">ableMove</span><span class="o">(</span><span class="n">x</span><span class="o">,</span><span class="n">y</span><span class="o">);</span>
            <span class="k">for</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">coordinates</span> <span class="o">:</span> <span class="n">moveList</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">dfs</span><span class="o">(</span><span class="n">coordinates</span><span class="o">[</span><span class="mi">0</span><span class="o">],</span> <span class="n">coordinates</span><span class="o">[</span><span class="mi">1</span><span class="o">],</span> <span class="n">count</span><span class="o">+</span><span class="mi">1</span><span class="o">);</span>
            <span class="o">}</span>
        <span class="o">}</span>

        <span class="n">visited</span><span class="o">[</span><span class="n">theMap</span><span class="o">[</span><span class="n">x</span><span class="o">][</span><span class="n">y</span><span class="o">]]</span> <span class="o">=</span> <span class="kc">false</span><span class="o">;</span>

    <span class="o">}</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">IOException</span> <span class="o">{</span>
        <span class="nc">BufferedReader</span> <span class="n">br</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">BufferedReader</span><span class="o">(</span><span class="k">new</span> <span class="nc">InputStreamReader</span><span class="o">(</span><span class="nc">System</span><span class="o">.</span><span class="na">in</span><span class="o">));</span>
        <span class="nc">StringTokenizer</span> <span class="n">st</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">StringTokenizer</span><span class="o">(</span><span class="n">br</span><span class="o">.</span><span class="na">readLine</span><span class="o">());</span>

        <span class="no">R</span> <span class="o">=</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="n">st</span><span class="o">.</span><span class="na">nextToken</span><span class="o">());</span>
        <span class="no">C</span> <span class="o">=</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="n">st</span><span class="o">.</span><span class="na">nextToken</span><span class="o">());</span>
        <span class="n">theMap</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="no">R</span><span class="o">][</span><span class="no">C</span><span class="o">];</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="no">R</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="nc">String</span> <span class="n">str</span> <span class="o">=</span> <span class="n">br</span><span class="o">.</span><span class="na">readLine</span><span class="o">();</span>
            <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="no">C</span><span class="o">;</span> <span class="n">j</span><span class="o">++)</span> <span class="o">{</span>
                <span class="n">theMap</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">]</span> <span class="o">=</span> <span class="n">str</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">j</span><span class="o">)</span> <span class="o">-</span> <span class="sc">'A'</span><span class="o">;</span>
            <span class="o">}</span>
        <span class="o">}</span>

        <span class="n">dfs</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">);</span>

        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">answer</span><span class="o">);</span>

    <span class="o">}</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="nc">ArrayList</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">[]&gt;</span> <span class="nf">ableMove</span><span class="o">(</span><span class="kt">int</span> <span class="n">x</span><span class="o">,</span> <span class="kt">int</span> <span class="n">y</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">ArrayList</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">[]&gt;</span> <span class="n">coordinates</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;();</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">4</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="kt">int</span> <span class="n">x_position</span> <span class="o">=</span> <span class="n">x</span> <span class="o">+</span> <span class="n">x_way</span><span class="o">[</span><span class="n">i</span><span class="o">];</span>
            <span class="kt">int</span> <span class="n">y_position</span> <span class="o">=</span> <span class="n">y</span> <span class="o">+</span> <span class="n">y_way</span><span class="o">[</span><span class="n">i</span><span class="o">];</span>
            
            <span class="c1">// 배열을 벗어나지 않는지 체크</span>

            <span class="k">if</span><span class="o">(</span><span class="n">x_position</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">x_position</span> <span class="o">&gt;</span> <span class="n">theMap</span><span class="o">.</span><span class="na">length</span><span class="o">-</span><span class="mi">1</span> <span class="o">||</span> <span class="n">y_position</span> <span class="o">&lt;</span> <span class="mi">0</span> 
                <span class="o">||</span> <span class="n">y_position</span> <span class="o">&gt;</span> <span class="n">theMap</span><span class="o">[</span><span class="mi">0</span><span class="o">].</span><span class="na">length</span><span class="o">-</span><span class="mi">1</span> <span class="o">){</span>
            <span class="o">}</span>
            <span class="k">else</span> <span class="o">{</span>
                <span class="kt">int</span><span class="o">[]</span> <span class="n">temp</span> <span class="o">=</span> <span class="o">{</span><span class="n">x_position</span><span class="o">,</span> <span class="n">y_position</span><span class="o">};</span>
                <span class="n">coordinates</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">temp</span><span class="o">);</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">coordinates</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>

</code></pre></div></div>]]></content><author><name>ash tensor</name></author><category term="백준" /><category term="PS" /><category term="JAVA" /><summary type="html"><![CDATA[[백준] 백준 1987번 :: 알파벳 :: 골드 4]]></summary></entry><entry><title type="html">[WEB]GCP(google cloud platform) 프리 티어 VM 생성 / MYSQL 서버 연결</title><link href="http://localhost:4000/web/2024/02/17/gcp-free-tier-settings.html" rel="alternate" type="text/html" title="[WEB]GCP(google cloud platform) 프리 티어 VM 생성 / MYSQL 서버 연결" /><published>2024-02-17T00:00:00+09:00</published><updated>2024-02-17T00:00:00+09:00</updated><id>http://localhost:4000/web/2024/02/17/gcp-free-tier-settings</id><content type="html" xml:base="http://localhost:4000/web/2024/02/17/gcp-free-tier-settings.html"><![CDATA[<h2 id="webgcpgoogle-cloud-platform-프리-티어-vm-생성">[WEB]GCP(google cloud platform) 프리 티어 VM 생성</h2>

<p>클라우드 서비스로 가장 우선적으로 선택하는 것 중에 하나가 바로 AWS일 것이다. 하지만 AWS 같은 경우에는 프리티어 VM의 사용 기한이 1년으로, 
1년이 지나면 자동으로 등록해 놓은 신용카드로 사용 요금이 빠져나간다. 그래서 나 같은 경우에는 프리티어로 사용하던 VM의 사용 기한이 끝나 매달 2만원 가량의 요금이
 지불되고 있는데… 솔직히 돈이 너무 아까웠다. 그래서 이에 대한 대책으로 다른 클라우드 서비스 프리 티어를 살펴보고 최종적으로 GCP에 MYSQL 서버를 설치하고 접속되게 변경했다.</p>

<h3 id="오라클은-가입이-안됨">오라클은 가입이 안됨…</h3>

<p>사실 이런 프리티어 클라우드 서비스 중에 가장 성능이 좋은 서비스는 오라클이다. 그런데 이 오라클 클라우드의 가장 큰 단점은 회원가입이 어럽다는 점이다…
농담이 아니라 실제 많은 사람들이 호소하는 불편함으로, 이 마지막 화면에서 “트랜잭션 오류가 발생하였습니다.” 라는 오류를 뱉으며 회원가입이 안 되는 오류가 있다.</p>

<p><img src="/img/posts/gcp/oraclefail.png" style="width: 80%" /></p>

<p>바로 이 화면이다. 해결 방법으로는 오라클 고객센터 라이브 챗으로 풀어달라고 하면 해결된다고는 하는데, 나 같은 경우에는 응답이 없어서, 그냥 GCP로 바꾸기로 했다.</p>

<h3 id="gcp">GCP</h3>

<p>GCP와 오라클이 프리티어에서 가장 큰 강점을 가지는 것은 바로 영구 무료 유지라는 점이다. AWS는 물론이고 MS 애저도 1년이 지나면 얄짤없이 유료화 시키는데 비해서
프리 티어 성능 안에서는 1년이 지나건 몇년이 지나건 무료로 서비스를 사용할 수 있다는 점이 큰 매력이다.</p>

<p><img src="/img/posts/gcp/gcp1.png" style="width: 80%" /></p>

<p>이 사진에서 알수있듯, 오리건, 아이오와, 사우스캐롤라이나의 VM이라면 30GB 용량까지 평생 무료로 사용할 수 있다. 하지만 스펙이 저열한데, 프리티어의 e2-micro
성능은 vcpu 1개와 0.5GB 메모리, 그리고 1GB 트래픽만 허용된다.</p>

<p>vcpu 1개의 경우에는 대략 0.2Ghz 정도의 성능을 가지는데, 아무리 무료라고는 하지만 좋은 성능은 아니다. 0.2Ghz다. 0.2Ghz!! 아마 피쳐폰보다 성능이 안좋을지도 모른다.
게다가 램도 겨우 500메가 정도로, 정말 20달러짜리 라즈베리파이보다 성능이 안좋을 것이다. 라즈베리파이는 단 돈 5만원에 2Ghz CPU 8개가 달려있는데…</p>

<p>아무튼 프리티어는 프리티어인 이유가 있다. 간단한 실증 정도의 테스트만 가능한 환경이니 너무 큰 프로젝트는 올리지 않는 편이 좋다.</p>

<h4 id="vm생성">VM생성</h4>

<p><a href="https://cloud.google.com/free/?utm_source=google&amp;utm_medium=cpc&amp;utm_campaign=japac-KR-all-en-dr-BKWS-all-core-trial-EXA-dr-1605216&amp;utm_content=text-ad-none-none-DEV_c-CRE_644033776725-ADGP_Hybrid+%7C+BKWS+-+EXA+%7C+Txt+~+GCP_General_core+brand_main-KWID_43700074755444107-kwd-87853815&amp;userloc_1009871-network_g&amp;utm_term=KW_gcp&amp;gad_source=1&amp;gclid=CjwKCAiArLyuBhA7EiwA-qo80PzDfq52iWQuvaP7LEccHJPst6zFmWL2s0Fu31ddUOkLIflDbWUbBxoCogEQAvD_BwE&amp;gclsrc=aw.ds&amp;hl=ko">이 페이지(GCP)</a>에서 회원가입을 한 후에,</p>

<p><img src="/img/posts/gcp/gcp2.png" style="width: 80%" /></p>

<p>“사용” 버튼을 누른후 인스턴스 만들기를 선택하면 된다. 그리고 난 뒤에</p>

<p><img src="/img/posts/gcp/gcp3.png" style="width: 80%" /></p>

<p>아까 언급했던 것처럼, 오리건, 아이오와, 사우스캐롤라이나와 같이 프리티어를 제공하는 리전을 선택한 뒤에(아마도 서부가 아주 조금이라도 더 빠를 것이다) 머신 구성에서는
 E2를 선택하고</p>

<p><img src="/img/posts/gcp/gcp6.png" style="width: 80%" /></p>

<p>엑세스 범위: 모든 클라우드 API에 대해 전체 액세스 허용, HTTP, HTTPS 트래픽 허용을 선택해 준다.</p>

<p><img src="/img/posts/gcp/gcp4.png" style="width: 80%" /></p>

<p>머신 유형에서는 프리티어를 제공해주는 e2-micro를 선택하자. 이후 부팅 디스크에서 새로운 SSD 영구 디스크, 크기는 30GB내에서 원하는 만큼 
선택하면 된다.</p>

<p><img src="/img/posts/gcp/gcp5.png" style="width: 80%" /></p>

<p>이후 인스턴스를 생성한 뒤 SSH로 접속을 선택하면 흔히 사용했던 bash가 새로운 브라우저 창으로 등장할 것이다.</p>

<h3 id="mysql-설치-및-설정">MYSQL 설치 및 설정</h3>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>apt-get install mariadb-server mariadb-client
/usr/bin/mysql_secure_installation (db초기화 작업)
</code></pre></div></div>

<p>나는 우분투 환경이기 때문에 apt-get install mariadb-server mariadb-client로 mysql을 설치했다. 그리고 이 이후에 방화벽을 설정해야한다.</p>

<p>VCP 네트워크의 방화벽 - 방화벽 규칙 만들기를 통해서 새로운 방화벽 규칙을 만들어야 한다 (프로젝트 창 옆에 있는 검색창에 방화벽이라고 검색해도 찾을 수 있다.)</p>

<p><img src="/img/posts/gcp/mysql1.png" style="width: 80%" /></p>

<p>8080포트, tcp/ip 프로토콜에 대해서 0.0.0.0/0 (모든 ip 입력에 대해서 허용, 자신의 IP범위를 적어 넣는편이 당연히 보안에 무조건 좋다)</p>

<p><img src="/img/posts/gcp/mysql2.png" style="width: 80%" /></p>

<p>3306포트에 대해서 (mysql) 접근 허용 방화벽 규칙을 설정해 준다. 이 이후에, 로컬에서만 접속할 수 있도록 바인딩 해 놓은 mysql 설정 파일도 수정해야한다.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>nano /etc/mysql/mariadb.conf.d/50-server.cnf 
</code></pre></div></div>

<p>룰 한 뒤에, bind-address= 127.0.0.1 을 지우던지, 주석처리 해야 한다.</p>

<p><img src="/img/posts/gcp/mysql3.png" style="width: 80%" /></p>

<p>이러면 mysql 서버를 사용할 기본적인 설정은 모두 끝났다!</p>]]></content><author><name>ash tensor</name></author><category term="WEB" /><summary type="html"><![CDATA[[WEB]GCP(google cloud platform) 프리 티어 VM 생성]]></summary></entry></feed>